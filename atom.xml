<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://ygytl.github.io/</id>
    <title>Grace</title>
    <updated>2020-06-13T15:37:19.922Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://ygytl.github.io/"/>
    <link rel="self" href="https://ygytl.github.io/atom.xml"/>
    <subtitle>Grace&apos;s blog</subtitle>
    <logo>https://ygytl.github.io/images/avatar.png</logo>
    <icon>https://ygytl.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, Grace</rights>
    <entry>
        <title type="html"><![CDATA[Crackme.exe脱壳与破解]]></title>
        <id>https://ygytl.github.io/post/crackmeexe-tuo-ke-yu-po-jie/</id>
        <link href="https://ygytl.github.io/post/crackmeexe-tuo-ke-yu-po-jie/">
        </link>
        <updated>2020-06-12T15:37:49.000Z</updated>
        <content type="html"><![CDATA[<p><strong>1.</strong> <em><strong>*首先使用PEid工具对软件进行分析，查看是否有壳*</strong></em></p>
<p>答：.pediy区块是外壳程序所加载的部分，所以改程序有壳。</p>
<figure data-type="image" tabindex="1"><img src="file:///C:%5CUsers%5C22892%5CAppData%5CLocal%5CTemp%5Cksohtml18252%5Cwps1.png" alt="img" loading="lazy"></figure>
<figure data-type="image" tabindex="2"><img src="file:///C:%5CUsers%5C22892%5CAppData%5CLocal%5CTemp%5Cksohtml18252%5Cwps2.png" alt="img" loading="lazy"></figure>
<p><strong>2.</strong> <em><strong>*若有壳，按照所学的脱壳方式进行脱壳*</strong></em></p>
<p><em><strong>*(1)查找程序的原始入口OEP，根据跨段指令寻找OEP*</strong></em></p>
<ol>
<li>运行OllyDbg，调试选项中“Event”将暂停点设置在主模块的入口点。打开CRACKME.EXE，程序会停在00408000h处。</li>
</ol>
<figure data-type="image" tabindex="3"><img src="file:///C:%5CUsers%5C22892%5CAppData%5CLocal%5CTemp%5Cksohtml18252%5Cwps3.png" alt="img" loading="lazy"></figure>
<p>2)按F8执行到00408001h处，再按F7跳转到004080C8h处。</p>
<figure data-type="image" tabindex="4"><img src="file:///C:%5CUsers%5C22892%5CAppData%5CLocal%5CTemp%5Cksohtml18252%5Cwps4.png" alt="img" loading="lazy"></figure>
<p>3)004080C8h一直运行到00408135h处，会跳转到00020000h处。</p>
<figure data-type="image" tabindex="5"><img src="file:///C:%5CUsers%5C22892%5CAppData%5CLocal%5CTemp%5Cksohtml18252%5Cwps5.png" alt="img" loading="lazy"></figure>
<figure data-type="image" tabindex="6"><img src="file:///C:%5CUsers%5C22892%5CAppData%5CLocal%5CTemp%5Cksohtml18252%5Cwps6.png" alt="img" loading="lazy"></figure>
<p>跳转后：</p>
<figure data-type="image" tabindex="7"><img src="file:///C:%5CUsers%5C22892%5CAppData%5CLocal%5CTemp%5Cksohtml18252%5Cwps7.png" alt="img" loading="lazy"></figure>
<p>4)从00020000h执行到000200A5h处，000200A5h到000200F0h处是一个循环,右键选中000200F2h处，按F4跳出循环到000200F2h处。</p>
<figure data-type="image" tabindex="8"><img src="file:///C:%5CUsers%5C22892%5CAppData%5CLocal%5CTemp%5Cksohtml18252%5Cwps8.png" alt="img" loading="lazy"></figure>
<p>5)从000200F2h处执行到00020147h处，jmp short 00020147指令表示00020147h处到00020178h处是一个循环；jmp short 0002010C指令表示0002010Ch处到0002017Dh处是一个循环；跳出这两个循环，到0002017Fh处。</p>
<figure data-type="image" tabindex="9"><img src="file:///C:%5CUsers%5C22892%5CAppData%5CLocal%5CTemp%5Cksohtml18252%5Cwps9.png" alt="img" loading="lazy"></figure>
<p>6)0002017Fh处会跳转到000201F6h处。</p>
<figure data-type="image" tabindex="10"><img src="file:///C:%5CUsers%5C22892%5CAppData%5CLocal%5CTemp%5Cksohtml18252%5Cwps10.png" alt="img" loading="lazy"></figure>
<figure data-type="image" tabindex="11"><img src="file:///C:%5CUsers%5C22892%5CAppData%5CLocal%5CTemp%5Cksohtml18252%5Cwps11.png" alt="img" loading="lazy"></figure>
<ol start="7">
<li>从0000201F6h处执行到00020282h处、00020283h处、00020283h处，分别可以看到popad、push 401000、retn。至此，OEP就找到了，是401000。</li>
</ol>
<figure data-type="image" tabindex="12"><img src="file:///C:%5CUsers%5C22892%5CAppData%5CLocal%5CTemp%5Cksohtml18252%5Cwps12.png" alt="img" loading="lazy"></figure>
<figure data-type="image" tabindex="13"><img src="file:///C:%5CUsers%5C22892%5CAppData%5CLocal%5CTemp%5Cksohtml18252%5Cwps13.png" alt="img" loading="lazy"></figure>
<p><em><strong>*(2)抓取内存映像文件*</strong></em></p>
<p>1)运行CRACKME.EXE程序，运行LordPE，在LordPE的选项中勾选“Full dump header from disk”，在窗口选择CRACKME，点击右键，执行“修正镜像大小”，接着执行“dump full(完整转存)”命令，即可转去内存数据并保存在文件里。命名为dumped.exe。</p>
<figure data-type="image" tabindex="14"><img src="file:///C:%5CUsers%5C22892%5CAppData%5CLocal%5CTemp%5Cksohtml18252%5Cwps14.png" alt="img" loading="lazy"></figure>
<figure data-type="image" tabindex="15"><img src="file:///C:%5CUsers%5C22892%5CAppData%5CLocal%5CTemp%5Cksohtml18252%5Cwps15.png" alt="img" loading="lazy"></figure>
<ol start="2">
<li>dumped.exe文件是不可运行的</li>
</ol>
<figure data-type="image" tabindex="16"><img src="file:///C:%5CUsers%5C22892%5CAppData%5CLocal%5CTemp%5Cksohtml18252%5Cwps16.png" alt="img" loading="lazy"></figure>
<p><em><strong>*(3)重建输入表*</strong></em></p>
<p>1)使用ImportREC工具进行修复。先运行CRACKME.EXE，接着运行ImportREC。</p>
<figure data-type="image" tabindex="17"><img src="file:///C:%5CUsers%5C22892%5CAppData%5CLocal%5CTemp%5Cksohtml18252%5Cwps17.png" alt="img" loading="lazy"></figure>
<p>2)在下列表框中选择CRACKME.EXE进程，在OEP处填入OEP的RVA值1000，单击“IAT AutoSearch”按钮，让其自动检查IAT的偏移和大小。弹出如下对话框：</p>
<figure data-type="image" tabindex="18"><img src="file:///C:%5CUsers%5C22892%5CAppData%5CLocal%5CTemp%5Cksohtml18252%5Cwps18.png" alt="img" loading="lazy"></figure>
<p>表示输入的OEP发挥作用了。</p>
<p>3)单击“Get Imports”按钮，让其分析IAT结构得到基本信息</p>
<figure data-type="image" tabindex="19"><img src="file:///C:%5CUsers%5C22892%5CAppData%5CLocal%5CTemp%5Cksohtml18252%5Cwps19.png" alt="img" loading="lazy"></figure>
<p>4)单击“Fix Dump”，选择刚才抓取的dumped.exe映像文件，将自动创建一个dumped_.exe文件。这个就是脱壳后的文件了，该文件可以正常运行。接着使用PEiD.exe查看脱壳前后的区段表。</p>
<p>脱壳前：</p>
<figure data-type="image" tabindex="20"><img src="file:///C:%5CUsers%5C22892%5CAppData%5CLocal%5CTemp%5Cksohtml18252%5Cwps20.png" alt="img" loading="lazy"></figure>
<p>脱壳后：</p>
<figure data-type="image" tabindex="21"><img src="file:///C:%5CUsers%5C22892%5CAppData%5CLocal%5CTemp%5Cksohtml18252%5Cwps21.png" alt="img" loading="lazy"></figure>
<p><em><strong>*3.脱壳后再对软件代码进行分析，分析出自己姓名所对应的正确的序列号*</strong></em></p>
<p>1)打开OllyDbg，选择dumped_.exe进行分析。</p>
<figure data-type="image" tabindex="22"><img src="file:///C:%5CUsers%5C22892%5CAppData%5CLocal%5CTemp%5Cksohtml18252%5Cwps22.png" alt="img" loading="lazy"></figure>
<p>2)先在00401226h处设置断点,在注册表填入自定义姓名和序列号。</p>
<figure data-type="image" tabindex="23"><img src="file:///C:%5CUsers%5C22892%5CAppData%5CLocal%5CTemp%5Cksohtml18252%5Cwps23.png" alt="img" loading="lazy"></figure>
<ol start="3">
<li>按F9后，得到下图所示；在00401220h处显示了Name框的内容，在00401233h处显示了序列号Serial框的内容。</li>
</ol>
<figure data-type="image" tabindex="24"><img src="file:///C:%5CUsers%5C22892%5CAppData%5CLocal%5CTemp%5Cksohtml18252%5Cwps24.png" alt="img" loading="lazy"></figure>
<ol start="4">
<li>接下来分析下图语句，首先是一个用户名的计算函数，然后是一个序列号的计算函数，接着比较两个函数计算的结果是否相等，相等则提示正确。</li>
</ol>
<figure data-type="image" tabindex="25"><img src="file:///C:%5CUsers%5C22892%5CAppData%5CLocal%5CTemp%5Cksohtml18252%5Cwps25.png" alt="img" loading="lazy"></figure>
<p>00401228h call dumped_.0040137E  //用户名的计算函数</p>
<p>00401238h call dumped_.004013D8  //序列号的计算函数</p>
<p>00401241h cmp eax,ebx  //比较用户名字和序列号计算的结果</p>
<p>00401243h je short dumped_.0040124C  //相等则提示正确</p>
<p>00401245h call dumped_.00401362  //错误提示</p>
<p>0040124Ch call dumped_.0040134D  //正确提示</p>
<ol start="5">
<li>用户名算法分析</li>
</ol>
<figure data-type="image" tabindex="26"><img src="file:///C:%5CUsers%5C22892%5CAppData%5CLocal%5CTemp%5Cksohtml18252%5Cwps26.png" alt="img" loading="lazy"></figure>
<p>0040137Eh先取出用户名，依次去出名字字符串的单字符，将用户名中的英文单词全部转换为大写。</p>
<p>0040137Eh mov esi, dword ptr ss:[esp+0x4]  //esi=username</p>
<p>00401389h cmp a1, 0x41  //比较是否小于A</p>
<p>0040138Dh cmp a1, 0x5A  //比较是否大于Z</p>
<p>00401391h Inc esi  //username&gt;&gt;1</p>
<p>00401394h call dumped_.004013D2  //将小写字母转成大写</p>
<figure data-type="image" tabindex="27"><img src="file:///C:%5CUsers%5C22892%5CAppData%5CLocal%5CTemp%5Cksohtml18252%5Cwps27.png" alt="img" loading="lazy"></figure>
<p>接着进入4013C2这个函数，将用户名每一位的ASCII值相加。</p>
<figure data-type="image" tabindex="28"><img src="file:///C:%5CUsers%5C22892%5CAppData%5CLocal%5CTemp%5Cksohtml18252%5Cwps28.png" alt="img" loading="lazy"></figure>
<ol start="6">
<li>序列号算法分析</li>
</ol>
<figure data-type="image" tabindex="29"><img src="file:///C:%5CUsers%5C22892%5CAppData%5CLocal%5CTemp%5Cksohtml18252%5Cwps29.png" alt="img" loading="lazy"></figure>
<p>取出每一位的ASCII值，然后减去0x30，即将字母转化为数字然后用edi乘0xA(0x10)，接着用edi再加上序列号。（edi与0x1234进行异或）</p>
<p>序列号edi校验：</p>
<figure data-type="image" tabindex="30"><img src="file:///C:%5CUsers%5C22892%5CAppData%5CLocal%5CTemp%5Cksohtml18252%5Cwps30.png" alt="img" loading="lazy"></figure>
<p>比较edi与ebx是否相等：</p>
<figure data-type="image" tabindex="31"><img src="file:///C:%5CUsers%5C22892%5CAppData%5CLocal%5CTemp%5Cksohtml18252%5Cwps31.png" alt="img" loading="lazy"></figure>
<p><em><strong>*4.********写出注册机********代码如下：*</strong></em></p>
<pre><code class="language-c++">#include&lt;bits/stdc++.h&gt;

using namespace std;

int main()

{

	string username;

	printf(&quot;请输入用户名: &quot;);

	cin &gt;&gt; username;

	int result = 0, l = username.length();

	for(int i=0; i&lt;l; i++){

		if(username[i]&gt;='a'&amp;&amp;username[i]&lt;='z'){

			username[i] = username[i]-'a' + 'A';

		}

		result += username[i];

	}

	result ^= 0x5678;

	result ^= 0x1234;

	printf(&quot;%d\n&quot;, result);

	return 0;

}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[1088 Rational Arithmetic (20分)题解]]></title>
        <id>https://ygytl.github.io/post/1088-rational-arithmetic-20-fen-ti-jie/</id>
        <link href="https://ygytl.github.io/post/1088-rational-arithmetic-20-fen-ti-jie/">
        </link>
        <updated>2020-06-11T15:33:26.000Z</updated>
        <content type="html"><![CDATA[<p>1088 Rational Arithmetic (20分)</p>
<p>For two rational numbers, your task is to implement the basic arithmetics, that is, to calculate their sum, difference, product and quotient.</p>
<h3 id="input-specification">Input Specification:</h3>
<p>Each input file contains one test case, which gives in one line the two rational numbers in the format <code>a1/b1 a2/b2</code>. The numerators and the denominators are all in the range of long int. If there is a negative sign, it must appear only in front of the numerator. The denominators are guaranteed to be non-zero numbers.</p>
<h3 id="output-specification">Output Specification:</h3>
<p>For each test case, print in 4 lines the sum, difference, product and quotient of the two rational numbers, respectively. The format of each line is <code>number1 operator number2 = result</code>. Notice that all the rational numbers must be in their simplest form <code>k a/b</code>, where <code>k</code> is the integer part, and <code>a/b</code> is the simplest fraction part. If the number is negative, it must be included in a pair of parentheses. If the denominator in the division is zero, output <code>Inf</code> as the result. It is guaranteed that all the output integers are in the range of <strong>long int</strong>.</p>
<h3 id="sample-input-1">Sample Input 1:</h3>
<pre><code class="language-in">2/3 -4/2
</code></pre>
<h3 id="sample-output-1">Sample Output 1:</h3>
<pre><code class="language-out">2/3 + (-2) = (-1 1/3)
2/3 - (-2) = 2 2/3
2/3 * (-2) = (-1 1/3)
2/3 / (-2) = (-1/3)
</code></pre>
<h3 id="sample-input-2">Sample Input 2:</h3>
<pre><code class="language-in">5/3 0/6
</code></pre>
<h3 id="sample-output-2">Sample Output 2:</h3>
<pre><code class="language-out">1 2/3 + 0 = 1 2/3
1 2/3 - 0 = 1 2/3
1 2/3 * 0 = 0
1 2/3 / 0 = Inf
</code></pre>
<hr>
<hr>
<pre><code class="language-c++">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
using namespace std;
long long a1, b1, a2, b2;
long long gcd(long long a, long long b)
{
    int pos = (b &gt;= 0) ? 1 : 0;
    a = abs(a);
    b = abs(b);
    if(a &lt; b) {
        swap(a, b);
    }
    while(b != 0) {
        long long c = a % b;
        a = b;
        b = c;
    }
    return (pos) ? a : -a;
}
void solve(long long x2, long long y2){
	long long g = gcd(x2,y2);
	x2 /= g; y2 /= g;
	if(x2==0){
		printf(&quot;0\n&quot;);
		return ;
	}
	long long t = 0;
	if(y2!=0) t = x2 / y2;
	else return ;
	if(y2&lt;0) x2 *= -1, y2 *= -1;
	if(t&amp;&amp;y2){
		if(t&lt;0){
			printf(&quot;(&quot;); x2 *= -1;
		}
		printf(&quot;%lld&quot;, t);
		x2 %= y2;
		if(x2) printf(&quot; %lld/%lld&quot;, x2, y2);
		if(t&lt;0) printf(&quot;)&quot;);
	}
	else{
		if(x2&lt;0) printf(&quot;(&quot;);
		printf(&quot;%lld/%lld&quot;, x2, y2);
		if(x2&lt;0) printf(&quot;)&quot;);
	}
	printf(&quot;\n&quot;);
}
void first(int k){
	long long x1 = a1, y1 = b1, x2 = a2, y2 = b2;
	long long f1 = 0, f2 = 0;
	long long g1 = gcd(x1,y1);
	long long g2 = gcd(x2,y2);
	x1 /= g1; y1 /= g1;
	x2 /= g2; y2 /= g2;
	if(y1&lt;0){
		y1 *= -1; x1 *= -1;
	}
	if(y2&lt;0){
		y2 *= -1; x2 *= -1;
	}
	if(x1&lt;0) f1 = 1;
	if(x2&lt;0) f2 = 1;
	
	long long t = 0;
	t = x1 / y1;
	if(t&amp;&amp;y1){
		if(t&lt;0){
			printf(&quot;(&quot;); x1 *= -1;
		}
		printf(&quot;%lld&quot;, t);
		x1 %= y1;
		if(x1) printf(&quot; %lld/%lld&quot;, x1, y1);
		if(t&lt;0) printf(&quot;)&quot;);
	}
	else{
		if(x1==0) printf(&quot;0&quot;);
		else{
			if(x1&lt;0) printf(&quot;(&quot;);
			printf(&quot;%lld/%lld&quot;, x1, y1);
			if(x1&lt;0) printf(&quot;)&quot;);
		}
	}
	if(k==1) printf(&quot; + &quot;);
	if(k==2) printf(&quot; - &quot;);
	if(k==3) printf(&quot; * &quot;);
	if(k==4) printf(&quot; / &quot;);
	
	t = x2 / y2;
	if(y2&lt;0) x2 *= -1, y2 *= -1;
	if(t&amp;&amp;y2){
		if(t&lt;0){
			printf(&quot;(&quot;); x2 *= -1;
		}
		printf(&quot;%lld&quot;, t);
		x2 %= y2;
		if(x2) printf(&quot; %lld/%lld&quot;, x2, y2);
		if(t&lt;0) printf(&quot;)&quot;);
	}
	else{
		if(x2==0) printf(&quot;0&quot;);
		else{
			if(x2&lt;0) printf(&quot;(&quot;);
			printf(&quot;%lld/%lld&quot;, x2, y2);
			if(x2&lt;0) printf(&quot;)&quot;);
		}
		
	}
	printf(&quot; = &quot;);
}
void solve1(){
	first(1);
	long long x1 = a1, y1 = b1, x2 = a2, y2 = b2;
	long long g = gcd(y1, y2);
	x1 *= y2/g;
	x2 *= y1/g;
	x2 += x1;
	y2 *= y1;
	y2 /= g;
	solve(x2,y2);
}
void solve2(){
	first(2);
	long long x1 = a1, y1 = b1, x2 = a2, y2 = b2;
	x2 *= -1;
	long long g = gcd(y1, y2);
	x1 *= y2/g;
	x2 *= y1/g;
	x2 += x1;
	y2 *= y1;
	y2 /= g;
	solve(x2,y2);
}
void solve3(){
	first(3);
	long long x1 = a1, y1 = b1, x2 = a2, y2 = b2;
	x2 *= x1;
	y2 *= y1;
	solve(x2,y2);
}
void solve4(){
	first(4);
	long long x1 = a1, y1 = b1, x2 = a2, y2 = b2;
	x2 *= y1;
	y2 *= x1;
	long long tmp = x2;
	x2 = y2; y2 = tmp;
	if(y2==0) printf(&quot;Inf\n&quot;);
	else solve(x2,y2);
}
int main()
{
	scanf(&quot;%lld/%lld %lld/%lld&quot;, &amp;a1, &amp;b1, &amp;a2, &amp;b2);
	solve1();
	solve2();
	solve3();
	solve4();
	return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[1086 Tree Traversals Again (25分)题解]]></title>
        <id>https://ygytl.github.io/post/1086-tree-traversals-again-25-fen-ti-jie/</id>
        <link href="https://ygytl.github.io/post/1086-tree-traversals-again-25-fen-ti-jie/">
        </link>
        <updated>2020-06-08T13:08:50.000Z</updated>
        <content type="html"><![CDATA[<p>1086 Tree Traversals Again (25分)</p>
<p>An inorder binary tree traversal can be implemented in a non-recursive way with a stack. For example, suppose that when a 6-node binary tree (with the keys numbered from 1 to 6) is traversed, the stack operations are: push(1); push(2); push(3); pop(); pop(); push(4); pop(); pop(); push(5); push(6); pop(); pop(). Then a unique binary tree (shown in Figure 1) can be generated from this sequence of operations. Your task is to give the postorder traversal sequence of this tree.</p>
<p><img src="https://images.ptausercontent.com/30" alt="img" loading="lazy"><br>
Figure 1</p>
<h3 id="input-specification">Input Specification:</h3>
<p>Each input file contains one test case. For each case, the first line contains a positive integer <em>N</em> (≤30) which is the total number of nodes in a tree (and hence the nodes are numbered from 1 to <em>N</em>). Then 2<em>N</em> lines follow, each describes a stack operation in the format: &quot;Push X&quot; where X is the index of the node being pushed onto the stack; or &quot;Pop&quot; meaning to pop one node from the stack.</p>
<h3 id="output-specification">Output Specification:</h3>
<p>For each test case, print the postorder traversal sequence of the corresponding tree in one line. A solution is guaranteed to exist. All the numbers must be separated by exactly one space, and there must be no extra space at the end of the line.</p>
<h3 id="sample-input">Sample Input:</h3>
<pre><code class="language-in">6
Push 1
Push 2
Push 3
Pop
Pop
Push 4
Pop
Pop
Push 5
Push 6
Pop
Pop
</code></pre>
<h3 id="sample-output">Sample Output:</h3>
<pre><code class="language-out">3 4 2 6 5 1
</code></pre>
<hr>
<p>题目描述：题目给定一个二叉树的中序遍历，不过，这个中序遍历要用过出栈入栈的方法得到，出栈的顺序就是这棵二叉树的中序遍历，而入栈的顺序就是先序遍历(这个有一丢丢难看出来哈，画画图就知道了)。给出先序和中序遍历，求后序遍历。</p>
</br>
<p>输入：第一行n为二叉树的节点数，接下来2*n行出栈入栈操作。</p>
<p>输出：输出这棵树的后序遍历。每个值间有个空格隔开。</p>
</br>
<p>解题思路：分别将先序遍历和中序遍历用数组存放。然后通过递归得到后序遍历结果。怎么实现已知先序和中序遍历，就能得到后序遍历呢？主要找根节点，从先序遍历的第一个值，就是树的根结点开始递归。我们用样例来分析。</p>
<table>
<thead>
<tr>
<th>index</th>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
</tr>
</thead>
<tbody>
<tr>
<td>Pre</td>
<td>1</td>
<td>2</td>
<td>3</td>
<td>4</td>
<td>5</td>
<td>6</td>
</tr>
<tr>
<td>In</td>
<td>3</td>
<td>2</td>
<td>4</td>
<td>1</td>
<td>6</td>
<td>5</td>
</tr>
</tbody>
</table>
<p>后序遍历结果：3 4 2 6 5 1</p>
<p>1）递归一开始，root=0，inl=0，inr=n-1=5，这些传入函数的值分别是根节点在先序遍历Pre中的索引位置，中序遍历的左右索引边界。</p>
<p>2）递归的退出口是非常重要的，要想好放在哪。这里就是当inl大于inr时，递归结束。</p>
<p>3）while循环得到的是根节点在中序遍历中的位置，用i来标记。</p>
<p>4）接着分别找到先序遍历中，当前根节点的左右子结点索引，充当递归的根节点索引。为什么找索引，知道索引，那么值也就很容易得到啦</p>
<p>5）左子结点直接root+1就行；右子节点需要计算一下，式子为root+(i-inl)+1，i-inl是左子树值的个数，这里需要把他们排除了，再加一，就得到右子节点的索引了。</p>
<p>6）为什么post_back写在最后面，题目求的是后序遍历嘛。放在while循环后面得到先序遍历，放在两个get_post之间得到中序遍历。</p>
<hr>
<pre><code class="language-c++">#include&lt;bits/stdc++.h&gt;
using namespace std;
int n;
const int maxn = 100;
int in[maxn], pre[maxn];
vector&lt;int&gt; post;
void get_post(int root, int l, int r){
	if(l&gt;r) return ;
	int i = l;
	while(i&lt;=r&amp;&amp;pre[root]!=in[i]) i++;
	get_post(root+1,l,i-1);
	get_post(root+i-l+1,i+1,r);
	post.push_back(pre[root]);
}
int main()
{
	string str;
	int c1=0, c2=0, c3=0, k;
	stack&lt;int&gt; s; 
	cin &gt;&gt; n;
	for(int i=0; i&lt;2*n; i++){
		cin &gt;&gt; str;
		if(str==&quot;Push&quot;){
			cin &gt;&gt; k;
			pre[c1++] = k;
			s.push(k);
		}
		else{
			in[c2++] = s.top();
			s.pop();
		}
	}
	get_post(0, 0, n-1);
	for(int i=0; i&lt;post.size(); i++){
		if(i) printf(&quot; &quot;);
		printf(&quot;%d&quot;, post[i]);
	}
	return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[1085 Perfect Sequence (25分)题解]]></title>
        <id>https://ygytl.github.io/post/1085-perfect-sequence-25-fen-ti-jie/</id>
        <link href="https://ygytl.github.io/post/1085-perfect-sequence-25-fen-ti-jie/">
        </link>
        <updated>2020-06-07T16:12:19.000Z</updated>
        <content type="html"><![CDATA[<p>1085 Perfect Sequence (25分)</p>
<p>Given a sequence of positive integers and another positive integer <em>p</em>. The sequence is said to be a <strong>perfect sequence</strong> if <em>M</em>≤<em>m</em>×<em>p</em> where <em>M</em> and <em>m</em> are the maximum and minimum numbers in the sequence, respectively.</p>
<p>Now given a sequence and a parameter <em>p</em>, you are supposed to find from the sequence as many numbers as possible to form a perfect subsequence.</p>
<h3 id="input-specification">Input Specification:</h3>
<p>Each input file contains one test case. For each case, the first line contains two positive integers <em>N</em> and <em>p</em>, where <em>N</em> (≤105) is the number of integers in the sequence, and <em>p</em> (≤109) is the parameter. In the second line there are <em>N</em> positive integers, each is no greater than 109.</p>
<h3 id="output-specification">Output Specification:</h3>
<p>For each test case, print in one line the maximum number of integers that can be chosen to form a perfect subsequence.</p>
<h3 id="sample-input">Sample Input:</h3>
<pre><code class="language-in">10 8
2 3 20 4 5 1 6 7 8 9
</code></pre>
<h3 id="sample-output">Sample Output:</h3>
<pre><code class="language-out">8
</code></pre>
<hr>
<p>题目描述：求完美数列，要求数列元素尽可能多。完美数列公式：M&lt;=m*p，M为数列中最大值，m为数列中最小值，p是给定的值。</p>
</br>
<p>输入：第一行两个值n，p，分别为数列元素个数，p是给定的值；第二行n个值给出无序的数列。</p>
<p>输出：完美数列元素的个数。</p>
</br>
<p>解题思路：要用long long类型存值，不然测试点5报错。将给定的数列从小到大排序，接着从索引0开始遍历，用二分查找找到每个元素能组成的最大完美子序列长度，进行比较后得出结果。</p>
<hr>
<pre><code class="language-c++">#include&lt;bits/stdc++.h&gt;
using namespace std;
const int maxn = 200000+5;
long long v[maxn];
int n, p;
int search(int g){
	int l=g, r=n-1, mid;
	int tx = 0;
	while(l&lt;=r){
		mid = (l+r)/2;
		if(v[mid]&lt;=v[g]*p){
			tx = max(tx,mid-g+1);
			l = mid + 1;
		}
		else r = mid-1;
	}
	return tx;
}
int main()
{
	int ans=0;
	scanf(&quot;%d %d&quot;, &amp;n, &amp;p);
	for(int i=0; i&lt;n; i++) scanf(&quot;%lld&quot;, &amp;v[i]);
	sort(v,v+n);//小到大 
	for(int i=0; i&lt;n; i++){
		ans = max(ans,search(i));
	}
	printf(&quot;%d&quot;, ans);
	return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[1084 Broken Keyboard (20分)题解]]></title>
        <id>https://ygytl.github.io/post/1084-broken-keyboard-20-fen-ti-jie/</id>
        <link href="https://ygytl.github.io/post/1084-broken-keyboard-20-fen-ti-jie/">
        </link>
        <updated>2020-06-07T14:47:11.000Z</updated>
        <content type="html"><![CDATA[<p>1084 Broken Keyboard (20分)</p>
<p>On a broken keyboard, some of the keys are worn out. So when you type some sentences, the characters corresponding to those keys will not appear on screen.</p>
<p>Now given a string that you are supposed to type, and the string that you actually type out, please list those keys which are for sure worn out.</p>
<h3 id="input-specification">Input Specification:</h3>
<p>Each input file contains one test case. For each case, the 1st line contains the original string, and the 2nd line contains the typed-out string. Each string contains no more than 80 characters which are either English letters [A-Z] (case insensitive), digital numbers [0-9], or <code>_</code> (representing the space). It is guaranteed that both strings are non-empty.</p>
<h3 id="output-specification">Output Specification:</h3>
<p>For each test case, print in one line the keys that are worn out, in the order of being detected. The English letters must be capitalized. Each worn out key must be printed once only. It is guaranteed that there is at least one worn out key.</p>
<h3 id="sample-input">Sample Input:</h3>
<pre><code class="language-in">7_This_is_a_test
_hs_s_a_es
</code></pre>
<h3 id="sample-output">Sample Output:</h3>
<pre><code class="language-out">7TI
</code></pre>
<hr>
<p>题目描述：在一个坏掉的键盘上，有些键是损坏的，我们通过输入一串字符串，来找到那些坏掉的键。</p>
</br>
<p>输入：第一行一串字符串，若键盘没有坏，他应该像第一行的字符串这样完整的显示在电脑屏幕上。第二行也是字符串，他是坏掉的键盘输入后，显示在电脑上的效果。</p>
<p>输出：坏掉的键值，若是拼音，则输出他的大写形式。</p>
</br>
<p>解题思路：两个字符串同时从索引0开始扫描，对比一下两个字符串，结果就出来了。哦，因为题目要求输出字母大写的形式，若字符串中出现小写字母，要转换处理一下再输出。</p>
<hr>
<pre><code class="language-c++">#include&lt;bits/stdc++.h&gt;
using namespace std;
int main()
{
	string s1, s2;
	getline(cin,s1);
	getline(cin,s2);
	int c = 0;
	map&lt;char,bool&gt; p;
	for(int i=0; i&lt;s1.length(); i++){
		char ch1=s1[i], ch2=s2[c];
		if(s1[i]&gt;='a'&amp;&amp;s1[i]&lt;='z') ch1 = s1[i]-'a'+'A';
		if(s2[c]&gt;='a'&amp;&amp;s2[c]&lt;='z') ch2 = s2[c]-'a'+'A'; 
		if(ch1!=ch2&amp;&amp;p[ch1]==false){
			cout &lt;&lt; ch1;
			p[ch1] = true;
		}
		else if(ch1==ch2) c++;
	}
    cout &lt;&lt; endl;
	return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[1083 List Grades (25分)题解]]></title>
        <id>https://ygytl.github.io/post/1083-list-grades-25-fen-ti-jie/</id>
        <link href="https://ygytl.github.io/post/1083-list-grades-25-fen-ti-jie/">
        </link>
        <updated>2020-06-07T14:19:56.000Z</updated>
        <content type="html"><![CDATA[<p>1083 List Grades (25分)</p>
<p>Given a list of <em>N</em> student records with name, ID and grade. You are supposed to sort the records with respect to the grade in non-increasing order, and output those student records of which the grades are in a given interval.</p>
<h3 id="input-specification">Input Specification:</h3>
<p>Each input file contains one test case. Each case is given in the following format:</p>
<pre><code>N
name[1] ID[1] grade[1]
name[2] ID[2] grade[2]
... ...
name[N] ID[N] grade[N]
grade1 grade2
</code></pre>
<p>where <code>name[i]</code> and <code>ID[i]</code> are strings of no more than 10 characters with no space, <code>grade[i]</code> is an integer in [0, 100], <code>grade1</code> and <code>grade2</code> are the boundaries of the grade's interval. It is guaranteed that all the grades are <strong>distinct</strong>.</p>
<h3 id="output-specification">Output Specification:</h3>
<p>For each test case you should output the student records of which the grades are in the given interval [<code>grade1</code>, <code>grade2</code>] and are in non-increasing order. Each student record occupies a line with the student's name and ID, separated by one space. If there is no student's grade in that interval, output <code>NONE</code> instead.</p>
<h3 id="sample-input-1">Sample Input 1:</h3>
<pre><code class="language-in">4
Tom CS000001 59
Joe Math990112 89
Mike CS991301 100
Mary EE990830 95
60 100
</code></pre>
<h3 id="sample-output-1">Sample Output 1:</h3>
<pre><code class="language-out">Mike CS991301
Mary EE990830
Joe Math990112
</code></pre>
<h3 id="sample-input-2">Sample Input 2:</h3>
<pre><code class="language-in">2
Jean AA980920 60
Ann CS01 80
90 95
</code></pre>
<h3 id="sample-output-2">Sample Output 2:</h3>
<pre><code class="language-out">NONE
</code></pre>
<hr>
<p>题目描述：题目给定某些学生的信息，包括姓名、课程号、课程得分，现在给定一个区间的分数，若有学生分数在给定区间内，则输出该学生的姓名及性别。没有则输出NONE。</p>
</br>
<p>输入：第一行n表示学生信息个数。接下来n行提供学生信息。</p>
<p>输出：输出分数在给定区间分数的学生信息，输出时按成绩递减输出，若没有符合的学生，输出NONE。</p>
</br>
<p>解题思路：写个cmp函数比较排序一下就行了。</p>
<hr>
<pre><code class="language-c++">#include&lt;bits/stdc++.h&gt;
using namespace std;
struct node{
	string name, class_name;
	int score;
};
vector&lt;node&gt; v, List;
bool cmp(node a, node b){
	return a.score &gt; b.score;
}
int main()
{
	int n, l, r;
	node t;
	scanf(&quot;%d&quot;, &amp;n);
	for(int i=0; i&lt;n; i++){
		cin &gt;&gt; t.name &gt;&gt; t.class_name &gt;&gt; t.score;
		v.push_back(t);
	}
	scanf(&quot;%d %d&quot;, &amp;l, &amp;r);
	for(int i=0; i&lt;n; i++){
		t = v[i];
		if(t.score &gt;= l &amp;&amp; t.score &lt;= r){
			List.push_back(t);
		}
	}
	sort(List.begin(),List.end(),cmp);
	if(List.size()==0) printf(&quot;NONE&quot;);
	for(int i=0; i&lt;List.size(); i++){
		cout &lt;&lt; List[i].name &lt;&lt; &quot; &quot; &lt;&lt; List[i].class_name &lt;&lt; endl;
	}
	return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[1082 Read Number in Chinese (25分)题解]]></title>
        <id>https://ygytl.github.io/post/1082-read-number-in-chinese-25-fen-ti-jie/</id>
        <link href="https://ygytl.github.io/post/1082-read-number-in-chinese-25-fen-ti-jie/">
        </link>
        <updated>2020-06-07T13:17:11.000Z</updated>
        <content type="html"><![CDATA[<p>1082 Read Number in Chinese (25分)</p>
<p>Given an integer with no more than 9 digits, you are supposed to read it in the traditional Chinese way. Output <code>Fu</code> first if it is negative. For example, -123456789 is read as <code>Fu yi Yi er Qian san Bai si Shi wu Wan liu Qian qi Bai ba Shi jiu</code>. Note: zero (<code>ling</code>) must be handled correctly according to the Chinese tradition. For example, 100800 is <code>yi Shi Wan ling ba Bai</code>.</p>
<h3 id="input-specification">Input Specification:</h3>
<p>Each input file contains one test case, which gives an integer with no more than 9 digits.</p>
<h3 id="output-specification">Output Specification:</h3>
<p>For each test case, print in a line the Chinese way of reading the number. The characters are separated by a space and there must be no extra space at the end of the line.</p>
<h3 id="sample-input-1">Sample Input 1:</h3>
<pre><code class="language-in">-123456789
</code></pre>
<h3 id="sample-output-1">Sample Output 1:</h3>
<pre><code class="language-out">Fu yi Yi er Qian san Bai si Shi wu Wan liu Qian qi Bai ba Shi jiu
</code></pre>
<h3 id="sample-input-2">Sample Input 2:</h3>
<pre><code class="language-in">100800
</code></pre>
<h3 id="sample-output-2">Sample Output 2:</h3>
<pre><code class="language-out">yi Shi Wan ling ba Bai
</code></pre>
<hr>
<p>题目描述：将数字转化为字母拼音的格式</p>
</br>
<p>输入：不超过9 digits的数</p>
<p>输出：汉字拼音格式</p>
</br>
<p>解题思路：把几个坑说下，测试点3是输入0的时候是否输出'ling'。难点是对零的处理，给几个测试数据吧，测试通过基本就行了；这里提供两个写法，细节处理有些许不同。</p>
<pre><code>9090909
jiu Bai ling jiu Wan ling jiu Bai ling jiu

100000009
yi Yi Wan ling jiu

0
ling

10086
yi Wan ling ba Shi liu

110110
yi Shi yi Wan ling yi Bai yi Shi
</code></pre>
<hr>
<pre><code class="language-c++">#include&lt;bits/stdc++.h&gt;
using namespace std;
//方法一
int main()
{
	string s;
	cin &gt;&gt; s;
	map&lt;int,string&gt; p;
	p[0]=&quot;ling&quot;; p[1]=&quot;yi&quot;; p[2]=&quot;er&quot;; p[3]=&quot;san&quot;; p[4]=&quot;si&quot;; p[5]=&quot;wu&quot;;
	p[6]=&quot;liu&quot;; p[7]=&quot;qi&quot;; p[8]=&quot;ba&quot;; p[9]=&quot;jiu&quot;;
	if(s[0]=='-'){
		printf(&quot;Fu &quot;);
	}
	else s = &quot;+&quot;+s;
	string ans=&quot;&quot;;
	bool flag = false;
	int l = s.size();
	for(int i=1; i&lt;l; i++){
		if(s[i]=='0'){
			if(l-i==5) ans += &quot; Wan&quot;; 
			flag = true;
			continue;
		}
		else{
			if(i!=1) ans += &quot; &quot;;
			if(flag){
				ans+= p[0] + &quot; &quot;;
			}
			flag = false;
			if(l-i==1) ans += p[s[i]-'0'];
			if(l-i==2||l-i==6) ans += p[s[i]-'0'] + &quot; Shi&quot;;
			if(l-i==3||l-i==7) ans += p[s[i]-'0'] + &quot; Bai&quot;;
			if(l-i==4||l-i==8) ans += p[s[i]-'0'] + &quot; Qian&quot;;
			if(l-i==5) ans += p[s[i]-'0'] + &quot; Wan&quot;;
			if(l-i==9) ans += p[s[i]-'0'] + &quot; Yi&quot;;
		}
	}
	if(s==&quot;+0&quot;||s==&quot;-0&quot;) ans = &quot;ling&quot;;
	cout &lt;&lt; ans &lt;&lt; endl;
	return 0;
}
</code></pre>
<pre><code class="language-c++">#include&lt;bits/stdc++.h&gt;
using namespace std;
//方法二
int main()
{
	map&lt;int,string&gt; p;
	p[0] = &quot;ling&quot;; p[1] = &quot;yi&quot;; p[2] = &quot;er&quot;; p[3] = &quot;san&quot;;
	p[4] = &quot;si&quot;; p[5] = &quot;wu&quot;; p[6] = &quot;liu&quot;; p[7] = &quot;qi&quot;;
	p[8] = &quot;ba&quot;; p[9] = &quot;jiu&quot;;
	string str, ans=&quot;&quot;;
	cin &gt;&gt; str;
	int l, s=0;
	bool flag = false;
	l = str.length();
	if(str[0]=='-'){
		ans += &quot;Fu&quot;;
		s++; l--; flag = true;
	}
	bool f1=false, f2=false, f3=false;
	for(int i=s; i&lt;str.length(); i++,l--){
		f1 = false;
		if(l&gt;=5&amp;&amp;l&lt;=8) f2 = true;
		if(str[i]=='0') f3 = true;
		else{
			f1 = true;
			if(flag) ans += &quot; &quot;;
			if(f3) ans += &quot;ling &quot;;
			ans += p[str[i]-'0'];
			flag = true;
			f3 = false;
		}
		if(f1){
			if(l==2||l==6) ans += &quot; Shi&quot;;
			if(l==3||l==7) ans += &quot; Bai&quot;;
			if(l==4||l==8) ans += &quot; Qian&quot;;
			if(l==9) ans += &quot; Yi&quot;;
		}
		if(f2&amp;&amp;l==5){
			ans += &quot; Wan&quot;; f2 = false;
		}
	}
	if(str==&quot;0&quot;) ans = &quot;ling&quot;;
	cout &lt;&lt; ans &lt;&lt; endl;
	return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[1080 Graduate Admission (30分)题解]]></title>
        <id>https://ygytl.github.io/post/1080-graduate-admission-30-fen-ti-jie/</id>
        <link href="https://ygytl.github.io/post/1080-graduate-admission-30-fen-ti-jie/">
        </link>
        <updated>2020-06-07T09:14:00.000Z</updated>
        <content type="html"><![CDATA[<p>1080 Graduate Admission (30分)</p>
<p>It is said that in 2011, there are about 100 graduate schools ready to proceed over 40,000 applications in Zhejiang Province. It would help a lot if you could write a program to automate the admission procedure.</p>
<p>Each applicant will have to provide two grades: the national entrance exam grade <em>G**E</em>, and the interview grade <em>G**I</em>. The final grade of an applicant is (<em>G**E</em>+<em>G**I</em>)/2. The admission rules are:</p>
<ul>
<li>The applicants are ranked according to their final grades, and will be admitted one by one from the top of the rank list.</li>
<li>If there is a tied final grade, the applicants will be ranked according to their national entrance exam grade <em>G**E</em>. If still tied, their ranks must be the same.</li>
<li>Each applicant may have <em>K</em> choices and the admission will be done according to his/her choices: if according to the rank list, it is one's turn to be admitted; and if the quota of one's most preferred shcool is not exceeded, then one will be admitted to this school, or one's other choices will be considered one by one in order. If one gets rejected by all of preferred schools, then this unfortunate applicant will be rejected.</li>
<li>If there is a tied rank, and if the corresponding applicants are applying to the same school, then that school must admit all the applicants with the same rank, <strong>even if its quota will be exceeded</strong>.</li>
</ul>
<h3 id="input-specification">Input Specification:</h3>
<p>Each input file contains one test case.</p>
<p>Each case starts with a line containing three positive integers: <em>N</em> (≤40,000), the total number of applicants; <em>M</em> (≤100), the total number of graduate schools; and <em>K</em> (≤5), the number of choices an applicant may have.</p>
<p>In the next line, separated by a space, there are <em>M</em> positive integers. The <em>i</em>-th integer is the quota of the <em>i</em>-th graduate school respectively.</p>
<p>Then <em>N</em> lines follow, each contains 2+<em>K</em> integers separated by a space. The first 2 integers are the applicant's <em>G**E</em> and <em>G**I</em>, respectively. The next <em>K</em> integers represent the preferred schools. For the sake of simplicity, we assume that the schools are numbered from 0 to <em>M</em>−1, and the applicants are numbered from 0 to <em>N</em>−1.</p>
<h3 id="output-specification">Output Specification:</h3>
<p>For each test case you should output the admission results for all the graduate schools. The results of each school must occupy a line, which contains the applicants' numbers that school admits. The numbers must be in increasing order and be separated by a space. There must be no extra space at the end of each line. If no applicant is admitted by a school, you must output an empty line correspondingly.</p>
<h3 id="sample-input">Sample Input:</h3>
<pre><code class="language-in">11 6 3
2 1 2 2 2 3
100 100 0 1 2
60 60 2 3 5
100 90 0 3 4
90 100 1 2 0
90 90 5 1 3
80 90 1 0 2
80 80 0 1 2
80 80 0 1 2
80 70 1 3 2
70 80 1 2 3
100 100 0 2 4
</code></pre>
<h3 id="sample-output">Sample Output:</h3>
<pre><code class="language-out">0 10
3
5 6 7
2 8

1 4
</code></pre>
<hr>
<p>题目描述：学校录取学生的模拟过程</p>
</br>
<p>输入：第一行n，m，k。分别为学生人数，学校数，学生可填报志愿数。第二行m个值，分别表示学校录取的人数。接下来n行，为学生的考试成绩GE，GI，以及填报的k个学校。</p>
<p>输出：每个学校录取的学生编号，从小到大输出。</p>
<p>录取规则：成绩排序，总分=（GE+GI）/2，总分高排在前面；当总分相同时，GE成绩高排在前面；当总分和GE都相同时，排名并列。如果学校最后录取的学生有多名排名是一样的，超额也要将他们都录取了。</p>
</br>
<p>解题思路：模拟题，很容易就把简单的问题复杂化了。先将学生按照成绩排序，分高的选择权。可以从第一名开始按其意愿选择学校，当他选择的学校没有录取满人时，他就会直接被学校录取，当学校录取满人了，其他成绩比较低的就无法再进入这满了人的学校，只能看其他志愿。</p>
<p>注意：在学校最后录取的学生成绩/排名不唯一时，怎么把排名相同的全部录取？这需要将学校最后录取的人的分数记录下来，就两个数组记录一下就行了。</p>
<p>模拟题得多做几道，找找感觉！</p>
<hr>
<pre><code class="language-c++">#include&lt;bits/stdc++.h&gt;
using namespace std;
const int maxn = 40000+5;
int n, m, k, snum[200], ltsum[200], ltge[200];
bool vis[maxn];
struct node{
	int ge, gi, id, sum;
	vector&lt;int&gt; sc;
	bool operator &lt;( const node &amp;x )const{
        if( sum!=x.sum ) return sum &gt; x.sum;
        return ge &gt; x.ge;
    }
};
vector&lt;int&gt; ans[200];
vector&lt;node&gt; v;
//bool cmp(node a, node b){
//	if(a.sum!=b.sum) return a.sum &gt; b.sum;
//	else return a.ge &gt; b.ge;
//}
int main()
{
	int g;
	memset(vis,true,sizeof(vis));
	scanf(&quot;%d %d %d&quot;, &amp;n, &amp;m, &amp;k);
	for(int i=0; i&lt;m; i++) scanf(&quot;%d&quot;, &amp;snum[i]);
	for(int i=0; i&lt;n; i++){//学生 
		node t;
		scanf(&quot;%d %d&quot;, &amp;t.ge, &amp;t.gi);
		t.id = i; t.sum = t.ge+t.gi;
		for(int j=0; j&lt;k; j++){
			scanf(&quot;%d&quot;, &amp;g);
			t.sc.push_back(g);//学生报志愿 
		}
		v.push_back(t);
	}
//	sort(v.begin(),v.end(),cmp);
	sort(v.begin(), v.end());
	for(int i=0; i&lt;n; i++){
		node t = v[i];
		for(int j=0; j&lt;k; j++){
			int cid = t.sc[j];
			if(!vis[t.id]) continue;
			if(ans[cid].size()&lt;snum[cid]){
				ltsum[cid] = t.sum;
				ltge[cid] = t.ge;
				ans[cid].push_back(t.id);
				vis[t.id] = false;
			}
			else if(t.sum==ltsum[cid]&amp;&amp;t.ge==ltge[cid]){
				ans[cid].push_back(t.id);
				vis[t.id] = false;
			}
		}
	}
	for(int i=0; i&lt;m; i++){
		sort(ans[i].begin(),ans[i].end());
		for(int j=0; j&lt;ans[i].size(); j++){
			if(j) printf(&quot; &quot;);
			printf(&quot;%d&quot;, ans[i][j]);
		}
		printf(&quot;\n&quot;);
	}
	return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[1076 Forwards on Weibo (30分)题解]]></title>
        <id>https://ygytl.github.io/post/1076-forwards-on-weibo-30-fen-ti-jie/</id>
        <link href="https://ygytl.github.io/post/1076-forwards-on-weibo-30-fen-ti-jie/">
        </link>
        <updated>2020-06-06T10:01:02.000Z</updated>
        <content type="html"><![CDATA[<p>1076 Forwards on Weibo (30分)</p>
<p>Weibo is known as the Chinese version of Twitter. One user on Weibo may have many followers, and may follow many other users as well. Hence a social network is formed with followers relations. When a user makes a post on Weibo, all his/her followers can view and forward his/her post, which can then be forwarded again by their followers. Now given a social network, you are supposed to calculate the maximum potential amount of forwards for any specific user, assuming that only <em>L</em> levels of indirect followers are counted.</p>
<h3 id="input-specification">Input Specification:</h3>
<p>Each input file contains one test case. For each case, the first line contains 2 positive integers: <em>N</em> (≤1000), the number of users; and <em>L</em> (≤6), the number of levels of indirect followers that are counted. Hence it is assumed that all the users are numbered from 1 to <em>N</em>. Then <em>N</em> lines follow, each in the format:</p>
<pre><code>M[i] user_list[i]
</code></pre>
<p>where <code>M[i]</code> (≤100) is the total number of people that <code>user[i]</code> follows; and <code>user_list[i]</code> is a list of the <code>M[i]</code> users that followed by <code>user[i]</code>. It is guaranteed that no one can follow oneself. All the numbers are separated by a space.</p>
<p>Then finally a positive <em>K</em> is given, followed by <em>K</em> <code>UserID</code>'s for query.</p>
<h3 id="output-specification">Output Specification:</h3>
<p>For each <code>UserID</code>, you are supposed to print in one line the maximum potential amount of forwards this user can trigger, assuming that everyone who can view the initial post will forward it once, and that only <em>L</em> levels of indirect followers are counted.</p>
<h3 id="sample-input">Sample Input:</h3>
<pre><code class="language-in">7 3
3 2 3 4
0
2 5 6
2 3 1
2 3 4
1 4
1 5
2 2 6
</code></pre>
<h3 id="sample-output">Sample Output:</h3>
<pre><code class="language-out">4
5
</code></pre>
<hr>
<p>题目描述：微博吧啦吧啦。。现在！给你一个社会网图，你需要求出最大潜在的转发数时多少，假设只能传到L层关系。</p>
</br>
<p>输入：第一行两个正整数N(&lt;=1000)用户数，L(&lt;=6)转发层。接下来有N行，每行代表第i个用户关注的人(i=1~N)，每行格式为M[i] user_list[i]，user_list时用户的编号。最后一行，第一个数K是带查询个数，接下来就是K个值啦。比如样例中最后一行K=2，带查询的第一个值是2。分析下样例，先把图画出来，当2发出一篇微博时，他最大能被转发的次数是多少？显然是4，他能被(1、4、5、6)转发。</p>
<p>输出：转发的次数</p>
</br>
<p>解题思路：要查询那个点，就从哪个点开始广搜遍历就行了。</p>
<p>注意：很简单的一道BFS题，不知道为什么会出现在30分这里。难道是因为最后一个测试点卡着了？最后一个测试点容易超时。</p>
<hr>
<pre><code class="language-c++">#include&lt;bits/stdc++.h&gt;
using namespace std;
int n, l;
const int maxn = 1000+5;
vector&lt;int&gt; G[maxn];
bool vis[maxn];
struct node{
	int index, level;
	node(){
		index = level = 0;
	}
};
void query(int start){
	fill(vis,vis+maxn,false);
	node t, tt;
	t.index = start;
	t.level = 0;
	queue&lt;node&gt; q;
	q.push(t);
	vis[start] = true;
	int ans = 0;
	while(!q.empty()){
		t = q.front(); q.pop();
		for(int i=0; i&lt;G[t.index].size(); ++i){
			int u = G[t.index][i];
			if(!vis[u]&amp;&amp;t.level&lt;l){
				ans++;
				vis[u] = true;
				tt.index = u;
				tt.level = t.level+1;
				q.push(tt);
			}
		}
	}
	printf(&quot;%d\n&quot;, ans);
}
int main()
{
	int k, g;
	scanf(&quot;%d %d&quot;, &amp;n, &amp;l);
	for(int i=1; i&lt;=n; ++i){
		scanf(&quot;%d&quot;, &amp;k);
		for(int j=0; j&lt;k; ++j){
			scanf(&quot;%d&quot;, &amp;g);
			G[g].push_back(i);
		}
	}
	scanf(&quot;%d&quot;, &amp;k);
	for(int i=0; i&lt;k; ++i){
		scanf(&quot;%d&quot;, &amp;g);
		query(g);
	}
	return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[1081 Rational Sum (20分)题解]]></title>
        <id>https://ygytl.github.io/post/1081-rational-sum-20-fen-ti-jie/</id>
        <link href="https://ygytl.github.io/post/1081-rational-sum-20-fen-ti-jie/">
        </link>
        <updated>2020-06-06T09:12:16.000Z</updated>
        <content type="html"><![CDATA[<p>1081 Rational Sum (20分)</p>
<p>Given <em>N</em> rational numbers in the form <code>numerator/denominator</code>, you are supposed to calculate their sum.</p>
<h3 id="input-specification">Input Specification:</h3>
<p>Each input file contains one test case. Each case starts with a positive integer <em>N</em> (≤100), followed in the next line <em>N</em> rational numbers <code>a1/b1 a2/b2 ...</code> where all the numerators and denominators are in the range of <strong>long int</strong>. If there is a negative number, then the sign must appear in front of the numerator.</p>
<h3 id="output-specification">Output Specification:</h3>
<p>For each test case, output the sum in the simplest form <code>integer numerator/denominator</code> where <code>integer</code> is the integer part of the sum, <code>numerator</code> &lt; <code>denominator</code>, and the numerator and the denominator have no common factor. You must output only the fractional part if the integer part is 0.</p>
<h3 id="sample-input-1">Sample Input 1:</h3>
<pre><code class="language-in">5
2/5 4/15 1/30 -2/60 8/3
</code></pre>
<h3 id="sample-output-1">Sample Output 1:</h3>
<pre><code class="language-out">3 1/3
</code></pre>
<h3 id="sample-input-2">Sample Input 2:</h3>
<pre><code class="language-in">2
4/3 2/3
</code></pre>
<h3 id="sample-output-2">Sample Output 2:</h3>
<pre><code class="language-out">2
</code></pre>
<h3 id="sample-input-3">Sample Input 3:</h3>
<pre><code class="language-in">3
1/3 -1/6 1/8
</code></pre>
<h3 id="sample-output-3">Sample Output 3:</h3>
<pre><code class="language-out">7/24
</code></pre>
<hr>
<p>题目描述：分数求和。</p>
</br>
<p>输入：第一行n表示分数的个数，第二行n个分数。</p>
<p>输出：分数之和。输出格式 1）4/3输出1 2/3；2）4 /4 输出 1；3）2/3输出2/3</p>
</br>
<p>解题思路：我习惯将程序分块写，这样程序看起来比较直观清晰；将所有分数加起来，可以先记录第一个分数，分子为a1、分母为b1，接着读第二个分数，第二个分数分子为a2，分母为b2，接着就可以将两个分数进行计算了，然后将计算结果分别再存入a1和b1；后面读入的分数都存在a2和b2中，重复上述过程。得到的结果a1和b1按照题目规定输出格式输出。</p>
<p>两个分数相加的过程：例如2/5和4/15相加，想求出两个分母的最大公因数为5，两个分母同时除于5，分别得到b1=1，b2=3，将分子a1乘与b2，a2乘与b1，则a1=6，a2=4，此时，分数分别为6/1和4/3，让a1=a1+a2=10，b1 = b1*b2*gcd(b1,b2)=15（分母进行通分的过程），这样就能将两分数相加的结果放入a1和b1了，即2/5 + 4 / 15 = 10 / 15。</p>
<hr>
<pre><code class="language-c++">#include&lt;bits/stdc++.h&gt;
using namespace std;
int n, a1, b1, a2, b2;
int gcd(int a, int b){ return a == 0 ? b : gcd(b % a, a); } 
void sum(){
	int g = gcd(b1,b2);
	b1 /= g;
	b2 /= g;
	a1*=b2; a2 *= b1;
	a1 += a2;
	b1 *= b2*g;
}
int main()
{
	scanf(&quot;%d&quot;, &amp;n);
	for(int i=0; i&lt;n; i++){
		if(i==0) scanf(&quot;%d/%d&quot;, &amp;a1, &amp;b1);
		else{
			scanf(&quot;%d/%d&quot;, &amp;a2, &amp;b2);
			sum();
		}
	}
	int g = gcd(a1,b1);
	a1 /= g; b1 /= g;
	if(a1%b1==0) printf(&quot;%d\n&quot;, a1/b1);
	else if(a1&gt;b1) printf(&quot;%d %d/%d\n&quot;, a1/b1, a1%b1, b1);
	else printf(&quot;%d/%d&quot;, a1%b1, b1);
	return 0;
}
</code></pre>
]]></content>
    </entry>
</feed>