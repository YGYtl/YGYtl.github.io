<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://ygytl.github.io/</id>
    <title>Grace</title>
    <updated>2020-06-01T06:24:37.446Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://ygytl.github.io/"/>
    <link rel="self" href="https://ygytl.github.io/atom.xml"/>
    <subtitle>Grace&apos;s blog</subtitle>
    <logo>https://ygytl.github.io/images/avatar.png</logo>
    <icon>https://ygytl.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, Grace</rights>
    <entry>
        <title type="html"><![CDATA[P2 并发与并行的区别、同步与异步的解析]]></title>
        <id>https://ygytl.github.io/post/p2-bing-fa-yu-bing-xing-de-qu-bie-tong-bu-yu-yi-bu-de-jie-xi/</id>
        <link href="https://ygytl.github.io/post/p2-bing-fa-yu-bing-xing-de-qu-bie-tong-bu-yu-yi-bu-de-jie-xi/">
        </link>
        <updated>2020-06-01T06:23:42.000Z</updated>
        <content type="html"><![CDATA[<h2 id="并发与并行的区别">并发与并行的区别</h2>
<h3 id="并发">并发</h3>
<p>并发：每个时间段只允许处理一个进程<br>
多个进程看似在同步运行，但并非正正的在同一时刻同时运行<br>
例如：一个人一边在煮菜，一边在看书，他不可能在煮菜时同时看书，<br>
只能先把菜放入锅里煮时，抽空走出厨房，回到房里看书，当菜煮好了，<br>
又要放下书，回去把菜翻炒翻炒。炒菜和看书看似同时进行，但实际上，<br>
炒菜和看书，一个时间段只能处理其一。</p>
<h3 id="并行">并行</h3>
<p>并行：多个进程在同一时刻同时运行<br>
例如：类似有多核CPU处理程序，还是炒菜和看书的例子，<br>
就就好像有两个人在处理，一个人在炒菜，同时，另一个人在看书，<br>
这两件事是同一时刻同时进行的。</p>
<p>Python中如何实现并发进程？？？<br>
利用 多进程、多线程、异步编程即可</p>
<p>Multiple Processes<br>
抢占式多任务，操作系统调度，可使用多核CPU</p>
<p>Multiple Threads<br>
抢占式多任务，操作系统调度，不能使用多核CPU</p>
<p>Asynchronous Programming<br>
协作式多任务，单进程、单线程</p>
<h2 id="同步与异步">同步与异步</h2>
<p>先看同步对弈和异步对弈</p>
<p>前提条件：假设A要与B<sub>1</sub> ~ B<sub>12</sub> 对弈，A思考需要5s，B<sub>1</sub> ~ B<sub>12</sub> 中，每个人要思考55s，对局需要30个回合才能分输赢，下棋时常忽略不计。</p>
<p>同步对弈 Synchronous<br>
同步对弈指：A与B<sub>1</sub>对弈完成后，才开始与B<sub>2</sub>对弈，以此类推，所以A走完30个回合的总时间是(5+55)*30*12=21600s</p>
<p>异步对弈 Asychronous<br>
异步对弈指：A与B<sub>1</sub>对弈时，A先下花了5s与B<sub>1</sub>下第一回合，B<sub>1</sub>需要花55s的时间思考，A不等待B<sub>1</sub>，直接与B<sub>2</sub>对弈，一直到与B<sub>12</sub>对弈了后，才返回跟B<sub>1</sub>对弈。而这时，A走完每个棋局的第一步需要花费12*5=60s，60s过去B<sub>1</sub>已经走完第一步，A与B<sub>1</sub>进行第二回合的对弈。A走完30个回合的总时间是60*30=1800s</p>
<p>21600/1800 = 12，异步对弈效率提高了12倍</p>
<h4 id="异步编程">异步编程：</h4>
<p>指在 单线程 中 并发 执行多个任务，当一个任务在等待数据时，它会释放 CPU 资源，</p>
<p>转而执行其它任务，通过程序员自己主动切换任务来最小化空闲时间。<br>
异步实现：异步函数在等待数据时被暂停执行，当数据到达时，又能够在被暂停的位置处恢复执行。</p>
<h4 id="异步-io-操作">异步 I/O 操作</h4>
<p>指当你发起一个 I/O 操作（比如，等待网络图片数据的到来），却不用等它结束，<br>
你可以继续去做其它的事情，当它结束时，你会得到通知，然后再回来接着处理这个 I/O 后续的操作。<br>
而 同步 I/O 操作 则会被阻塞在 I/O 操作上直到它完成，这期间 CPU 做了很多事，只是没有运行你的程序。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[1066 Root of AVL Tree (25分)题解]]></title>
        <id>https://ygytl.github.io/post/1066-root-of-avl-tree-25-fen-ti-jie/</id>
        <link href="https://ygytl.github.io/post/1066-root-of-avl-tree-25-fen-ti-jie/">
        </link>
        <updated>2020-06-01T05:10:53.000Z</updated>
        <content type="html"><![CDATA[<p>1066 Root of AVL Tree (25分)</p>
<p>An AVL tree is a self-balancing binary search tree. In an AVL tree, the heights of the two child subtrees of any node differ by at most one; if at any time they differ by more than one, rebalancing is done to restore this property. Figures 1-4 illustrate the rotation rules.</p>
<p><img src="https://images.ptausercontent.com/31" alt="img" loading="lazy">  <img src="https://images.ptausercontent.com/32" alt="img" loading="lazy"></p>
<p><img src="https://images.ptausercontent.com/33" alt="img" loading="lazy"> <img src="https://images.ptausercontent.com/34" alt="img" loading="lazy"></p>
<p>Now given a sequence of insertions, you are supposed to tell the root of the resulting AVL tree.</p>
<h3 id="input-specification">Input Specification:</h3>
<p>Each input file contains one test case. For each case, the first line contains a positive integer <em>N</em> (≤20) which is the total number of keys to be inserted. Then <em>N</em> distinct integer keys are given in the next line. All the numbers in a line are separated by a space.</p>
<h3 id="output-specification">Output Specification:</h3>
<p>For each test case, print the root of the resulting AVL tree in one line.</p>
<h3 id="sample-input-1">Sample Input 1:</h3>
<pre><code class="language-in">5
88 70 61 96 120
</code></pre>
<h3 id="sample-output-1">Sample Output 1:</h3>
<pre><code class="language-out">70
</code></pre>
<h3 id="sample-input-2">Sample Input 2:</h3>
<pre><code>7
88 70 61 96 120 90 65
</code></pre>
<h3 id="sample-output-2">Sample Output 2:</h3>
<pre><code>88
</code></pre>
<hr>
<p>题目描述：平衡二叉搜索树(AVL Tree)是能够自我调整到平衡的一棵树；何为平衡二叉搜索树？</p>
<p>1、左子树与右子树高度之差的绝对值不超过1<br>
2、树的每个左子树和右子树都是AVL树<br>
3、每一个节点都有一个平衡因子（balance factor），任一节点的平衡因子是-1、0、1（每一个节点的平衡因子 = 右子树高度 - 左子树高度）</p>
<p>现在就是要构建一棵AVL树。</p>
<p>输入：第一行n为节点数；第二行n个数，为要插入的元素。</p>
<p>输出：将构建的AVL数的根节点输出。</p>
<p>解题思路：构建一棵树，用结构体记录每个节点的信息，包括节点的值、左右子树的指针；一开始很难理解怎么转，仔细分析下，也就四种旋转（左旋转，右旋转，左右旋转、右左旋转），有点蒙？画个图就清晰了。灵魂画手上线：</p>
<p>1、右旋转：插入的是数据C，C&lt;B&lt;A</p>
<figure data-type="image" tabindex="1"><img src="https://ygytl.github.io//post-images/1590988367275.jpg" alt="img" loading="lazy"></figure>
<p>2、左右旋转：插入的是数据C，B&lt;C&lt;A</p>
<figure data-type="image" tabindex="2"><img src="https://ygytl.github.io//post-images/1590988395061.jpg" alt="img" loading="lazy"></figure>
<p>3、左旋转：插入数据是C，C&gt;B&gt;A</p>
<p><img src="https://ygytl.github.io//post-images/1590988401828.jpg" alt="img" loading="lazy"><br>
4、右左旋转：插入数据是C，B&gt;C&gt;A</p>
<figure data-type="image" tabindex="3"><img src="https://ygytl.github.io//post-images/1590988409815.jpg" alt="img" loading="lazy"></figure>
<hr>
<pre><code class="language-c++">#include&lt;bits/stdc++.h&gt;
using namespace std;
struct node{
	int val;
	node *left, *right;
};

node *routerRight(node *root){
	node *t = NULL;
	t = root-&gt;left;
	root-&gt;left = t-&gt;right;
	t-&gt;right = root;
	return t;
}
node *routerLeft(node *root){
	node *t = NULL;
	t = root-&gt;right;
	root-&gt;right = t-&gt;left;
	t-&gt;left = root;
	return t;
}

node *routerLeftRight(node *root){
	root-&gt;left = routerLeft(root-&gt;left);
	return routerRight(root);
}

node *routerRightLeft(node *root){
	root-&gt;right = routerRight(root-&gt;right);
	return routerLeft(root);
}

int height(node *root){
	if(root==NULL) return 0;
	return max(height(root-&gt;left),height(root-&gt;right))+1;
}
node *insert(node *root, int val){
	if(root==NULL){
		root = new node();
		root-&gt;val = val;
		root-&gt;left = root-&gt;right = NULL;
	}
	else if(val &lt; root-&gt;val){
		root-&gt;left = insert(root-&gt;left,val);
		if(height(root-&gt;left)-height(root-&gt;right)==2){
			root = val &lt; root-&gt;left-&gt;val ? routerRight(root):routerLeftRight(root);
		}
	}
	else{
		root-&gt;right = insert(root-&gt;right,val);
		if(height(root-&gt;right)-height(root-&gt;left)==2){
			root = val &gt; root-&gt;right-&gt;val ? routerLeft(root):routerRightLeft(root); 
		}
	}
	return root;
}
int n;
int main()
{
	int m;
	scanf(&quot;%d&quot;, &amp;n);
	node *root = NULL;
	for(int i=0; i&lt;n; i++){
		scanf(&quot;%d&quot;, &amp;m);
		root = insert(root,m);
	}
	printf(&quot;%d&quot;, root-&gt;val);
	return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[P3 同步阻塞下载]]></title>
        <id>https://ygytl.github.io/post/p3-tong-bu-zu-sai-xia-zai/</id>
        <link href="https://ygytl.github.io/post/p3-tong-bu-zu-sai-xia-zai/">
        </link>
        <updated>2020-05-31T03:18:14.000Z</updated>
        <content type="html"><![CDATA[<h3 id="环境搭建">环境搭建</h3>
<h4 id="安装centos7并配置nginx">安装centos7并配置nginx</h4>
<pre><code>1. 添加repo源
# vi /etc/yum.repos.d/nginx.repo

内容如下:
[nginx]
name=nginx repo
baseurl=http://nginx.org/packages/centos/7/$basearch/
gpgcheck=0
enabled=1

2. 安装
# yum install -y nginx

3. 启动
# systemctl start nginx
# systemctl enable nginx
</code></pre>
<h3 id="同步阻塞">同步阻塞</h3>
<h4 id="11-在windows下创建文件夹test在文件夹下创建日志模块loggerpy后续windows文件都放入同一个文件夹下">1.1 在windows下创建文件夹test，在文件夹下创建日志模块logger.py(后续windows文件都放入同一个文件夹下)</h4>
<pre><code class="language-python">import os
import time
import logging

logger = logging.getLogger('aiotest')
logger.setLevel(logging.DEBUG)
formatter = logging.Formatter(
    '%(asctime)s - %(filename)s[line:%(lineno)d] - &lt;%(threadName)s %(thread)d&gt;' +
    '- &lt;Process %(process)d&gt; - %(levelname)s: %(message)s'
)

basedir = os.path.abspath(os.path.dirname(__file__))
log_dest = os.path.join(basedir, 'logs')  # 日志文件所在目录
if not os.path.isdir(log_dest):
    os.mkdir(log_dest)
filename = time.strftime('%Y-%m-%d-%H-%M-%S', time.localtime(time.time())) + '.log'  file_handler = logging.FileHandler(os.path.join(log_dest, filename))  # 创建日志文件handler
file_handler.setFormatter(formatter)  # 设置Formatter
file_handler.setLevel(logging.INFO)  # 单独设置日志文件的日志级别

stream_handler = logging.StreamHandler()
stream_handler.setFormatter(formatter)
# stream_handler.setLevel(logging.INFO)  # 单独设置控制台日志的日志级别，注释掉则使用总日志级别
logger.addHandler(file_handler)
logger.addHandler(stream_handler)
</code></pre>
<h4 id="12-在centos中放入文件flagstargz">1.2 在centos中放入文件flags.tar.gz</h4>
<pre><code>将flags.tar.gz文件导入到/usr/share/nginx/html中，并解压tar xf flags.tar.gz
#cd /usr/share/nginx/html
#ls flags &gt; flags.txt
将flags文件夹下的文件名写入flags.txt中，以便后续使用
</code></pre>
<h4 id="13-在windows下创建commonpy">1.3 在windows下创建common.py</h4>
<pre><code class="language-python">import os
import time
import requests
from logger import logger

basepath = os.path.abspath(os.path.dirname(__file__))  # 当前模块文件的根目录

def setup_down_path():
    '''设置图片下载后的保存位置，所有图片放在同一个目录下'''
    down_path = os.path.join(basepath, 'downloads')
    if not os.path.isdir(down_path):
        os.mkdir(down_path)
        logger.info('Create download path {}'.format(down_path))
    return down_path

def get_links():
    '''获取所有图片的下载链接'''
    with open(os.path.join(basepath, 'flags.txt')) as f:
        return ['http://192.168.157.134/flags/' + flag.strip() for flag in f.readlines()]


def download_one(image):  #后续多线程时concurrent.futures.ThreadPoolExecutor.map()
    '''
    下载一张图片
    param image: 字典，包括图片的保存目录、图片的序号、图片的URL
    '''
    logger.info('Downloading No.{} [{}]'.format(image['linkno'], image['link']))
    t0 = time.time()

    resp = requests.get(image['link'])
    filename = os.path.split(image['link'])[1]
    with open(os.path.join(image['path'], filename), 'wb') as f:
        f.write(resp.content)  # resp.content是bytes类型，而resp.text是str类型

    t1 = time.time()
    logger.info('Task No.{} [{}] runs {} seconds.'.format(image['linkno'], image['link'], t1 - t0))
</code></pre>
<h4 id="14-在windows下创建sequentialpy">1.4  在windows下创建sequential.py</h4>
<pre><code class="language-python">import time
from common import setup_down_path, get_links, download_one
from logger import logger

def download_many():
    '''依序下载所有图片，同步阻塞'''
    down_path = setup_down_path()
    links = get_links()

    for linkno, link in enumerate(links, 1):
        image = {
            'path': down_path,
            'linkno': linkno,  # 图片序号，方便日志输出时，正在下载哪一张
            'link': link
        }
        download_one(image)

    return len(links)

if __name__ == '__main__':
    t0 = time.time()
    count = download_many()
    msg = '{} flags downloaded in {} seconds.'
    logger.info(msg.format(count, time.time() - t0))
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[1067 Sort with Swap(0, i) (25分)题解]]></title>
        <id>https://ygytl.github.io/post/1067-sort-with-swap0-i-25-fen/</id>
        <link href="https://ygytl.github.io/post/1067-sort-with-swap0-i-25-fen/">
        </link>
        <updated>2020-05-29T07:32:54.000Z</updated>
        <content type="html"><![CDATA[<p>1067 Sort with Swap(0, i) (25分)</p>
<p>Given any permutation of the numbers {0, 1, 2,..., <em>N</em>−1}, it is easy to sort them in increasing order. But what if <code>Swap(0, *)</code> is the ONLY operation that is allowed to use? For example, to sort {4, 0, 2, 1, 3} we may apply the swap operations in the following way:</p>
<pre><code>Swap(0, 1) =&gt; {4, 1, 2, 0, 3}
Swap(0, 3) =&gt; {4, 1, 2, 3, 0}
Swap(0, 4) =&gt; {0, 1, 2, 3, 4}
</code></pre>
<p>Now you are asked to find the minimum number of swaps need to sort the given permutation of the first <em>N</em> nonnegative integers.</p>
<h3 id="input-specification">Input Specification:</h3>
<p>Each input file contains one test case, which gives a positive <em>N</em> (≤105) followed by a permutation sequence of {0, 1, ..., <em>N</em>−1}. All the numbers in a line are separated by a space.</p>
<h3 id="output-specification">Output Specification:</h3>
<p>For each case, simply print in a line the minimum number of swaps need to sort the given permutation.</p>
<h3 id="sample-input">Sample Input:</h3>
<pre><code class="language-in">10
3 5 7 2 6 4 9 0 8 1
</code></pre>
<h3 id="sample-output">Sample Output:</h3>
<pre><code class="language-out">9
</code></pre>
<hr>
<p>题目描述：只能与0交换，求得到正确序列所需最少交换次数。</p>
<p>解题思路：找到序列中值与位置不匹配的元素，进行循环交换，将他们放回正确的位置，当该元素不为0时，交换次数要另外加2。</p>
<hr>
<pre><code class="language-c++">#include&lt;bits/stdc++.h&gt;
using namespace std;
int main()
{
	int n;
	vector&lt;int&gt; v;
	scanf(&quot;%d&quot;, &amp;n);
	v.resize(n);
	for(int i=0; i&lt;n; i++){
		scanf(&quot;%d&quot;, &amp;v[i]);
	}
	int ans = 0;
	for(int i=0; i&lt;n; i++){
		if(v[i]==i) continue;
		while(v[i]!=i){
			swap(v[i],v[v[i]]);
			ans++;
		}
		if(i!=0) ans+=2;
	}
	printf(&quot;%d\n&quot;, ans);
	return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[1065 A+B and C (64bit) (20分)题解]]></title>
        <id>https://ygytl.github.io/post/1065-ab-and-c-64bit-20-fen-ti-jie/</id>
        <link href="https://ygytl.github.io/post/1065-ab-and-c-64bit-20-fen-ti-jie/">
        </link>
        <updated>2020-05-29T02:42:07.000Z</updated>
        <content type="html"><![CDATA[<p>1065 A+B and C (64bit) (20分)</p>
<p>Given three integers <em>A</em>, <em>B</em> and <em>C</em> in [−2<sup>63</sup>,2<sup>63</sup>], you are supposed to tell whether <em>A</em>+<em>B</em>&gt;<em>C</em>.</p>
<h3 id="input-specification">Input Specification:</h3>
<p>The first line of the input gives the positive number of test cases, <em>T</em> (≤10). Then <em>T</em> test cases follow, each consists of a single line containing three integers <em>A</em>, <em>B</em> and <em>C</em>, separated by single spaces.</p>
<h3 id="output-specification">Output Specification:</h3>
<p>For each test case, output in one line <code>Case #X: true</code> if <em>A</em>+<em>B</em>&gt;<em>C</em>, or <code>Case #X: false</code> otherwise, where <em>X</em> is the case number (starting from 1).</p>
<h3 id="sample-input">Sample Input:</h3>
<pre><code class="language-in">3
1 2 3
2 3 4
9223372036854775807 -9223372036854775808 0
</code></pre>
<h3 id="sample-output">Sample Output:</h3>
<pre><code class="language-out">Case #1: false
Case #2: true
Case #3: false
</code></pre>
<hr>
<p>题目描述：A+B&gt;C，真返回true，假返回false</p>
<p>解题思路：一看就是大数据处理，long double类型杠，或者对数据处理一下</p>
<p>注：a&gt;&gt;1 与 a/2有区别，(a&amp;1) 与 a%2有区别，a+b==c 与 (g=a+b),g==c有区别</p>
<hr>
<p>方法一：</p>
<pre><code class="language-C++">#include&lt;bits/stdc++.h&gt;
using namespace std ;
int main()
{
    int n;
    scanf(&quot;%d&quot;, &amp;n);
    for( int i=1; i&lt;=n; i++){
        long double a, b, c;
        scanf(&quot;%Lf %Lf %Lf&quot;, &amp;a, &amp;b, &amp;c);
        printf(&quot;Case #%d: &quot;, i);
        if(a+b&gt;c) printf(&quot;yes\n&quot;);
        else printf(&quot;false\n&quot;);
    }
    return 0 ;
}
</code></pre>
<p>方法二：</p>
<pre><code class="language-c++">#include&lt;bits/stdc++.h&gt;
using namespace std;
int main()
{
	long long a, b, c;
	int n;
	scanf(&quot;%d&quot;, &amp;n);
	for(int i=1; i&lt;=n; i++){
		scanf(&quot;%lld %lld %lld&quot;, &amp;a, &amp;b, &amp;c);
		long long ta, tb, tc;
		ta = a&gt;&gt;1;
		tb = b&gt;&gt;1;
		tc = c&gt;&gt;1;
		printf(&quot;Case #%d: &quot;, i);
		if(ta+tb&gt;tc){
			printf(&quot;true\n&quot;);
		}
		else if(ta+tb==tc&amp;&amp;((a&amp;1)+(b&amp;1)&gt;(c&amp;1))){
			printf(&quot;true\n&quot;);
		}
		else printf(&quot;false\n&quot;);
	}
	return 0;
}
</code></pre>
<p>方法三：</p>
<pre><code class="language-python">n = int(input())
for i in range(1,n+1):
    g = input().split()
    a = int(g[0])
    b = int(g[1])
    c = int(g[2])
    if a+b &gt; c:
        print('Case #{}: true'.format(i))
    else:
        print('Case #{}: false'.format(i))

</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[linux常用命令]]></title>
        <id>https://ygytl.github.io/post/linux-chang-yong-ming-ling/</id>
        <link href="https://ygytl.github.io/post/linux-chang-yong-ming-ling/">
        </link>
        <updated>2020-05-28T13:18:52.000Z</updated>
        <content type="html"><![CDATA[<h5 id="复制文件或文件夹">复制文件或文件夹</h5>
<pre><code>cp dir1/a.doc dir2 //将dir1下的a.doc文件复制到dir2目录下
cp -r dir1 dir2 //将dir1及dir1下的文件复制到dir2
cp -r dir1/. dir2 //将dir1下的文件复制到dir2
</code></pre>
<h5 id="解压缩">解压缩</h5>
<pre><code>tar xf flag.tar.gz
</code></pre>
<h5 id="centos查看ip">CentOS查看ip</h5>
<pre><code>ip addr
</code></pre>
<h5 id="将flags文件夹里的文件名输出到txt文本">将flags文件夹里的文件名输出到txt文本</h5>
<pre><code>#ls flags &gt; flags.txt
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[1062 Talent and Virtue (25分)题解]]></title>
        <id>https://ygytl.github.io/post/1062-talent-and-virtue-25-fen/</id>
        <link href="https://ygytl.github.io/post/1062-talent-and-virtue-25-fen/">
        </link>
        <updated>2020-05-26T15:56:44.000Z</updated>
        <content type="html"><![CDATA[<p>1062 Talent and Virtue (25分)</p>
<p>About 900 years ago, a Chinese philosopher Sima Guang wrote a history book in which he talked about people's talent and virtue. According to his theory, a man being outstanding in both talent and virtue must be a &quot;sage（圣人）&quot;; being less excellent but with one's virtue outweighs talent can be called a &quot;nobleman（君子）&quot;; being good in neither is a &quot;fool man（愚人）&quot;; yet a fool man is better than a &quot;small man（小人）&quot; who prefers talent than virtue.</p>
<p>Now given the grades of talent and virtue of a group of people, you are supposed to rank them according to Sima Guang's theory.</p>
<h3 id="input-specification">Input Specification:</h3>
<p>Each input file contains one test case. Each case first gives 3 positive integers in a line: <em>N</em> (≤10<sup>5</sup>), the total number of people to be ranked; <em>L</em> (≥60), the lower bound of the qualified grades -- that is, only the ones whose grades of talent and virtue are both not below this line will be ranked; and <em>H</em> (&lt;100), the higher line of qualification -- that is, those with both grades not below this line are considered as the &quot;sages&quot;, and will be ranked in non-increasing order according to their total grades. Those with talent grades below <em>H</em> but virtue grades not are cosidered as the &quot;noblemen&quot;, and are also ranked in non-increasing order according to their total grades, but they are listed after the &quot;sages&quot;. Those with both grades below <em>H</em>, but with virtue not lower than talent are considered as the &quot;fool men&quot;. They are ranked in the same way but after the &quot;noblemen&quot;. The rest of people whose grades both pass the <em>L</em> line are ranked after the &quot;fool men&quot;.</p>
<p>Then <em>N</em> lines follow, each gives the information of a person in the format:</p>
<pre><code>ID_Number Virtue_Grade Talent_Grade
</code></pre>
<p>where <code>ID_Number</code> is an 8-digit number, and both grades are integers in [0, 100]. All the numbers are separated by a space.</p>
<h3 id="output-specification">Output Specification:</h3>
<p>The first line of output must give <em>M</em> (≤<em>N</em>), the total number of people that are actually ranked. Then <em>M</em> lines follow, each gives the information of a person in the same format as the input, according to the ranking rules. If there is a tie of the total grade, they must be ranked with respect to their virtue grades in non-increasing order. If there is still a tie, then output in increasing order of their ID's.</p>
<h3 id="sample-input">Sample Input:</h3>
<pre><code class="language-in">14 60 80
10000001 64 90
10000002 90 60
10000011 85 80
10000003 85 80
10000004 80 85
10000005 82 77
10000006 83 76
10000007 90 78
10000008 75 79
10000009 59 90
10000010 88 45
10000012 80 100
10000013 90 99
10000014 66 60
</code></pre>
<h3 id="sample-output">Sample Output:</h3>
<pre><code class="language-out">12
10000013 90 99
10000012 80 100
10000003 85 80
10000011 85 80
10000004 80 85
10000007 90 78
10000006 83 76
10000005 82 77
10000002 90 60
10000014 66 60
10000008 75 79
10000001 64 90
</code></pre>
<hr>
<p>题目描述：有个人制定了规则，给定了天赋美德的评分界限，大于<em>等于</em>H的为优秀，小于H的为一般。他将人分为了四类，称天赋(talent)和美德(virtue)都优秀的人“圣人”；virtue优秀但talent一般的人为“君子”；virtue和talent都一般，但virtue分数高于<em>等于</em>talent分数的人为“愚人”；virtue和talent都一般，而且virtue分数低于talent分数的人为“小人”。</p>
<p>输入：第一行三个输入数据，N(&lt;=10<sup>5</sup>)需要排序的总人数，L分等级时的最低分数，H分等级时的优秀界限。接下来的n行，每行输入3个数，分别为ID_Number、Virtue_Grade、Talent_Grade。</p>
<p>输出：第一行输出一个参与排序的总人数，接着依照指定的排序规则，依序输出“圣人”、“君子”、“愚人”、“小人”。排序规则：先按照virtue+talent的总得分递减排序；当总分相同，则按照virtue得分递减排序；当总分相同、virtue得分相同，则按照ID递增排序。</p>
<p>解题思路：先过滤不符合排序的人，就是talent或virtue分数小于最低分数界限L的人。将四类人分为A、B、C、D四组；组分好后，进行排序，最后输出。</p>
<p>A--talent &gt;= H, virtue &gt;= H；<br>
B--talent &lt;H , virtue &gt;= H；<br>
C--talent &lt; H, virtue &lt; H &amp;&amp; virtue &gt;= talent；<br>
D--talent &lt; H, virtue &lt;H &amp;&amp; virtue &lt; talent；</p>
<hr>
<pre><code class="language-c++">#include&lt;bits/stdc++.h&gt;
using namespace std;
int n, l, h;
struct node{
	int id;
	int virtue, talent;
	int cid;
};
vector&lt;node&gt; v;
bool cmp(node a, node b){
	if(a.cid!=b.cid) return a.cid &lt; b.cid;
	else if(a.virtue+a.talent != b.virtue+b.talent) return a.virtue+a.talent &gt; b.virtue+b.talent;
	else if(a.virtue!=b.virtue) return a.virtue &gt; b.virtue;
	else if(a.id!=b.id) return a.id &lt; b.id;
}
int main()
{
	scanf(&quot;%d %d %d&quot;, &amp;n, &amp;l, &amp;h);
	for(int i=0; i&lt;n; i++){
		node t;
		scanf(&quot;%d %d %d&quot;, &amp;t.id, &amp;t.virtue, &amp;t.talent);
		if(t.talent&lt;l||t.virtue&lt;l) continue;
		if(t.talent&gt;=h&amp;&amp;t.virtue&gt;=h) t.cid = 1;
		else if(t.talent&lt;h&amp;&amp;t.virtue&gt;=h) t.cid = 2;
		else if(t.talent&lt;h&amp;&amp;t.virtue&lt;h&amp;&amp;t.virtue&gt;=t.talent) t.cid = 3;
		else t.cid = 4;
		v.push_back(t);
	}
	sort(v.begin(),v.end(),cmp);
	printf(&quot;%d\n&quot;, v.size());
	for(int i=0; i&lt;v.size(); i++){
		node t = v[i];
		printf(&quot;%d %d %d\n&quot;, t.id, t.virtue, t.talent);
	}
	return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[1045 Favorite Color Stripe (30分)题解]]></title>
        <id>https://ygytl.github.io/post/1045-favorite-color-stripe-30-fen-ti-jie/</id>
        <link href="https://ygytl.github.io/post/1045-favorite-color-stripe-30-fen-ti-jie/">
        </link>
        <updated>2020-05-25T15:39:27.000Z</updated>
        <summary type="html"><![CDATA[<p>1045 Favorite Color Stripe (30分)</p>
<p>Eva is trying to make her own color stripe out of a given one. She would like to keep only her favorite colors in her favorite order by cutting off those unwanted pieces and sewing the remaining parts together to form her favorite color stripe.</p>
<p>It is said that a normal human eye can distinguish about less than 200 different colors, so Eva's favorite colors are limited. However the original</p>
]]></summary>
        <content type="html"><![CDATA[<p>1045 Favorite Color Stripe (30分)</p>
<p>Eva is trying to make her own color stripe out of a given one. She would like to keep only her favorite colors in her favorite order by cutting off those unwanted pieces and sewing the remaining parts together to form her favorite color stripe.</p>
<p>It is said that a normal human eye can distinguish about less than 200 different colors, so Eva's favorite colors are limited. However the original</p>
<!-- more -->
<!-- more -->
<p>stripe could be very long, and Eva would like to have the remaining favorite stripe with the maximum length. So she needs your help to find her the best result.</p>
<p>Note that the solution might not be unique, but you only have to tell her the maximum length. For example, given a stripe of colors {2 2 4 1 5 5 6 3 1 1 5 6}. If Eva's favorite colors are given in her favorite order as {2 3 1 5 6}, then she has 4 possible best solutions {2 2 1 1 1 5 6}, {2 2 1 5 5 5 6}, {2 2 1 5 5 6 6}, and {2 2 3 1 1 5 6}.</p>
<h3 id="input-specification"><strong>Input Specification:</strong></h3>
<p>Each input file contains one test case. For each case, the first line contains a positive integer <strong>N</strong> (≤200) which is the total number of colors involved (and hence the colors are numbered from 1 to <strong>N</strong>). Then the next line starts with a positive integer <strong>M</strong> (≤200) followed by <strong>M</strong> Eva's favorite color numbers given in her favorite order. Finally the third line starts with a positive integer <strong>L</strong> (≤10<sup>4</sup>) which is the length of the given stripe, followed by <strong>L</strong> colors on the stripe. All the numbers in a line a separated by a space.</p>
<h3 id="output-specification"><strong>Output Specification:</strong></h3>
<p>For each test case, simply print in a line the maximum length of Eva's favorite stripe.</p>
<h3 id="sample-input"><strong>Sample Input:</strong></h3>
<pre><code class="language-in">
6

5 2 3 1 5 6

12 2 2 4 1 5 5 6 3 1 1 5 6

</code></pre>
<h3 id="sample-output"><strong>Sample Output:</strong></h3>
<pre><code class="language-out">
7

</code></pre>
<hr>
<p>题目描述：N为颜色求得色号吧(1~N)，给出M个数，表示用户最喜欢的摆放序列，从L个数中自主挑选排序，求出符合用户摆放序列要求的最长序列。</p>
<p>解题思路：动态规划</p>
<p>（1）将M个数用编号存放到数组</p>
<p>（2）从L个数中挑选用户喜欢的颜色序号放入容器</p>
<p>（3）动态规划的思想。。</p>
<hr>
<pre><code class="language-c++">#include&lt;bits/stdc++.h&gt;
using namespace std;
vector&lt;int&gt; v;
map&lt;int,int&gt; G;
const int maxn = 100050;
int dp[maxn];
int main()
{
	int n, m, k;
	int g;
	scanf(&quot;%d %d&quot;, &amp;n, &amp;m);
	for(int i=1; i&lt;=m; i++){
		scanf(&quot;%d&quot;, &amp;g);
		G[g] = i;
	}
	scanf(&quot;%d&quot;, &amp;k);
	for(int i=0; i&lt;k; i++){
		scanf(&quot;%d&quot;, &amp;g);
		if(G[g]!=0){
			v.push_back(G[g]);
		}
	}
	int l = v.size(), ans = 0;
	for(int i=0; i&lt;l; i++){
		dp[i] = 1;
		for(int j=0; j&lt;i; j++){
			if(v[j]&lt;=v[i]&amp;&amp;dp[i]&lt;dp[j]+1){
				dp[i] = dp[j]+1;
			}
		}
		ans = max(ans,dp[i]);
	}
	printf(&quot;%d\n&quot;, ans);
	return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[1063 Set Similarity (25分)题解]]></title>
        <id>https://ygytl.github.io/post/1063-set-similarity-25-fen-ti-jie/</id>
        <link href="https://ygytl.github.io/post/1063-set-similarity-25-fen-ti-jie/">
        </link>
        <updated>2020-05-25T01:49:12.000Z</updated>
        <content type="html"><![CDATA[<p>1063 Set Similarity (25分)</p>
<p>Given two sets of integers, the similarity of the sets is defined to be N<sub>c</sub>/N<sub>t</sub>×100%, where N<sub>c</sub> is the number of distinct common numbers shared by the two sets, and N<sub>t</sub> is the total number of distinct numbers in the two sets. Your job is to calculate the similarity of any given pair of sets.</p>
<h3 id="input-specification">Input Specification:</h3>
<p>Each input file contains one test case. Each case first gives a positive integer <em>N</em> (≤50) which is the total number of sets. Then <em>N</em> lines follow, each gives a set with a positive <em>M</em> (≤104) and followed by <em>M</em> integers in the range [0,109]. After the input of sets, a positive integer <em>K</em> (≤2000) is given, followed by <em>K</em> lines of queries. Each query gives a pair of set numbers (the sets are numbered from 1 to <em>N</em>). All the numbers in a line are separated by a space.</p>
<h3 id="output-specification">Output Specification:</h3>
<p>For each query, print in one line the similarity of the sets, in the percentage form accurate up to 1 decimal place.</p>
<h3 id="sample-input">Sample Input:</h3>
<pre><code class="language-in">3
3 99 87 101
4 87 101 5 87
7 99 101 18 5 135 18 99
2
1 2
1 3
</code></pre>
<h3 id="sample-output">Sample Output:</h3>
<pre><code class="language-out">50.0%
33.3%
</code></pre>
<hr>
<p>题目描述：求两个集合中，相同元素在两个集合中占比为多少。</p>
<p>输入数据：给n组集合，每组集合有m个元素，题目给出k组查询，每组询问两集合中相同元素的占比。</p>
<p>分析输入样例</p>
<p>查询1、2集合：相同数2（87 101）/总数4（87 101 99 87 5）=0.5<br>
查询1、3集合：相同数2（99 101）/总数6（99 87 101 18 5 135）=0.3</p>
<p>注意最后一个测试点容易超时，使用set的find()。</p>
<hr>
<pre><code class="language-C++">#include&lt;bits/stdc++.h&gt;
using namespace std;
vector&lt; set&lt;int&gt; &gt; v;
int main()
{
	int n, m, k, g;
	scanf(&quot;%d&quot;, &amp;n);
	v.resize(n+1);
	for(int i=1; i&lt;=n; i++){
		scanf(&quot;%d&quot;, &amp;m);
		for(int j=0; j&lt;m; j++){
			scanf(&quot;%d&quot;, &amp;g);
			v[i].insert(g);
		}
	}
	int count=0, all_num=0, a, b;
	scanf(&quot;%d&quot;, &amp;k);
	set&lt;int&gt;::iterator it;
	for(int i=0; i&lt;k; i++){
		scanf(&quot;%d %d&quot;, &amp;a, &amp;b);
		all_num = v[a].size()+v[b].size();
		count = 0;
		for(it=v[a].begin(); it!=v[a].end(); it++){
			if(v[b].find(*it)!=v[b].end()) count++;//在集合b中可以找到 
		}
		printf(&quot;%.1f%\n&quot;, count*100.0/(all_num-count));//共同的元素出现了两次 
	}
	return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[windows系统生成ssh key]]></title>
        <id>https://ygytl.github.io/post/windows-xi-tong-sheng-cheng-ssh-key/</id>
        <link href="https://ygytl.github.io/post/windows-xi-tong-sheng-cheng-ssh-key/">
        </link>
        <updated>2020-05-23T17:12:48.000Z</updated>
        <content type="html"><![CDATA[<h3 id="1-首先安装git工具运行git-bash输入指令进入ssh文件夹位置在桌面">1、首先安装Git工具，运行Git Bash，输入指令进入.ssh文件夹(位置在桌面)</h3>
<pre><code>cd ~/.ssh/
</code></pre>
<h3 id="2-如果提示-no-such-file-or-directory你可以手动的创建一个-ssh文件夹即可">2、 如果提示 “ No such file or directory”，你可以手动的创建一个 .ssh文件夹即可</h3>
<pre><code> mkdir ~/.ssh 
</code></pre>
<h3 id="3-配置全局的name和emailgithub的name和email">3、 配置全局的name和email，github的name和email</h3>
<pre><code> git config --global user.name &quot;yourname&quot;  

 git config --global user.email &quot;youremail@outlook.com&quot; 
</code></pre>
<h3 id="4-生成key">4、生成key</h3>
<pre><code> ssh-keygen -t rsa -C &quot;youremail@outlook.com&quot; 
</code></pre>
<p>连续按三次回车，这里设置的密码就为空了，并且创建了key。</p>
<p>最后得到了两个文件：id_rsa和id_rsa.pub</p>
<h3 id="5-打开id_rsapub复制里面的内容添加到你github就行了">5、 打开id_rsa.pub，复制里面的内容添加到你github就行了</h3>
]]></content>
    </entry>
</feed>