<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://ygytl.github.io/</id>
    <title>Grace</title>
    <updated>2020-06-04T08:45:30.922Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://ygytl.github.io/"/>
    <link rel="self" href="https://ygytl.github.io/atom.xml"/>
    <subtitle>Grace&apos;s blog</subtitle>
    <logo>https://ygytl.github.io/images/avatar.png</logo>
    <icon>https://ygytl.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, Grace</rights>
    <entry>
        <title type="html"><![CDATA[1068 Find More Coins (30分)题解]]></title>
        <id>https://ygytl.github.io/post/1068-find-more-coins-30-fen-ti-jie/</id>
        <link href="https://ygytl.github.io/post/1068-find-more-coins-30-fen-ti-jie/">
        </link>
        <updated>2020-06-04T08:13:06.000Z</updated>
        <content type="html"><![CDATA[<p>1068 Find More Coins (30分)</p>
<p>Eva loves to collect coins from all over the universe, including some other planets like Mars. One day she visited a universal shopping mall which could accept all kinds of coins as payments. However, there was a special requirement of the payment: for each bill, she must pay the exact amount. Since she has as many as 104 coins with her, she definitely needs your help. You are supposed to tell her, for any given amount of money, whether or not she can find some coins to pay for it.</p>
<h3 id="input-specification">Input Specification:</h3>
<p>Each input file contains one test case. For each case, the first line contains 2 positive numbers: <code>N</code> (≤104, the total number of coins) and <code>M</code> (≤102, the amount of money Eva has to pay). The second line contains <code>N</code> face values of the coins, which are all positive numbers. All the numbers in a line are separated by a space.</p>
<h3 id="output-specification">Output Specification:</h3>
<p>For each test case, print in one line the face values <em>V</em>1≤<em>V</em>2≤⋯≤<em>V**k</em> such that <em>V</em>1+<em>V</em>2+⋯+<em>V**k</em>=<code>M</code>. All the numbers must be separated by a space, and there must be no extra space at the end of the line. If such a solution is not unique, output the smallest sequence. If there is no solution, output &quot;No Solution&quot; instead.</p>
<p>Note: sequence {A[1], A[2], ...} is said to be &quot;smaller&quot; than sequence {B[1], B[2], ...} if there exists <em>k</em>≥1 such that A[<em>i</em>]=B[<em>i</em>] for all <em>i</em>&lt;<em>k</em>, and A[<em>k</em>] &lt; B[<em>k</em>].</p>
<h3 id="sample-input-1">Sample Input 1:</h3>
<pre><code class="language-in">8 9
5 9 8 7 2 3 4 1
</code></pre>
<h3 id="sample-output-1">Sample Output 1:</h3>
<pre><code class="language-out">1 3 5
</code></pre>
<h3 id="sample-input-2">Sample Input 2:</h3>
<pre><code>4 8
7 2 4 3
</code></pre>
<h3 id="sample-output-2">Sample Output 2:</h3>
<pre><code>No Solution
</code></pre>
<hr>
<p>题目描述：商店有多种商品，给出多种商品的重量，而你的购物车有规定的称重量，不能超过规定的重量，现在要你求出在购物车刚好能够装满其重量时，能够装的最多件物品数。</p>
</br>
<p>输入：第一行n表示商品数，m表示购物车能够称的总重量。第二行为n个物品的重量。</p>
<p>输出：输出购物车总重量刚好等于m的商品的重量，递增输出。如果没有则输出No Solution。</p>
<p>因为题目要求递增输出，需要先给wet排个序。</p>
</br>
<p>解题思路：01背包问题。这道题中可以假设weight=value，dp可以用一维数组来维护。</p>
<p>01背包(思想)：有n种物品，每种物品只有一件，给出物品重量weight和价值value。</p>
<p>dp[ i ][ j ] 表示 在面对第 i 件物品，且背包容量为 j 时所能获得的最大价值</p>
<ol>
<li>
<p>j &lt; weight[ i ]，背包容纳不了第 i 件物品，dp[ i ][ j ] = dp[ i-1 ][ j ]</p>
</li>
<li>
<p>j &gt;= weight[ i ]，背包可容纳第 i 件物品，可选放或不放，如果放入则dp[ i ][ j ] = dp[ i-1 ][ j - weight[ i ] ] + value[ i ]，如果不放入则与1)相同</p>
</li>
</ol>
<p>转移方程：dp[ i ][ j ]=max{ dp [ i-1 ][ j ],dp[ i-1 ][ j-v[ i ]]+w[ i ]}</p>
<pre><code>for i=1~N:
	for j=N~0:
		dp[j] = max{dp[j],dp[j-v[i]]+w[i]}
</code></pre>
</br>
<p>补充：</p>
<p>完全背包：有n种物品，每种物品有无数件，给出物品重量weight和价值value。</p>
<p>转移方程：dp[ i ][ v ] = max{ f [ i-1 ][ v - k*v[ i ]]+k*w[ i ] |0&lt;=k*v[ i ]&lt;=j}</p>
<pre><code>for i=1~N:
	for j=0~N:
		dp[j] = max{dp[j],dp[j-v[i]]+w[i]}
</code></pre>
<p>提示：每种背包都是无限的。当我们把i从1到N循环时，dp[j]表示容量为j在前i种背包时所得的价值，这里我们要添加的不是前一个背包，而是当前背包。所以我们要考虑的是当前状态。</p>
</br>
<p>多重背包：有n种物品，每种物品给定了数量count，商品重量weight和价值value。</p>
<p>dp[ i ][ j ] = max{ dp[ i-1 ][ j-  k* v[ i ]]+k*w[ i ] |0&lt;=k&lt;=n[ i ]}</p>
<hr>
<pre><code class="language-c++">#include&lt;bits/stdc++.h&gt;
using namespace std;
const int maxn = 10086;
int wet[maxn];
int dp[maxn];
int vis[maxn][110];
int n, m;
bool cmp(int a, int b){
	return a &gt; b;
}
int main()
{
	scanf(&quot;%d %d&quot;, &amp;n, &amp;m);
	memset(dp,0,sizeof(dp));
	memset(vis,false,sizeof(vis));
	for(int i=1; i&lt;=n; i++) scanf(&quot;%d&quot;, &amp;wet[i]);
	sort(wet+1,wet+n+1,cmp);
	for(int i=1; i&lt;=n; i++){
		for(int j=m; j&gt;=wet[i]; j--){//确保一定可放入第i件物品 
			if(dp[j-wet[i]]+wet[i]&gt;=dp[j]){
				dp[j] = dp[j-wet[i]]+wet[i];
				vis[i][j] = true;
			}
		}
	}
	vector&lt;int&gt; ans;
	if(dp[m]!=m) printf(&quot;No Solution&quot;);
	else{
		int x = n, y = m;
		while(y&gt;0){
			if(vis[x][y]){
				ans.push_back(wet[x]);
				y -= wet[x];
			}
			x--;
		}
		for(int i=0; i&lt;ans.size(); i++){
			if(i) printf(&quot; &quot;);
			printf(&quot;%d&quot;, ans[i]);
		}
	}
	return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[1075 PAT Judge (25分)题解]]></title>
        <id>https://ygytl.github.io/post/1075-pat-judge-25-fen-ti-jie/</id>
        <link href="https://ygytl.github.io/post/1075-pat-judge-25-fen-ti-jie/">
        </link>
        <updated>2020-06-03T10:16:48.000Z</updated>
        <content type="html"><![CDATA[<p>1075 PAT Judge (25分)</p>
<p>The ranklist of PAT is generated from the status list, which shows the scores of the submissions. This time you are supposed to generate the ranklist for PAT.</p>
<h3 id="input-specification">Input Specification:</h3>
<p>Each input file contains one test case. For each case, the first line contains 3 positive integers, <em>N</em> (≤10<sup>4</sup>), the total number of users, <em>K</em> (≤5), the total number of problems, and <em>M</em> (≤10<sup>5</sup>), the total number of submissions. It is then assumed that the user id's are 5-digit numbers from 00001 to <em>N</em>, and the problem id's are from 1 to <em>K</em>. The next line contains <em>K</em> positive integers <code>p[i]</code> (<code>i</code>=1, ..., <em>K</em>), where <code>p[i]</code> corresponds to the full mark of the i-th problem. Then <em>M</em> lines follow, each gives the information of a submission in the following format:</p>
<pre><code>user_id problem_id partial_score_obtained
</code></pre>
<p>where <code>partial_score_obtained</code> is either −1 if the submission cannot even pass the compiler, or is an integer in the range [0, <code>p[problem_id]</code>]. All the numbers in a line are separated by a space.</p>
<h3 id="output-specification">Output Specification:</h3>
<p>For each test case, you are supposed to output the ranklist in the following format:</p>
<pre><code>rank user_id total_score s[1] ... s[K]
</code></pre>
<p>where <code>rank</code> is calculated according to the <code>total_score</code>, and all the users with the same <code>total_score</code> obtain the same <code>rank</code>; and <code>s[i]</code> is the partial score obtained for the <code>i</code>-th problem. If a user has never submitted a solution for a problem, then &quot;-&quot; must be printed at the corresponding position. If a user has submitted several solutions to solve one problem, then the highest score will be counted.</p>
<p>The ranklist must be printed in non-decreasing order of the ranks. For those who have the same rank, users must be sorted in nonincreasing order according to the number of perfectly solved problems. And if there is still a tie, then they must be printed in increasing order of their id's. For those who has never submitted any solution that can pass the compiler, or has never submitted any solution, they must NOT be shown on the ranklist. It is guaranteed that at least one user can be shown on the ranklist.</p>
<h3 id="sample-input">Sample Input:</h3>
<pre><code class="language-in">7 4 20
20 25 25 30
00002 2 12
00007 4 17
00005 1 19
00007 2 25
00005 1 20
00002 2 2
00005 1 15
00001 1 18
00004 3 25
00002 2 25
00005 3 22
00006 4 -1
00001 2 18
00002 1 20
00004 1 15
00002 4 18
00001 3 4
00001 4 2
00005 2 -1
00004 2 0
</code></pre>
<h3 id="sample-output">Sample Output:</h3>
<pre><code class="language-out">1 00002 63 20 25 - 18
2 00005 42 20 0 22 -
2 00007 42 - 25 - 17
2 00001 42 18 18 4 2
5 00004 40 15 0 25 -
</code></pre>
<hr>
<p>题目描述：PAT的成绩排序，排序规则（总分递增排序；总分相同，完美解答题目数多者优先；前两者都相同时，id递增排序）</p>
</br>
<p>输入：第一行三个参数。n为参赛人数，k为总题数，M为参赛者答题情况数。下列m行，每行三个参数，分别为参赛者id，题号，答题所得分数</p>
<p>输出：输出有分数的参赛者参赛的排名、id、总分、各题得分。</p>
</br>
<p>解题思路：emmmm后续再长篇大论解释，现在先写一些注意事项</p>
<p>注意：</p>
<p>测试点2：编译未通过者得分为-1，不计入得分，编译通过者，但是得分为0，成绩记为0。有一参赛者1，他所有题目都编译未通过，他得分岁为0，但不将他计入排名。有一参赛者2，他只编译通过了1道题，但这道题成绩为0，而且他的其他题都编译未通过，那他与参赛者1是不同的，他是可以计入排名的。</p>
<p>测试点4：有些人，某道题已经提交过并且为满分了，他又去提交了一次，那么，他这第二次提交的满分记录，不计入完美答题数中。</p>
<hr>
<pre><code class="language-c++">#include&lt;bits/stdc++.h&gt;
using namespace std;
int n, k, m;
const int maxn = 1e5+1;
int score[maxn];
struct node{
	int id;
	int b[6];//记录每道题的分数 
	int all_score;
	int TG;
	int perfit_count;//记录完美答题个数 
	node(){
		TG = all_score = 0;
		perfit_count = 0;
		memset(b,-1,sizeof(b));
	}
};
map&lt;int,node&gt; p;
map&lt;int,int&gt; vis;
vector&lt;node&gt; v;
bool cmp(node a, node b){
	if(a.all_score!=b.all_score) return a.all_score &gt; b.all_score;
	else if(a.perfit_count!=b.perfit_count) return a.perfit_count &gt; b.perfit_count;
	else return a.id &lt; b.id;
}
int main()
{
	int A, B, C;
	scanf(&quot;%d %d %d&quot;, &amp;n, &amp;k, &amp;m);
	for(int i=1; i&lt;=k; i++) scanf(&quot;%d&quot;, &amp;score[i]);
	for(int i=0; i&lt;m; i++){
		scanf(&quot;%d %d %d&quot;, &amp;A, &amp;B, &amp;C);
		if(vis[A]==0){//没有记录过，把他添加到map中 
			node t;
			if(C==-1) C=0;
			else t.TG = 1;
			t.id = A;
			t.all_score = C;
			t.b[B] = C;
			if(C==score[B]){//标记B题已经满分 
				t.perfit_count++;
			}
			vis[A] = 1;
			p[A] = t;
		}
		else{//该学生之前已经答过题了 
			node t;
			t = p[A];
			if(C==-1) C=0;
			else t.TG = 1;
			if(t.b[B]==-1){//第B道题没有回答过 
				t.b[B] = C;
				t.all_score += C;
				if(C==score[B]){//标记B题已经满分 
					t.perfit_count++;
				}
			}
			else if(C&gt;t.b[B]){
				t.all_score -= t.b[B];
				t.all_score += C;
				t.b[B] = C;
				if(C==score[B]){//标记B题已经满分 
					t.perfit_count++;
				}
			}
			p[A] = t;
		}
	}
	map&lt;int,node&gt;::iterator it;
	node t;
	for(it=p.begin(); it!=p.end(); it++){
		t = it-&gt;second;
		if(t.TG) v.push_back(t);
	}
	sort(v.begin(),v.end(),cmp);
	int rank = 1, tscore=0;
	for(int i=0; i&lt;v.size(); i++){
		t = v[i];
		if(i==0) tscore = t.all_score;
		if(t.all_score!=tscore){
			rank = i+1;
			tscore = t.all_score;
		}
		printf(&quot;%d %05d %d&quot;, rank, t.id, t.all_score);
		for(int j=1; j&lt;=k; j++){
			if(t.b[j]==-1) printf(&quot; -&quot;);
			else printf(&quot; %d&quot;, t.b[j]);
		}
		printf(&quot;\n&quot;);
	}
	return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[1070 Mooncake (25分)题解]]></title>
        <id>https://ygytl.github.io/post/1070-mooncake-25-fen-ti-jie/</id>
        <link href="https://ygytl.github.io/post/1070-mooncake-25-fen-ti-jie/">
        </link>
        <updated>2020-06-03T07:58:17.000Z</updated>
        <content type="html"><![CDATA[<p>1070 Mooncake (25分)</p>
<p>Mooncake is a Chinese bakery product traditionally eaten during the Mid-Autumn Festival. Many types of fillings and crusts can be found in traditional mooncakes according to the region's culture. Now given the inventory amounts and the prices of all kinds of the mooncakes, together with the maximum total demand of the market, you are supposed to tell the maximum profit that can be made.</p>
<p>Note: partial inventory storage can be taken. The sample shows the following situation: given three kinds of mooncakes with inventory amounts being 180, 150, and 100 thousand tons, and the prices being 7.5, 7.2, and 4.5 billion yuans. If the market demand can be at most 200 thousand tons, the best we can do is to sell 150 thousand tons of the second kind of mooncake, and 50 thousand tons of the third kind. Hence the total profit is 7.2 + 4.5/2 = 9.45 (billion yuans).</p>
<h3 id="input-specification">Input Specification:</h3>
<p>Each input file contains one test case. For each case, the first line contains 2 positive integers <em>N</em> (≤1000), the number of different kinds of mooncakes, and <em>D</em> (≤500 thousand tons), the maximum total demand of the market. Then the second line gives the positive inventory amounts (in thousand tons), and the third line gives the positive prices (in billion yuans) of <em>N</em> kinds of mooncakes. All the numbers in a line are separated by a space.</p>
<h3 id="output-specification">Output Specification:</h3>
<p>For each test case, print the maximum profit (in billion yuans) in one line, accurate up to 2 decimal places.</p>
<h3 id="sample-input">Sample Input:</h3>
<pre><code class="language-in">3 200
180 150 100
7.5 7.2 4.5
</code></pre>
<h3 id="sample-output">Sample Output:</h3>
<pre><code class="language-out">9.45
</code></pre>
<hr>
<p>题目描述：月饼吧啦吧啦吧啦，直接分析样例，假设库存的月饼种数为3，三种月饼库存分别有180、150、100(千吨)，他们对应的总价值分别是7.5、7.2、4.5百万元。若现在市场的月饼需求量是200(千吨)，求出商家可赚的最大利润是多少。</p>
</br>
<p>输入：第一行包括两个数，n--月饼种数，D--市场的月饼需求量。第二行有n个数，分别表示n种月饼的库存量。第三行有n个数，分别表示n种月饼各自的总价值。</p>
<p>输出：商家可赚的最大总利润。</p>
</br>
<p>解题思路：每种月饼的参数都存放到结构体中，还要求出每种月饼的单品价格。将结构体数组根据单价进行排序，单品价格高，那商家所得利润也比较高是不。排好序，根据市场需求量进行购买计算。很简单的就能得到商家获得的最高总利润啦。</p>
<p>注意点：测试点2，月饼的库存量要用浮点数来存啊！！！</p>
<hr>
<pre><code class="language-c++">#include&lt;bits/stdc++.h&gt;
using namespace std;
struct node{
	double amount, price, avg;
};
vector&lt;node&gt; v;
bool cmp(node a, node b){
	return a.avg &gt; b.avg; 
}
int main()
{
	int n;
	double ans=0, d;
	node t;
	scanf(&quot;%d %lf&quot;, &amp;n, &amp;d);
	v.resize(n);
	for(int i=0; i&lt;n; i++) scanf(&quot;%lf&quot;, &amp;v[i].amount);
	for(int i=0; i&lt;n; i++){
		scanf(&quot;%lf&quot;, &amp;v[i].price);
		v[i].avg = v[i].price/v[i].amount;
	}
	sort(v.begin(),v.end(),cmp);
	for(int i=0; i&lt;v.size()&amp;&amp;d&gt;0; i++){
		t = v[i];
		if(t.amount&lt;=d){
			d -= t.amount;
			ans += t.price;
		}
		else{
			ans += t.avg*d;
			d = 0;
		}
	}
	printf(&quot;%.2f\n&quot;, ans);
	return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[1074 Reversing Linked List (25分)题解]]></title>
        <id>https://ygytl.github.io/post/1074-reversing-linked-list-25-fen-ti-jie/</id>
        <link href="https://ygytl.github.io/post/1074-reversing-linked-list-25-fen-ti-jie/">
        </link>
        <updated>2020-06-03T06:59:10.000Z</updated>
        <content type="html"><![CDATA[<p>1074 Reversing Linked List (25分)</p>
<p>Given a constant <em>K</em> and a singly linked list <em>L</em>, you are supposed to reverse the links of every <em>K</em> elements on <em>L</em>. For example, given <em>L</em> being 1→2→3→4→5→6, if <em>K</em>=3, then you must output 3→2→1→6→5→4; if <em>K</em>=4, you must output 4→3→2→1→5→6.</p>
<h3 id="input-specification">Input Specification:</h3>
<p>Each input file contains one test case. For each case, the first line contains the address of the first node, a positive <em>N</em> (≤105) which is the total number of nodes, and a positive <em>K</em> (≤<em>N</em>) which is the length of the sublist to be reversed. The address of a node is a 5-digit nonnegative integer, and NULL is represented by -1.</p>
<p>Then <em>N</em> lines follow, each describes a node in the format:</p>
<pre><code>Address Data Next
</code></pre>
<p>where <code>Address</code> is the position of the node, <code>Data</code> is an integer, and <code>Next</code> is the position of the next node.</p>
<h3 id="output-specification">Output Specification:</h3>
<p>For each case, output the resulting ordered linked list. Each node occupies a line, and is printed in the same format as in the input.</p>
<h3 id="sample-input">Sample Input:</h3>
<pre><code class="language-in">00100 6 4
00000 4 99999
00100 1 12309
68237 6 -1
33218 3 00000
99999 5 68237
12309 2 33218
</code></pre>
<h3 id="sample-output">Sample Output:</h3>
<pre><code class="language-out">00000 4 33218
33218 3 12309
12309 2 00100
00100 1 99999
99999 5 68237
68237 6 -1
</code></pre>
<hr>
<p>题目描述：有一条链表L，假设链表为1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;6，现在要求你将链表分组为每k个数一组，每组的链表反转后串连在一起，最后输出。若k=3，则反转后的链表为3-&gt;2-&gt;1-&gt;6-&gt;5-&gt;4，若k=4，4-&gt;3-&gt;2-&gt;1-&gt;5-&gt;6，可以看到1、2、3、4这四个数可以分为1组，然后将其反序输出了，而5、6不足一组，则按顺序输出。</p>
</br>
<p>输入：第一行包括三个数，链表头节点Head，n表示链表节点数，k表示k个算组分为一组。接下来n行，包括每个结点的head结点、num、next结点</p>
<p>输出：将反转后链表的每个结点按顺序输出。</p>
</br>
<p>解题思路：题目输入的结点顺序不是正确，需要通过题目给定的head头节点先将链表串起来。在输入的时候，就可以将每个结点放入结构体数组中，使用每个结点的head作为索引，存放好后，可以通过给定的链表头节点Head，将链表串起来，放入l2结构体容器中。后面只需要将容器分组。为每组个数都小于等于k，然后进行反转，再存放到l3结构体容器中，最后输出。这就大功告成啦。</p>
<p>使用结构体数组来模拟链表，实现起来比较简单。</p>
<hr>
<pre><code class="language-c++">#include&lt;bits/stdc++.h&gt;
using namespace std;
struct node{
	int head, num, next;
};
const int maxn = 100005;
node l1[maxn];
vector&lt;node&gt; l2, l3;
int main()
{
	node t;
	int head, n, k;
	scanf(&quot;%d %d %d&quot;, &amp;head, &amp;n, &amp;k);
	for(int i=0; i&lt;n; i++){
		scanf(&quot;%d %d %d&quot;, &amp;t.head, &amp;t.num, &amp;t.next);
		l1[t.head] = t;
	}
	while(head!=-1){
		t = l1[head];
		l2.push_back(t);
		head = t.next;
	}
	for(int i=0, j; i&lt;l2.size(); i+=k){
		if(i+k&lt;=l2.size()){
			j = i+k-1;
			while(j&gt;=i){
				l3.push_back(l2[j]);
				j--;
			}
		}
		else{
			j = i;
			while(j&lt;l2.size()){
				l3.push_back(l2[j]);
				j++;
			}
			break;
		}
	}
	for(int i=0; i&lt;l3.size()-1; i++){
		printf(&quot;%05d %d %05d\n&quot;, l3[i].head, l3[i].num, l3[i+1].head);
	}
	printf(&quot;%05d %d -1\n&quot;, l3[l3.size()-1].head, l3[l3.size()-1].num);
	return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[1073 Scientific Notation (20分)题解]]></title>
        <id>https://ygytl.github.io/post/1073-scientific-notation-20-fen-ti-jie/</id>
        <link href="https://ygytl.github.io/post/1073-scientific-notation-20-fen-ti-jie/">
        </link>
        <updated>2020-06-03T04:29:47.000Z</updated>
        <content type="html"><![CDATA[<p>1073 Scientific Notation (20分)</p>
<p>Scientific notation is the way that scientists easily handle very large numbers or very small numbers. The notation matches the regular expression [+-][1-9]<code>.</code>[0-9]+E[+-][0-9]+ which means that the integer portion has exactly one digit, there is at least one digit in the fractional portion, and the number and its exponent's signs are always provided even when they are positive.</p>
<p>Now given a real number <em>A</em> in scientific notation, you are supposed to print <em>A</em> in the conventional notation while keeping all the significant figures.</p>
<h3 id="input-specification">Input Specification:</h3>
<p>Each input contains one test case. For each case, there is one line containing the real number <em>A</em> in scientific notation. The number is no more than 9999 bytes in length and the exponent's absolute value is no more than 9999.</p>
<h3 id="output-specification">Output Specification:</h3>
<p>For each test case, print in one line the input number <em>A</em> in the conventional notation, with all the significant figures kept, including trailing zeros.</p>
<h3 id="sample-input-1">Sample Input 1:</h3>
<pre><code class="language-in">+1.23400E-03
</code></pre>
<h3 id="sample-output-1">Sample Output 1:</h3>
<pre><code class="language-out">0.00123400
</code></pre>
<h3 id="sample-input-2">Sample Input 2:</h3>
<pre><code class="language-in">-1.2E+10
</code></pre>
<h3 id="sample-output-2">Sample Output 2:</h3>
<pre><code class="language-out">-12000000000
</code></pre>
<hr>
<p>题目描述：给定一串表达式，其正则表达式可写为 [+-] [1-9] .[0-9]+E[+-][0-9]+，这里提示一下+ 这个符号，在正则表达式中，表示前一个字符的出现次数为&gt;=1。现在要你将这个表达式以它规定的规则输出。</p>
<p>输出规则：</p>
<p>1)表达式的第一个字符判断该数为正数或负数，若为负数，则输出'-'号</p>
<p>2)字母E后接的是正符号 或 负符号，正号表示将这个数扩大，负号表示将这个数缩小</p>
<p>3)字母E后面接的数字表示扩大或缩小多少，小数点往前移多少位，往后移多少位。</p>
</br>
<p>输入：字符串</p>
<p>输出：按规则输出</p>
</br>
<p>解题思路：</p>
<p>​    表达式中'.'和'E'是固定给出的，可以根据这两个字符将字符串切分。将数字部分提取出来，稍后进行字符串拼接。例如将小数点前的数字记为s1，小数点到字母E之间的数字记为s2，字母E后面的数字记为s3，且将s3转化为整数k，以便将数字放大或缩小。</p>
<p>​    可以将放大和缩小分开来求。1、若k=0，就表示不需要将数据放大或缩小，直接将s1和s2进行拼接，注意s1和s2之间还需加上个小数点；2、将数据缩小其实就是考虑怎么在数据前补0的问题，讨论要不要补0，或要补多少。直接用k减去s1的长度就能求出该在0.后追加几个0了；3、将数据放大则考虑在s2后补多少个0，这要分两部分讨论，1)当扩大倍数小于s2字符串长度(数据本身的小数点位数)时，这种情况下不用补0，需要把小数点放到正确的位置，再将字符串进行拼接就行。2)当扩大倍数大于s2字符串长度时，需要补0，补多少个0，直接k减去s2字符串长度即可。</p>
<p>注意：测试点4，就是讨论当扩大倍数小于s2字符串长度(数据本身的小数点位数)时的情况。</p>
<p>附加测试点4测试数据：</p>
<p>输入：-1.123456E+03，输出-1123.456</p>
<hr>
<pre><code class="language-c++">#include&lt;bits/stdc++.h&gt;
using namespace std;
int get_num(string s){
	int ans = 0;
	for(int i=0; i&lt;s.size(); i++){
		ans = ans*10 + s[i]-'0';
	}
	return ans;
}
int main()
{
	string s, str;
	cin &gt;&gt; s;
	if(s[0]=='-') cout &lt;&lt; '-';
	
	str = s.substr(1);
	string s1=&quot;&quot;, s2=&quot;&quot;, s3=&quot;&quot;;
	int g1=0, g2=0;
	g1 = str.find('.');
	g2 = str.find('E');
	
	s1 = str.substr(0,g1);
	s2 = str.substr(g1+1,g2-g1-1);
	s3 = str.substr(g2+2);
	
	int k = get_num(s3);
	if(k==0){
		cout &lt;&lt; s1 + '.' + s2 &lt;&lt; endl;
		return 0;
	}
	
	string ans = &quot;&quot;;
	if(str[g2+1]=='-'){//前面追加 
		ans = &quot;0.&quot;;
		k-=s1.size();
		while(k){
			ans += '0';
			k--;
		}
		ans = ans + s1 + s2; 
	}
	else{//后面追加 
		int l = s2.size();
		if(k-l&lt;0){
			ans += s1;
			ans += s2.substr(0,k);
			ans += '.';
			ans += s2.substr(k);
		}
		else{
			k-=s2.size();
			ans = ans + s1 + s2;
			while(k){
				ans += '0';
				k--;
			}
		}
	}
	cout &lt;&lt; ans &lt;&lt; endl;
	return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[1064 Complete Binary Search Tree (30分)题解]]></title>
        <id>https://ygytl.github.io/post/1064-complete-binary-search-tree-30-fen-ti-jie/</id>
        <link href="https://ygytl.github.io/post/1064-complete-binary-search-tree-30-fen-ti-jie/">
        </link>
        <updated>2020-06-02T16:06:30.000Z</updated>
        <content type="html"><![CDATA[<p>1064 Complete Binary Search Tree (30分)</p>
<p>A Binary Search Tree (BST) is recursively defined as a binary tree which has the following properties:</p>
<ul>
<li>The left subtree of a node contains only nodes with keys less than the node's key.</li>
<li>The right subtree of a node contains only nodes with keys greater than or equal to the node's key.</li>
<li>Both the left and right subtrees must also be binary search trees.</li>
</ul>
<p>A Complete Binary Tree (CBT) is a tree that is completely filled, with the possible exception of the bottom level, which is filled from left to right.</p>
<p>Now given a sequence of distinct non-negative integer keys, a unique BST can be constructed if it is required that the tree must also be a CBT. You are supposed to output the level order traversal sequence of this BST.</p>
<h3 id="input-specification">Input Specification:</h3>
<p>Each input file contains one test case. For each case, the first line contains a positive integer <em>N</em> (≤1000). Then <em>N</em> distinct non-negative integer keys are given in the next line. All the numbers in a line are separated by a space and are no greater than 2000.</p>
<h3 id="output-specification">Output Specification:</h3>
<p>For each test case, print in one line the level order traversal sequence of the corresponding complete binary search tree. All the numbers in a line must be separated by a space, and there must be no extra space at the end of the line.</p>
<h3 id="sample-input">Sample Input:</h3>
<pre><code class="language-in">10
1 2 3 4 5 6 7 8 9 0
</code></pre>
<h3 id="sample-output">Sample Output:</h3>
<pre><code class="language-out">6 3 8 1 5 7 9 0 2 4
</code></pre>
<hr>
<p>题目描述：给一棵完全二叉搜索树（满二叉搜索树），求输出它的层序遍历。</p>
<p>二叉搜索树的性质：</p>
<p>1、左子结点权值小于其父结点的权值</p>
<p>2、右子结点权值大于其父结点的权值</p>
<p>3、每个左右子结点都是二叉搜索树</p>
</br>
<p>输入：第一行n表示结点个数，第二行表示结点的权值。</p>
<p>输出：输出其层序遍历的结果</p>
</br>
<p>解题思路：不需要建树。先将各个结点的权值保存到数组中，接着将数组从小到大排序，以便放入正确的层序遍历数组中。通常将树放入数组中时，都会牺牲0号索引，从索引1开始存储。用递归算法就能获得层序遍历的结果，接下来利用题目给出的例子分析下这个递归算法。</p>
<p>样例构建出来的树长这样：<br>
<img src="https://ygytl.github.io//post-images/1591114718233.jpg" alt="" width="300" height="400" loading="lazy"></p>
<p>根据上图，可得到层序遍历数组：</p>
<table>
<thead>
<tr>
<th>index</th>
<th style="text-align:center">1</th>
<th style="text-align:center">2</th>
<th style="text-align:center">3</th>
<th style="text-align:center">4</th>
<th style="text-align:center">5</th>
<th style="text-align:center">6</th>
<th style="text-align:center">7</th>
<th style="text-align:center">8</th>
<th style="text-align:center">9</th>
<th style="text-align:center">10</th>
</tr>
</thead>
<tbody>
<tr>
<td>num</td>
<td style="text-align:center">6</td>
<td style="text-align:center">3</td>
<td style="text-align:center">8</td>
<td style="text-align:center">1</td>
<td style="text-align:center">5</td>
<td style="text-align:center">7</td>
<td style="text-align:center">9</td>
<td style="text-align:center">0</td>
<td style="text-align:center">2</td>
<td style="text-align:center">4</td>
</tr>
</tbody>
</table>
<p>现在模拟递归算法的过程：</p>
<p>n = 10</p>
<ol>
<li>
<p>root = 1，root&lt;=n为true，进入if语句中---后续还未完成</p>
</li>
<li>
<p>执行get_level(root*2)，即get_level(1*2)，root=2，root&lt;=n为true，进入if语句中---后续还未完成</p>
</li>
<li>
<p>执行get_level(root*2)，即get_level(2*2)，root=4，root&lt;=n为true，进入if语句中---后续还未完成</p>
</li>
<li>
<p>执行get_level(root*2)，即get_level(4*2)，root=8，root&lt;=n为true，进入if语句中---后续还未完成</p>
</li>
<li>
<p>执行get_level(roo*2)，即get_level(8*2)，root=16，root&lt;=n为false！<em>步骤 5)执行完毕</em>。返回上一条语句，即步骤 4)，执行未完成的部分。</p>
</li>
</ol>
<p>这时，步骤5) 返回到 步骤 4) 的后续执行步骤，root=8且c=0，level[root]=v[c++]即level[8]=v[0]，且c=1。</p>
<ol start="6">
<li>
<p>接着往下执行，root = 8， get_level(root*2+1)，即get_level(8*2+1)---步骤6)只是个过渡，已完成。</p>
</li>
<li>
<p>get_level(17)，root = 17，root&lt;=n为false！<em>步骤7) 执行完毕</em>。至此，<em>步骤4才真正执行完毕</em>。返回上一条语句，即步骤 3)，执行未完成的部分。</p>
</li>
</ol>
<p>这时，步骤7) 返回到 步骤3) 的后续执行步骤，root=4且c=1，level[root]=v[c++]即level[4]=v[1]，且c=2。</p>
<ol start="8">
<li>
<p>接着往下执行，root = 4，get_level(root*2+1)，即get_level(4*2+1)---步骤8)只是个过渡，已完成。</p>
</li>
<li>
<p>get_level(9)，root = 9，root&lt;=n为true，进入if语句中---后续还未完成</p>
</li>
<li>
<p>执行get_level(root*2)，即get_level(9*2)，root=18，root&lt;=n为false！<em>步骤10) 执行完毕</em>。返回到上一条语句，即步骤9)，执行未完成部分</p>
</li>
</ol>
<p>这时，步骤10) 返回到 步骤 9)的后续执行步骤，root=9且c=2，level[root]=v[c++]即level[9]=v[2]，且c=3。</p>
<ol start="11">
<li>
<p>接着往下执行，root = 9，get_level(root*2+1)，即get_level(9*2+1)---步骤11)只是个过渡，已完成。</p>
</li>
<li>
<p>get_level(19)，root = 19，root&lt;=n为false！至此，<em>步骤 9)执行完毕</em>，<em>步骤3)也执行完毕</em>。---步骤12)只是个过渡，已完成。</p>
</li>
<li>
<p>步骤12) 执行完比后，会返回上一个为执行完成的步骤，即步骤2)，往后以此类推。。。</p>
</li>
</ol>
</br>
<p>上述过程写的看似复杂，但是自己动手把数据带入进去，模拟一下就也就那么回事，不难不难。</p>
<hr>
<pre><code class="language-c++">#include&lt;bits/stdc++.h&gt;
using namespace std;
int n, c=0;
vector&lt;int&gt; level, v;
void get_level(int root){
	if(root&lt;=n){
		get_level(root*2);
		level[root] = v[c++];
		get_level(root*2+1);
	}
}
int main()
{
	scanf(&quot;%d&quot;, &amp;n);
	v.resize(n);
	level.resize(n+1);
	for(int i=0; i&lt;n; i++){
		scanf(&quot;%d&quot;, &amp;v[i]);
	}
	sort(v.begin() ,v.end());
	get_level(1);
	for(int i=1; i&lt;=n; i++){
		if(i!=1) printf(&quot; &quot;);
		printf(&quot;%d&quot;, level[i]);
	}
	return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[1053 Path of Equal Weight (30分)题解]]></title>
        <id>https://ygytl.github.io/post/1053-path-of-equal-weight-30-fen-ti-jie/</id>
        <link href="https://ygytl.github.io/post/1053-path-of-equal-weight-30-fen-ti-jie/">
        </link>
        <updated>2020-06-02T04:29:04.000Z</updated>
        <content type="html"><![CDATA[<p>1053 Path of Equal Weight (30分)</p>
<p>Given a non-empty tree with root <em>R</em>, and with weight <em>W**i</em> assigned to each tree node <em>T**i</em>. The <strong>weight of a path from *R* to *L*</strong> is defined to be the sum of the weights of all the nodes along the path from <em>R</em> to any leaf node <em>L</em>.</p>
<p>Now given any weighted tree, you are supposed to find all the paths with their weights equal to a given number. For example, let's consider the tree showed in the following figure: for each node, the upper number is the node ID which is a two-digit number, and the lower number is the weight of that node. Suppose that the given number is 24, then there exists 4 different paths which have the same given weight: {10 5 2 7}, {10 4 10}, {10 3 3 6 2} and {10 3 3 6 2}, which correspond to the red edges in the figure.</p>
<figure data-type="image" tabindex="1"><img src="https://images.ptausercontent.com/212" alt="img" loading="lazy"></figure>
<h3 id="input-specification">Input Specification:</h3>
<p>Each input file contains one test case. Each case starts with a line containing 0&lt;<em>N</em>≤100, the number of nodes in a tree, <em>M</em> (&lt;<em>N</em>), the number of non-leaf nodes, and 0&lt;<em>S</em>&lt;230, the given weight number. The next line contains <em>N</em> positive numbers where <em>W**i</em> (&lt;1000) corresponds to the tree node <em>T**i</em>. Then <em>M</em> lines follow, each in the format:</p>
<pre><code>ID K ID[1] ID[2] ... ID[K]
</code></pre>
<p>where <code>ID</code> is a two-digit number representing a given non-leaf node, <code>K</code> is the number of its children, followed by a sequence of two-digit <code>ID</code>'s of its children. For the sake of simplicity, let us fix the root ID to be <code>00</code>.</p>
<h3 id="output-specification">Output Specification:</h3>
<p>For each test case, print all the paths with weight S in <strong>non-increasing</strong> order. Each path occupies a line with printed weights from the root to the leaf in order. All the numbers must be separated by a space with no extra space at the end of the line.</p>
<p>Note: sequence {<em>A</em>1,<em>A</em>2,⋯,<em>A**n</em>} is said to be <strong>greater than</strong> sequence {<em>B</em>1,<em>B</em>2,⋯,<em>B**m</em>} if there exists 1≤<em>k</em>&lt;<em>m<strong>i</strong>n</em>{<em>n</em>,<em>m</em>} such that <em>A**i</em>=<em>B**i</em> for <em>i</em>=1,⋯,<em>k</em>, and <em>A**k</em>+1&gt;<em>B**k</em>+1.</p>
<h3 id="sample-input">Sample Input:</h3>
<pre><code class="language-in">20 9 24
10 2 4 3 5 10 2 18 9 7 2 2 1 3 12 1 8 6 2 2
00 4 01 02 03 04
02 1 05
04 2 06 07
03 3 11 12 13
06 1 09
07 2 08 10
16 1 15
13 3 14 16 17
17 2 18 19
</code></pre>
<h3 id="sample-output">Sample Output:</h3>
<pre><code class="language-out">10 5 2 7
10 4 10
10 3 3 6 2
10 3 3 6 2
</code></pre>
<hr>
<p>题目描述：现在有一棵树，让你找到根结点到叶子结点总权值为给定值的路径。</p>
</br>
<p>输入：n：节点总数，m：非叶子结点个数；s：假定要求的根节点到叶子节点总权值；接下来m行，包括id：结点编号，k：子结点个数，接下来k个子结点编号。</p>
<p>输出：根结点到叶子结点的过程中经过的总权值等于s，输出所经过结点的权值。</p>
</br>
<p>解题思路：这道题不用建树，用有向图保存这棵树就行。可以用BFS算法或DFS算法。</p>
<p>这里列举BFS算法详解：每个结点的权值保存在weight数组中，边的关系保存在G邻接表中。从root结点层层遍历，很简单的就可以得到根节点到各个叶子结点的总权值了。最重要的还是输出顺序的问题，我先将符合条件的路径权值数组存入ans二维数组容器中，最后将二维数组进行排序。排序规则是每个数组中同一位置的权值最大的序列排在前面输出。</p>
<hr>
<pre><code class="language-c++">//BFS 广度优先
#include&lt;bits/stdc++.h&gt;
using namespace std;
struct node{
	int id;
	long long ss;
	vector&lt;int&gt; list;
	node(){
		ss = 0;
	}
};
int n, m;
long long s;
const int maxn = 220;
int weight[maxn];
vector&lt;int&gt; G[maxn];
vector&lt; vector&lt;int&gt; &gt; ans;
bool cmp(vector&lt;int&gt; a, vector&lt;int&gt; b){
	int l=0;
	l = min(a.size(),b.size());
	for(int i=0; i&lt;l; i++){
		if(a[i]==b[i]) continue;
		else return a[i] &gt; b[i];
	}
	return false; //如果没有，最后一个测试点段错误! 
}
void bfs(int root){
	node t, tt;
	queue&lt;node&gt; q;
	t.id = root; t.ss = weight[root];
	t.list.push_back(weight[root]);
	q.push(t);
	
	int u, v;
	while(!q.empty()){
		t = q.front();
		u = t.id;
		q.pop();
		if(t.ss==s&amp;&amp;G[u].size()==0){
			ans.push_back(t.list);
			continue;
		}
		else if(t.ss &gt; s) continue;
		for(int i=0; i&lt;G[u].size(); i++){
			v = G[u][i];
			tt.id = v; tt.ss = t.ss + weight[v]; tt.list = t.list;
			tt.list.push_back(weight[v]);
			q.push(tt);
		}
	}
	sort(ans.begin(),ans.end(),cmp);
	
	for(int i=0; i&lt;ans.size(); i++){
		for(int j=0; j&lt;ans[i].size(); j++){
			if(j) printf(&quot; &quot;);
			printf(&quot;%d&quot;, ans[i][j]);
		}
		printf(&quot;\n&quot;);
	}
}
int main()
{
	scanf(&quot;%d %d %lld&quot;, &amp;n, &amp;m, &amp;s);
	int id, k, g;
	for(int i=0; i&lt;n; i++) scanf(&quot;%d&quot;, &amp;weight[i]);
	for(int i=0; i&lt;m; i++){
		scanf(&quot;%d %d&quot;, &amp;id, &amp;k);
		for(int j=0; j&lt;k; j++){
			scanf(&quot;%d&quot;, &amp;g);
			G[id].push_back(g);
		}
	}
	bfs(0);
	return 0;
}
</code></pre>
<pre><code class="language-c++">//DFS 深度优先
#include&lt;bits/stdc++.h&gt;
using namespace std;
struct node{
	int w;
	vector&lt;int&gt; child;
};
vector&lt;node&gt; v;
vector&lt;int&gt; path;
int target;
void dfs(int index, int nodenum, int sum){
	if(sum&gt;target) return ;
	if(sum==target){
		if(v[index].child.size()!=0) return;
		for(int i=0; i&lt;nodenum; i++){
			printf(&quot;%d%c&quot;, v[path[i]].w, i!=nodenum-1?' ':'\n');
		}
		return;
	}
	for(int i=0; i&lt;v[index].child.size(); i++){
		int nd = v[index].child[i];
		path[nodenum] = nd;
		dfs(nd,nodenum+1,sum+v[nd].w);
	}
}
int cmp(int a, int b){
	return v[a].w &gt; v[b].w;
}
int main()
{
	int n, m, node, k;
	scanf(&quot;%d %d %d&quot;, &amp;n, &amp;m, &amp;target);
	v.resize(n), path.resize(n);
	for(int i=0; i&lt;n; i++){
		scanf(&quot;%d&quot;, &amp;v[i].w);
	}
	for(int i=0; i&lt;m; i++){
		scanf(&quot;%d %d&quot;, &amp;node, &amp;k);
		v[node].child.resize(k);
		for(int j=0; j&lt;k; j++) scanf(&quot;%d&quot;, &amp;v[node].child[j]);
		sort(v[node].child.begin(),v[node].child.end(),cmp);
	}
	dfs(0,1,v[0].w);
	return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[1069 The Black Hole of Numbers (20分)题解]]></title>
        <id>https://ygytl.github.io/post/1069-the-black-hole-of-numbers-20-fen-ti-jie/</id>
        <link href="https://ygytl.github.io/post/1069-the-black-hole-of-numbers-20-fen-ti-jie/">
        </link>
        <updated>2020-06-02T02:55:21.000Z</updated>
        <content type="html"><![CDATA[<p>1069 The Black Hole of Numbers (20分)</p>
<p>For any 4-digit integer except the ones with all the digits being the same, if we sort the digits in non-increasing order first, and then in non-decreasing order, a new number can be obtained by taking the second number from the first one. Repeat in this manner we will soon end up at the number <code>6174</code> -- the <strong>black hole</strong> of 4-digit numbers. This number is named Kaprekar Constant.</p>
<p>For example, start from <code>6767</code>, we'll get:</p>
<pre><code>7766 - 6677 = 1089
9810 - 0189 = 9621
9621 - 1269 = 8352
8532 - 2358 = 6174
7641 - 1467 = 6174
... ...
</code></pre>
<p>Given any 4-digit number, you are supposed to illustrate the way it gets into the black hole.</p>
<h3 id="input-specification">Input Specification:</h3>
<p>Each input file contains one test case which gives a positive integer <em>N</em> in the range (0,10<sup>4</sup>).</p>
<h3 id="output-specification">Output Specification:</h3>
<p>If all the 4 digits of <em>N</em> are the same, print in one line the equation <code>N - N = 0000</code>. Else print each step of calculation in a line until <code>6174</code> comes out as the difference. All the numbers must be printed as 4-digit numbers.</p>
<h3 id="sample-input-1">Sample Input 1:</h3>
<pre><code class="language-in">6767
</code></pre>
<h3 id="sample-output-1">Sample Output 1:</h3>
<pre><code class="language-out">7766 - 6677 = 1089
9810 - 0189 = 9621
9621 - 1269 = 8352
8532 - 2358 = 6174
</code></pre>
<h3 id="sample-input-2">Sample Input 2:</h3>
<pre><code class="language-in">2222
</code></pre>
<h3 id="sample-output-2">Sample Output 2:</h3>
<pre><code class="language-out">2222 - 2222 = 0000
</code></pre>
<hr>
<p>题目描述：有一个小于10000的数n，n中的每一个数字重新排序，可以组成最大数和最小数，例如1001，可以重新排序得到max=1100，min=0011，用max - min得到的值进行循环，最终会得到6174或0000。现在就是要将求得6174或0000的过程模拟出来。</p>
</br>
<p>输入：小于10000的数</p>
<p>输出：输出max - min的计算结果为6174或0000的过程</p>
</br>
<p>解题思路：利用sscanf和sprintf两个函数进行模拟，使用字符的形式进行排序。注意以数字形式输出是，不满4 digits在前面要补0。</p>
<hr>
<pre><code class="language-c++">#include&lt;bits/stdc++.h&gt;
using namespace std;
int main()
{
	int val1, val2;
	int n;
	scanf(&quot;%d&quot;, &amp;n);
	char s[10];
	while(n){
		sprintf(s, &quot;%04d&quot;, n);// 发送格式化输出到 s
		sort(s,s+4);
		sscanf(s, &quot;%d&quot;, &amp;val2);//从字符串读取格式化输入 s -&gt; val2
		reverse(s,s+4);
		sscanf(s, &quot;%d&quot;, &amp;val1);//s -&gt;val1
		int g = val1 - val2;
		printf(&quot;%04d - %04d = %04d\n&quot;, val1, val2, g);
		if(g==0 || g==6174) break;
		n = g;
	}
	return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[1071 Speech Patterns (25分)题解]]></title>
        <id>https://ygytl.github.io/post/1071-speech-patterns-25-fen-ti-jie/</id>
        <link href="https://ygytl.github.io/post/1071-speech-patterns-25-fen-ti-jie/">
        </link>
        <updated>2020-06-01T14:54:10.000Z</updated>
        <content type="html"><![CDATA[<p>1071 Speech Patterns (25分)</p>
<p>People often have a preference among synonyms of the same word. For example, some may prefer &quot;the police&quot;, while others may prefer &quot;the cops&quot;. Analyzing such patterns can help to narrow down a speaker's identity, which is useful when validating, for example, whether it's still the same person behind an online avatar.</p>
<p>Now given a paragraph of text sampled from someone's speech, can you find the person's most commonly used word?</p>
<h3 id="input-specification">Input Specification:</h3>
<p>Each input file contains one test case. For each case, there is one line of text no more than 1048576 characters in length, terminated by a carriage return <code>\n</code>. The input contains at least one alphanumerical character, i.e., one character from the set [<code>0-9 A-Z a-z</code>].</p>
<h3 id="output-specification">Output Specification:</h3>
<p>For each test case, print in one line the most commonly occurring word in the input text, followed by a space and the number of times it has occurred in the input. If there are more than one such words, print the lexicographically smallest one. The word should be printed in all lower case. Here a &quot;word&quot; is defined as a continuous sequence of alphanumerical characters separated by non-alphanumerical characters or the line beginning/end.</p>
<p>Note that words are case <strong>insensitive</strong>.</p>
<h3 id="sample-input">Sample Input:</h3>
<pre><code class="language-in">Can1: &quot;Can a can can a can?  It can!&quot;
</code></pre>
<h3 id="sample-output">Sample Output:</h3>
<pre><code class="language-out">can 5
</code></pre>
<hr>
<p>题目描述：求给定的字符串中，出现次数最多的单词，这些单词由数字、大小写字母组成。</p>
</br>
<p>输入：一串字符串</p>
<p>输出：出现最多的单词及出现次数<br>
</br></p>
<p>解题思路：getline函数读取所有字符，要在读入所有字符后加一个字符'.'，当读入的最后一个字符是数字或者大小写字母时，比较容易将最后一个单词切分出来。接着，根据特殊字符来切分单词，并用map&lt;string,int&gt;来记录每个单词出现的次数。在记录的同时，我们也可以把答案顺便找出来。用ans和count两个量简单比较就行了。</p>
<p>注意：最后一个测试点就是卡在最后一个单词有没有正确切分并计数。</p>
<hr>
<pre><code class="language-c++">#include&lt;bits/stdc++.h&gt;
using namespace std;
map&lt;string,int&gt; p;
int main()
{
	string s, t=&quot;&quot;;
	getline(cin,s);
	s += '.';//不加最后一个测试点会错 
	int l = s.length();
	string ans=&quot;&quot;;
	int count = 0;
	for(int i=0; i&lt;l; i++){
		if(s[i]&gt;='0'&amp;&amp;s[i]&lt;='9'){
			t += s[i];
		}
		else if(s[i]&gt;='A'&amp;&amp;s[i]&lt;='Z'){
			t += s[i]-'A'+'a';
		}
		else if(s[i]&gt;='a'&amp;&amp;s[i]&lt;='z'){
			t += s[i];
		}
		else{
			if(t.length()!=0) p[t]++;
			if(p[t]==count){
				ans = t &lt; ans ? t : ans;
			}
			else if(p[t]&gt;count){
				count = p[t];
				ans = t;
			}
			t = &quot;&quot;;
		}
	}
	cout &lt;&lt; ans &lt;&lt; &quot; &quot; &lt;&lt; count &lt;&lt; endl;
	return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[P2 并发与并行的区别、同步与异步的解析]]></title>
        <id>https://ygytl.github.io/post/p2-bing-fa-yu-bing-xing-de-qu-bie-tong-bu-yu-yi-bu-de-jie-xi/</id>
        <link href="https://ygytl.github.io/post/p2-bing-fa-yu-bing-xing-de-qu-bie-tong-bu-yu-yi-bu-de-jie-xi/">
        </link>
        <updated>2020-06-01T06:23:42.000Z</updated>
        <content type="html"><![CDATA[<h2 id="并发与并行的区别">并发与并行的区别</h2>
<h3 id="并发">并发</h3>
<p>并发：每个时间段只允许处理一个进程<br>
多个进程看似在同步运行，但并非正正的在同一时刻同时运行<br>
例如：一个人一边在煮菜，一边在看书，他不可能在煮菜时同时看书，<br>
只能先把菜放入锅里煮时，抽空走出厨房，回到房里看书，当菜煮好了，<br>
又要放下书，回去把菜翻炒翻炒。炒菜和看书看似同时进行，但实际上，<br>
炒菜和看书，一个时间段只能处理其一。</p>
<h3 id="并行">并行</h3>
<p>并行：多个进程在同一时刻同时运行<br>
例如：类似有多核CPU处理程序，还是炒菜和看书的例子，<br>
就就好像有两个人在处理，一个人在炒菜，同时，另一个人在看书，<br>
这两件事是同一时刻同时进行的。</p>
<p>Python中如何实现并发进程？？？<br>
利用 多进程、多线程、异步编程即可</p>
<p>Multiple Processes<br>
抢占式多任务，操作系统调度，可使用多核CPU</p>
<p>Multiple Threads<br>
抢占式多任务，操作系统调度，不能使用多核CPU</p>
<p>Asynchronous Programming<br>
协作式多任务，单进程、单线程</p>
<h2 id="同步与异步">同步与异步</h2>
<p>先看同步对弈和异步对弈</p>
<p>前提条件：假设A要与B<sub>1</sub> ~ B<sub>12</sub> 对弈，A思考需要5s，B<sub>1</sub> ~ B<sub>12</sub> 中，每个人要思考55s，对局需要30个回合才能分输赢，下棋时常忽略不计。</p>
<p>同步对弈 Synchronous<br>
同步对弈指：A与B<sub>1</sub>对弈完成后，才开始与B<sub>2</sub>对弈，以此类推，所以A走完30个回合的总时间是(5+55)*30*12=21600s</p>
<p>异步对弈 Asychronous<br>
异步对弈指：A与B<sub>1</sub>对弈时，A先下花了5s与B<sub>1</sub>下第一回合，B<sub>1</sub>需要花55s的时间思考，A不等待B<sub>1</sub>，直接与B<sub>2</sub>对弈，一直到与B<sub>12</sub>对弈了后，才返回跟B<sub>1</sub>对弈。而这时，A走完每个棋局的第一步需要花费12*5=60s，60s过去B<sub>1</sub>已经走完第一步，A与B<sub>1</sub>进行第二回合的对弈。A走完30个回合的总时间是60*30=1800s</p>
<p>21600/1800 = 12，异步对弈效率提高了12倍</p>
<h3 id="异步编程">异步编程：</h3>
<p>指在 单线程 中 并发 执行多个任务，当一个任务在等待数据时，它会释放 CPU 资源，</p>
<p>转而执行其它任务，通过程序员自己主动切换任务来最小化空闲时间。<br>
异步实现：异步函数在等待数据时被暂停执行，当数据到达时，又能够在被暂停的位置处恢复执行。</p>
<h3 id="异步-io-操作">异步 I/O 操作</h3>
<p>指当你发起一个 I/O 操作（比如，等待网络图片数据的到来），却不用等它结束，<br>
你可以继续去做其它的事情，当它结束时，你会得到通知，然后再回来接着处理这个 I/O 后续的操作。<br>
而 同步 I/O 操作 则会被阻塞在 I/O 操作上直到它完成，这期间 CPU 做了很多事，只是没有运行你的程序。</p>
]]></content>
    </entry>
</feed>