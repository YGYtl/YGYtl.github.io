<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://ygytl.github.io/</id>
    <title>Grace</title>
    <updated>2020-06-07T09:14:19.717Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://ygytl.github.io/"/>
    <link rel="self" href="https://ygytl.github.io/atom.xml"/>
    <subtitle>Grace&apos;s blog</subtitle>
    <logo>https://ygytl.github.io/images/avatar.png</logo>
    <icon>https://ygytl.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, Grace</rights>
    <entry>
        <title type="html"><![CDATA[1080 Graduate Admission (30分)题解]]></title>
        <id>https://ygytl.github.io/post/1080-graduate-admission-30-fen-ti-jie/</id>
        <link href="https://ygytl.github.io/post/1080-graduate-admission-30-fen-ti-jie/">
        </link>
        <updated>2020-06-07T09:14:00.000Z</updated>
        <content type="html"><![CDATA[<p>1080 Graduate Admission (30分)</p>
<p>It is said that in 2011, there are about 100 graduate schools ready to proceed over 40,000 applications in Zhejiang Province. It would help a lot if you could write a program to automate the admission procedure.</p>
<p>Each applicant will have to provide two grades: the national entrance exam grade <em>G**E</em>, and the interview grade <em>G**I</em>. The final grade of an applicant is (<em>G**E</em>+<em>G**I</em>)/2. The admission rules are:</p>
<ul>
<li>The applicants are ranked according to their final grades, and will be admitted one by one from the top of the rank list.</li>
<li>If there is a tied final grade, the applicants will be ranked according to their national entrance exam grade <em>G**E</em>. If still tied, their ranks must be the same.</li>
<li>Each applicant may have <em>K</em> choices and the admission will be done according to his/her choices: if according to the rank list, it is one's turn to be admitted; and if the quota of one's most preferred shcool is not exceeded, then one will be admitted to this school, or one's other choices will be considered one by one in order. If one gets rejected by all of preferred schools, then this unfortunate applicant will be rejected.</li>
<li>If there is a tied rank, and if the corresponding applicants are applying to the same school, then that school must admit all the applicants with the same rank, <strong>even if its quota will be exceeded</strong>.</li>
</ul>
<h3 id="input-specification">Input Specification:</h3>
<p>Each input file contains one test case.</p>
<p>Each case starts with a line containing three positive integers: <em>N</em> (≤40,000), the total number of applicants; <em>M</em> (≤100), the total number of graduate schools; and <em>K</em> (≤5), the number of choices an applicant may have.</p>
<p>In the next line, separated by a space, there are <em>M</em> positive integers. The <em>i</em>-th integer is the quota of the <em>i</em>-th graduate school respectively.</p>
<p>Then <em>N</em> lines follow, each contains 2+<em>K</em> integers separated by a space. The first 2 integers are the applicant's <em>G**E</em> and <em>G**I</em>, respectively. The next <em>K</em> integers represent the preferred schools. For the sake of simplicity, we assume that the schools are numbered from 0 to <em>M</em>−1, and the applicants are numbered from 0 to <em>N</em>−1.</p>
<h3 id="output-specification">Output Specification:</h3>
<p>For each test case you should output the admission results for all the graduate schools. The results of each school must occupy a line, which contains the applicants' numbers that school admits. The numbers must be in increasing order and be separated by a space. There must be no extra space at the end of each line. If no applicant is admitted by a school, you must output an empty line correspondingly.</p>
<h3 id="sample-input">Sample Input:</h3>
<pre><code class="language-in">11 6 3
2 1 2 2 2 3
100 100 0 1 2
60 60 2 3 5
100 90 0 3 4
90 100 1 2 0
90 90 5 1 3
80 90 1 0 2
80 80 0 1 2
80 80 0 1 2
80 70 1 3 2
70 80 1 2 3
100 100 0 2 4
</code></pre>
<h3 id="sample-output">Sample Output:</h3>
<pre><code class="language-out">0 10
3
5 6 7
2 8

1 4
</code></pre>
<hr>
<p>题目描述：学校录取学生的模拟过程</p>
</br>
<p>输入：第一行n，m，k。分别为学生人数，学校数，学生可填报志愿数。第二行m个值，分别表示学校录取的人数。接下来n行，为学生的考试成绩GE，GI，以及填报的k个学校。</p>
<p>输出：每个学校录取的学生编号，从小到大输出。</p>
<p>录取规则：成绩排序，总分=（GE+GI）/2，总分高排在前面；当总分相同时，GE成绩高排在前面；当总分和GE都相同时，排名并列。如果学校最后录取的学生有多名排名是一样的，超额也要将他们都录取了。</p>
</br>
<p>解题思路：模拟题，很容易就把简单的问题复杂化了。先将学生按照成绩排序，分高的选择权。可以从第一名开始按其意愿选择学校，当他选择的学校没有录取满人时，他就会直接被学校录取，当学校录取满人了，其他成绩比较低的就无法再进入这满了人的学校，只能看其他志愿。</p>
<p>注意：在学校最后录取的学生成绩/排名不唯一时，怎么把排名相同的全部录取？这需要将学校最后录取的人的分数记录下来，就两个数组记录一下就行了。</p>
<p>模拟题得多做几道，找找感觉！</p>
<hr>
<pre><code class="language-c++">#include&lt;bits/stdc++.h&gt;
using namespace std;
const int maxn = 40000+5;
int n, m, k, snum[200], ltsum[200], ltge[200];
bool vis[maxn];
struct node{
	int ge, gi, id, sum;
	vector&lt;int&gt; sc;
	bool operator &lt;( const node &amp;x )const{
        if( sum!=x.sum ) return sum &gt; x.sum;
        return ge &gt; x.ge;
    }
};
vector&lt;int&gt; ans[200];
vector&lt;node&gt; v;
//bool cmp(node a, node b){
//	if(a.sum!=b.sum) return a.sum &gt; b.sum;
//	else return a.ge &gt; b.ge;
//}
int main()
{
	int g;
	memset(vis,true,sizeof(vis));
	scanf(&quot;%d %d %d&quot;, &amp;n, &amp;m, &amp;k);
	for(int i=0; i&lt;m; i++) scanf(&quot;%d&quot;, &amp;snum[i]);
	for(int i=0; i&lt;n; i++){//学生 
		node t;
		scanf(&quot;%d %d&quot;, &amp;t.ge, &amp;t.gi);
		t.id = i; t.sum = t.ge+t.gi;
		for(int j=0; j&lt;k; j++){
			scanf(&quot;%d&quot;, &amp;g);
			t.sc.push_back(g);//学生报志愿 
		}
		v.push_back(t);
	}
//	sort(v.begin(),v.end(),cmp);
	sort(v.begin(), v.end());
	for(int i=0; i&lt;n; i++){
		node t = v[i];
		for(int j=0; j&lt;k; j++){
			int cid = t.sc[j];
			if(!vis[t.id]) continue;
			if(ans[cid].size()&lt;snum[cid]){
				ltsum[cid] = t.sum;
				ltge[cid] = t.ge;
				ans[cid].push_back(t.id);
				vis[t.id] = false;
			}
			else if(t.sum==ltsum[cid]&amp;&amp;t.ge==ltge[cid]){
				ans[cid].push_back(t.id);
				vis[t.id] = false;
			}
		}
	}
	for(int i=0; i&lt;m; i++){
		sort(ans[i].begin(),ans[i].end());
		for(int j=0; j&lt;ans[i].size(); j++){
			if(j) printf(&quot; &quot;);
			printf(&quot;%d&quot;, ans[i][j]);
		}
		printf(&quot;\n&quot;);
	}
	return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[1076 Forwards on Weibo (30分)题解]]></title>
        <id>https://ygytl.github.io/post/1076-forwards-on-weibo-30-fen-ti-jie/</id>
        <link href="https://ygytl.github.io/post/1076-forwards-on-weibo-30-fen-ti-jie/">
        </link>
        <updated>2020-06-06T10:01:02.000Z</updated>
        <content type="html"><![CDATA[<p>1076 Forwards on Weibo (30分)</p>
<p>Weibo is known as the Chinese version of Twitter. One user on Weibo may have many followers, and may follow many other users as well. Hence a social network is formed with followers relations. When a user makes a post on Weibo, all his/her followers can view and forward his/her post, which can then be forwarded again by their followers. Now given a social network, you are supposed to calculate the maximum potential amount of forwards for any specific user, assuming that only <em>L</em> levels of indirect followers are counted.</p>
<h3 id="input-specification">Input Specification:</h3>
<p>Each input file contains one test case. For each case, the first line contains 2 positive integers: <em>N</em> (≤1000), the number of users; and <em>L</em> (≤6), the number of levels of indirect followers that are counted. Hence it is assumed that all the users are numbered from 1 to <em>N</em>. Then <em>N</em> lines follow, each in the format:</p>
<pre><code>M[i] user_list[i]
</code></pre>
<p>where <code>M[i]</code> (≤100) is the total number of people that <code>user[i]</code> follows; and <code>user_list[i]</code> is a list of the <code>M[i]</code> users that followed by <code>user[i]</code>. It is guaranteed that no one can follow oneself. All the numbers are separated by a space.</p>
<p>Then finally a positive <em>K</em> is given, followed by <em>K</em> <code>UserID</code>'s for query.</p>
<h3 id="output-specification">Output Specification:</h3>
<p>For each <code>UserID</code>, you are supposed to print in one line the maximum potential amount of forwards this user can trigger, assuming that everyone who can view the initial post will forward it once, and that only <em>L</em> levels of indirect followers are counted.</p>
<h3 id="sample-input">Sample Input:</h3>
<pre><code class="language-in">7 3
3 2 3 4
0
2 5 6
2 3 1
2 3 4
1 4
1 5
2 2 6
</code></pre>
<h3 id="sample-output">Sample Output:</h3>
<pre><code class="language-out">4
5
</code></pre>
<hr>
<p>题目描述：微博吧啦吧啦。。现在！给你一个社会网图，你需要求出最大潜在的转发数时多少，假设只能传到L层关系。</p>
</br>
<p>输入：第一行两个正整数N(&lt;=1000)用户数，L(&lt;=6)转发层。接下来有N行，每行代表第i个用户关注的人(i=1~N)，每行格式为M[i] user_list[i]，user_list时用户的编号。最后一行，第一个数K是带查询个数，接下来就是K个值啦。比如样例中最后一行K=2，带查询的第一个值是2。分析下样例，先把图画出来，当2发出一篇微博时，他最大能被转发的次数是多少？显然是4，他能被(1、4、5、6)转发。</p>
<p>输出：转发的次数</p>
</br>
<p>解题思路：要查询那个点，就从哪个点开始广搜遍历就行了。</p>
<p>注意：很简单的一道BFS题，不知道为什么会出现在30分这里。难道是因为最后一个测试点卡着了？最后一个测试点容易超时。</p>
<hr>
<pre><code class="language-c++">#include&lt;bits/stdc++.h&gt;
using namespace std;
int n, l;
const int maxn = 1000+5;
vector&lt;int&gt; G[maxn];
bool vis[maxn];
struct node{
	int index, level;
	node(){
		index = level = 0;
	}
};
void query(int start){
	fill(vis,vis+maxn,false);
	node t, tt;
	t.index = start;
	t.level = 0;
	queue&lt;node&gt; q;
	q.push(t);
	vis[start] = true;
	int ans = 0;
	while(!q.empty()){
		t = q.front(); q.pop();
		for(int i=0; i&lt;G[t.index].size(); ++i){
			int u = G[t.index][i];
			if(!vis[u]&amp;&amp;t.level&lt;l){
				ans++;
				vis[u] = true;
				tt.index = u;
				tt.level = t.level+1;
				q.push(tt);
			}
		}
	}
	printf(&quot;%d\n&quot;, ans);
}
int main()
{
	int k, g;
	scanf(&quot;%d %d&quot;, &amp;n, &amp;l);
	for(int i=1; i&lt;=n; ++i){
		scanf(&quot;%d&quot;, &amp;k);
		for(int j=0; j&lt;k; ++j){
			scanf(&quot;%d&quot;, &amp;g);
			G[g].push_back(i);
		}
	}
	scanf(&quot;%d&quot;, &amp;k);
	for(int i=0; i&lt;k; ++i){
		scanf(&quot;%d&quot;, &amp;g);
		query(g);
	}
	return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[1081 Rational Sum (20分)题解]]></title>
        <id>https://ygytl.github.io/post/1081-rational-sum-20-fen-ti-jie/</id>
        <link href="https://ygytl.github.io/post/1081-rational-sum-20-fen-ti-jie/">
        </link>
        <updated>2020-06-06T09:12:16.000Z</updated>
        <content type="html"><![CDATA[<p>1081 Rational Sum (20分)</p>
<p>Given <em>N</em> rational numbers in the form <code>numerator/denominator</code>, you are supposed to calculate their sum.</p>
<h3 id="input-specification">Input Specification:</h3>
<p>Each input file contains one test case. Each case starts with a positive integer <em>N</em> (≤100), followed in the next line <em>N</em> rational numbers <code>a1/b1 a2/b2 ...</code> where all the numerators and denominators are in the range of <strong>long int</strong>. If there is a negative number, then the sign must appear in front of the numerator.</p>
<h3 id="output-specification">Output Specification:</h3>
<p>For each test case, output the sum in the simplest form <code>integer numerator/denominator</code> where <code>integer</code> is the integer part of the sum, <code>numerator</code> &lt; <code>denominator</code>, and the numerator and the denominator have no common factor. You must output only the fractional part if the integer part is 0.</p>
<h3 id="sample-input-1">Sample Input 1:</h3>
<pre><code class="language-in">5
2/5 4/15 1/30 -2/60 8/3
</code></pre>
<h3 id="sample-output-1">Sample Output 1:</h3>
<pre><code class="language-out">3 1/3
</code></pre>
<h3 id="sample-input-2">Sample Input 2:</h3>
<pre><code class="language-in">2
4/3 2/3
</code></pre>
<h3 id="sample-output-2">Sample Output 2:</h3>
<pre><code class="language-out">2
</code></pre>
<h3 id="sample-input-3">Sample Input 3:</h3>
<pre><code class="language-in">3
1/3 -1/6 1/8
</code></pre>
<h3 id="sample-output-3">Sample Output 3:</h3>
<pre><code class="language-out">7/24
</code></pre>
<hr>
<p>题目描述：分数求和。</p>
</br>
<p>输入：第一行n表示分数的个数，第二行n个分数。</p>
<p>输出：分数之和。输出格式 1）4/3输出1 2/3；2）4 /4 输出 1；3）2/3输出2/3</p>
</br>
<p>解题思路：我习惯将程序分块写，这样程序看起来比较直观清晰；将所有分数加起来，可以先记录第一个分数，分子为a1、分母为b1，接着读第二个分数，第二个分数分子为a2，分母为b2，接着就可以将两个分数进行计算了，然后将计算结果分别再存入a1和b1；后面读入的分数都存在a2和b2中，重复上述过程。得到的结果a1和b1按照题目规定输出格式输出。</p>
<p>两个分数相加的过程：例如2/5和4/15相加，想求出两个分母的最大公因数为5，两个分母同时除于5，分别得到b1=1，b2=3，将分子a1乘与b2，a2乘与b1，则a1=6，a2=4，此时，分数分别为6/1和4/3，让a1=a1+a2=10，b1 = b1*b2*gcd(b1,b2)=15（分母进行通分的过程），这样就能将两分数相加的结果放入a1和b1了，即2/5 + 4 / 15 = 10 / 15。</p>
<hr>
<pre><code class="language-c++">#include&lt;bits/stdc++.h&gt;
using namespace std;
int n, a1, b1, a2, b2;
int gcd(int a, int b){ return a == 0 ? b : gcd(b % a, a); } 
void sum(){
	int g = gcd(b1,b2);
	b1 /= g;
	b2 /= g;
	a1*=b2; a2 *= b1;
	a1 += a2;
	b1 *= b2*g;
}
int main()
{
	scanf(&quot;%d&quot;, &amp;n);
	for(int i=0; i&lt;n; i++){
		if(i==0) scanf(&quot;%d/%d&quot;, &amp;a1, &amp;b1);
		else{
			scanf(&quot;%d/%d&quot;, &amp;a2, &amp;b2);
			sum();
		}
	}
	int g = gcd(a1,b1);
	a1 /= g; b1 /= g;
	if(a1%b1==0) printf(&quot;%d\n&quot;, a1/b1);
	else if(a1&gt;b1) printf(&quot;%d %d/%d\n&quot;, a1/b1, a1%b1, b1);
	else printf(&quot;%d/%d&quot;, a1%b1, b1);
	return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[1079 Total Sales of Supply Chain (25分)题解]]></title>
        <id>https://ygytl.github.io/post/1079-total-sales-of-supply-chain-25-fen-ti-jie/</id>
        <link href="https://ygytl.github.io/post/1079-total-sales-of-supply-chain-25-fen-ti-jie/">
        </link>
        <updated>2020-06-06T03:48:31.000Z</updated>
        <content type="html"><![CDATA[<p>1079 Total Sales of Supply Chain (25分)</p>
<p>A supply chain is a network of retailers（零售商）, distributors（经销商）, and suppliers（供应商）-- everyone involved in moving a product from supplier to customer.</p>
<p>Starting from one root supplier, everyone on the chain buys products from one's supplier in a price <em>P</em> and sell or distribute them in a price that is <em>r</em>% higher than <em>P</em>. Only the retailers will face the customers. It is assumed that each member in the supply chain has exactly one supplier except the root supplier, and there is no supply cycle.</p>
<p>Now given a supply chain, you are supposed to tell the total sales from all the retailers.</p>
<h3 id="input-specification">Input Specification:</h3>
<p>Each input file contains one test case. For each case, the first line contains three positive numbers: <em>N</em> (≤105), the total number of the members in the supply chain (and hence their ID's are numbered from 0 to <em>N</em>−1, and the root supplier's ID is 0); <em>P</em>, the unit price given by the root supplier; and <em>r</em>, the percentage rate of price increment for each distributor or retailer. Then <em>N</em> lines follow, each describes a distributor or retailer in the following format:</p>
<p><em>K**i</em> ID[1] ID[2] ... ID[<em>K**i</em>]</p>
<p>where in the <em>i</em>-th line, <em>K**i</em> is the total number of distributors or retailers who receive products from supplier <em>i</em>, and is then followed by the ID's of these distributors or retailers. <em>K**j</em> being 0 means that the <em>j</em>-th member is a retailer, then instead the total amount of the product will be given after <em>K**j</em>. All the numbers in a line are separated by a space.</p>
<h3 id="output-specification">Output Specification:</h3>
<p>For each test case, print in one line the total sales we can expect from all the retailers, accurate up to 1 decimal place. It is guaranteed that the number will not exceed 1010.</p>
<h3 id="sample-input">Sample Input:</h3>
<pre><code class="language-in">10 1.80 1.00
3 2 3 5
1 9
1 4
1 7
0 7
2 6 1
1 8
0 9
0 4
0 3
</code></pre>
<h3 id="sample-output">Sample Output:</h3>
<pre><code class="language-out">42.4
</code></pre>
<hr>
<p>题目描述：有一条销售链，供应商、经销商、零售商，供应商提供货物给经销商，经销商提供货物给零售商，题目要求出零售商售出的总额是多少。0号索引表示供应商。供应商的售价p，经销商的售价p1 = r%*p，零售商售价p2 = r%*p1。</p>
</br>
<p>输入：第一行三个数，n为节点数，p为商品原价，即供应商的出价，r为售价的增幅。接下来n行（表示0~n-1个结点的情况），分两种情况</p>
<p>1)第一个值为0，第二个值就表示零售商需要销售商品的数量</p>
<p>2)第一个值不为0，则第一个值表示第i个结点的子结点个数m，后面接着m个子结点的编号。</p>
<p>输出：零售商售出的总额，保留一位小数</p>
</br>
<p>解题思路：典型的bfs题，使用邻接表存树，节约空间。</p>
<p>注意，题目给的是r，我们计算时要计算r%，所以r*1.0/100。</p>
<hr>
<pre><code class="language-c++">#include&lt;bits/stdc++.h&gt;
using namespace std;
int n;
double p, r;
const int maxn = 200005;
vector&lt;int&gt; G[maxn];
map&lt;int,int&gt; lvs_sell;
struct node{
	int index;
	double price;
};
void bfs(){
	node t, tt;
	t.index = 0; t.price = p;
	queue&lt;node&gt; q;
	q.push(t);
	double ans = 0;
	while(!q.empty()){
		t = q.front();
		q.pop();
		if(G[t.index].size()==0){
			ans += lvs_sell[t.index]*t.price;
		}
		else{
			for(int i=0; i&lt;G[t.index].size(); i++){
				int v = G[t.index][i];
				tt.index = v;
				tt.price = r*t.price;
				q.push(tt);
			}
		}
	}
	printf(&quot;%.1f&quot;, ans);
}
int main()
{
	scanf(&quot;%d %lf %lf&quot;, &amp;n, &amp;p, &amp;r);
	r = r*1.0/100 + 1;
	int a, b;
	for(int i=0; i&lt;n; i++){
		scanf(&quot;%d %d&quot;, &amp;a, &amp;b);
		if(a==0) lvs_sell[i] = b;
		else{
			G[i].push_back(b);
			for(int j=1; j&lt;a; j++){
				scanf(&quot;%d&quot;, &amp;b);
				G[i].push_back(b);
			}
		}
	}
	bfs();
	return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[1078 Hashing (25分)题解]]></title>
        <id>https://ygytl.github.io/post/1078-hashing-25-fen-ti-jie/</id>
        <link href="https://ygytl.github.io/post/1078-hashing-25-fen-ti-jie/">
        </link>
        <updated>2020-06-06T02:29:52.000Z</updated>
        <content type="html"><![CDATA[<p>1078 Hashing (25分)</p>
<p>The task of this problem is simple: insert a sequence of distinct positive integers into a hash table, and output the positions of the input numbers. The hash function is defined to be <em>H</em>(<em>k<strong>e</strong>y</em>)=<em>k<strong>e</strong>y</em>%<em>T<strong>S</strong>i<strong>z</strong>e</em> where <em>T<strong>S</strong>i<strong>z</strong>e</em> is the maximum size of the hash table. Quadratic probing (with positive increments only) is used to solve the collisions.</p>
<p>Note that the table size is better to be prime. If the maximum size given by the user is not prime, you must re-define the table size to be the smallest prime number which is larger than the size given by the user.</p>
<h3 id="input-specification">Input Specification:</h3>
<p>Each input file contains one test case. For each case, the first line contains two positive numbers: <em>M<strong>S</strong>i<strong>z</strong>e</em> (≤104) and <em>N</em> (≤<em>M<strong>S</strong>i<strong>z</strong>e</em>) which are the user-defined table size and the number of input numbers, respectively. Then <em>N</em> distinct positive integers are given in the next line. All the numbers in a line are separated by a space.</p>
<h3 id="output-specification">Output Specification:</h3>
<p>For each test case, print the corresponding positions (index starts from 0) of the input numbers in one line. All the numbers in a line are separated by a space, and there must be no extra space at the end of the line. In case it is impossible to insert the number, print &quot;-&quot; instead.</p>
<h3 id="sample-input">Sample Input:</h3>
<pre><code class="language-in">4 4
10 6 4 15
</code></pre>
<h3 id="sample-output">Sample Output:</h3>
<pre><code class="language-out">0 1 4 -
</code></pre>
<hr>
<p>题目描述：把哈希表实现出来。</p>
</br>
<p>输入：Msize数组长度，n插入值得个数</p>
<p>输出：插入每个值得位置</p>
</br>
<p>解题思路：Quadratic probing (with positive increments only) is used to solve the collisions.</p>
<p>这句话是重点，必须理解，Quadratic二次方，probe探测，collision冲突；遇到冲突使用二次探测存放！</p>
<p>二次探测公式：H(Key) = (Key + i*i)  (i=0....n-1)</p>
<p>解这道题，因为哈希表得的长度规定选为素数，所以，当Msize不为素数，需要将大于Msize的最小素数求出，可以用一个数组先将素数表存好，方便查询。然后把二次探测公式实现就行了。</p>
<hr>
<pre><code class="language-c++">#include&lt;bits/stdc++.h&gt;
using namespace std;
const int maxn = 20005;
vector&lt;int&gt; prime;
int p[maxn];
bool is_prime(int k){
	if(k==0||k==1) return false;
	for(int i=2; i&lt;=sqrt(k); i++){
		if(k%i==0) return false;
	}
	return true;
}
int find_prime(int k){
	for(int i=0; i&lt;prime.size(); i++){
		if(prime[i]&gt;k) return prime[i];
	}
	return 0;
}
int main()
{
	memset(p,-1,sizeof(p));
	prime.push_back(2);
	for(int i=3; i&lt;=maxn; i+=2){
		if(is_prime(i)) prime.push_back(i);
	}
	int n, m;
	long long k;
	scanf(&quot;%d %d&quot;, &amp;n, &amp;m);
	if(!is_prime(n)) n = find_prime(n);
	
	for(int i=0; i&lt;m; i++){
		scanf(&quot;%lld&quot;, &amp;k);
		if(i) printf(&quot; &quot;);
		int g = k%n, c=0;
		while(p[g]!=-1&amp;&amp;c&lt;n){
			c++;
			g = (k+c*c)%n;
		}
		if(p[g]!=-1) printf(&quot;-&quot;);
		else{
			p[g%n] = g%n;
			printf(&quot;%d&quot;, g%n);
		}
	}
	return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[1077 Kuchiguse (20分)题解]]></title>
        <id>https://ygytl.github.io/post/1077-kuchiguse-20-fen-ti-jie/</id>
        <link href="https://ygytl.github.io/post/1077-kuchiguse-20-fen-ti-jie/">
        </link>
        <updated>2020-06-05T14:43:46.000Z</updated>
        <content type="html"><![CDATA[<p>1077 Kuchiguse (20分)</p>
<p>The Japanese language is notorious for its sentence ending particles. Personal preference of such particles can be considered as a reflection of the speaker's personality. Such a preference is called &quot;Kuchiguse&quot; and is often exaggerated artistically in Anime and Manga. For example, the artificial sentence ending particle &quot;nyan~&quot; is often used as a stereotype for characters with a cat-like personality:</p>
<ul>
<li>Itai nyan~ (It hurts, nyan~)</li>
<li>Ninjin wa iyada nyan~ (I hate carrots, nyan~)</li>
</ul>
<p>Now given a few lines spoken by the same character, can you find her Kuchiguse?</p>
<h3 id="input-specification">Input Specification:</h3>
<p>Each input file contains one test case. For each case, the first line is an integer <em>N</em> (2≤<em>N</em>≤100). Following are <em>N</em> file lines of 0~256 (inclusive) characters in length, each representing a character's spoken line. The spoken lines are case sensitive.</p>
<h3 id="output-specification">Output Specification:</h3>
<p>For each test case, print in one line the kuchiguse of the character, i.e., the longest common suffix of all <em>N</em> lines. If there is no such suffix, write <code>nai</code>.</p>
<h3 id="sample-input-1">Sample Input 1:</h3>
<pre><code class="language-in">3
Itai nyan~
Ninjin wa iyadanyan~
uhhh nyan~
</code></pre>
<h3 id="sample-output-1">Sample Output 1:</h3>
<pre><code class="language-out">nyan~
</code></pre>
<h3 id="sample-input-2">Sample Input 2:</h3>
<pre><code class="language-in">3
Itai!
Ninjinnwaiyada T_T
T_T
</code></pre>
<h3 id="sample-output-2">Sample Output 2:</h3>
<pre><code class="language-out">nai
</code></pre>
<hr>
<p>题目描述：找到一个人平时说话最常用的结尾语。</p>
</br>
<p>输入：第一行n，接下来n行字符串。</p>
<p>输出：每行共同的后缀字符串。若没有公共字符串后缀，则输出nai。</p>
</br>
<p>解题思路：先读入n，然后保存第一串字符串，与之后的n-1串字符串相比较，找到每行中相同的后缀。怎么找呢？比较两个字符串长度，取字符串长度较小的进行for循环，保证字符数组不会越界，两个字符串同时从末尾开始比较。这样就可以得到他们的公共后缀长度啦，当有一组公共后缀长度为0，用flag标记一下，最后输出结果就行。</p>
<hr>
<pre><code class="language-c++">#include&lt;bits/stdc++.h&gt;
using namespace std;
int main()
{
	int n, l, l1, l2, common;
	bool flag = true;
	scanf(&quot;%d&quot;, &amp;n);
	getchar();
	string s, tmp;
	for(int i=0; i&lt;n; i++){
		getline(cin,tmp);
		if(i==0){
			s = tmp;
			l1 = s.length();
			common = l1;
			continue;
		}
		l2 = tmp.length();
		l = min(l1,l2);
		int count = 0;
		for(int j=1; j&lt;=l; j++){
			if(tmp[l2-j]==s[l1-j]){
				count++;
			}
			else break;
		}
		if(count==0){
			flag = false;
		}
		common = min(common,count);
	}
	if(flag){
		string ans = s.substr(l1-common);
		cout &lt;&lt; ans &lt;&lt; endl;
	}
	else printf(&quot;nai\n&quot;);
	return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[1068 Find More Coins (30分)题解]]></title>
        <id>https://ygytl.github.io/post/1068-find-more-coins-30-fen-ti-jie/</id>
        <link href="https://ygytl.github.io/post/1068-find-more-coins-30-fen-ti-jie/">
        </link>
        <updated>2020-06-04T08:13:06.000Z</updated>
        <content type="html"><![CDATA[<p>1068 Find More Coins (30分)</p>
<p>Eva loves to collect coins from all over the universe, including some other planets like Mars. One day she visited a universal shopping mall which could accept all kinds of coins as payments. However, there was a special requirement of the payment: for each bill, she must pay the exact amount. Since she has as many as 104 coins with her, she definitely needs your help. You are supposed to tell her, for any given amount of money, whether or not she can find some coins to pay for it.</p>
<h3 id="input-specification">Input Specification:</h3>
<p>Each input file contains one test case. For each case, the first line contains 2 positive numbers: <code>N</code> (≤104, the total number of coins) and <code>M</code> (≤102, the amount of money Eva has to pay). The second line contains <code>N</code> face values of the coins, which are all positive numbers. All the numbers in a line are separated by a space.</p>
<h3 id="output-specification">Output Specification:</h3>
<p>For each test case, print in one line the face values <em>V</em>1≤<em>V</em>2≤⋯≤<em>V**k</em> such that <em>V</em>1+<em>V</em>2+⋯+<em>V**k</em>=<code>M</code>. All the numbers must be separated by a space, and there must be no extra space at the end of the line. If such a solution is not unique, output the smallest sequence. If there is no solution, output &quot;No Solution&quot; instead.</p>
<p>Note: sequence {A[1], A[2], ...} is said to be &quot;smaller&quot; than sequence {B[1], B[2], ...} if there exists <em>k</em>≥1 such that A[<em>i</em>]=B[<em>i</em>] for all <em>i</em>&lt;<em>k</em>, and A[<em>k</em>] &lt; B[<em>k</em>].</p>
<h3 id="sample-input-1">Sample Input 1:</h3>
<pre><code class="language-in">8 9
5 9 8 7 2 3 4 1
</code></pre>
<h3 id="sample-output-1">Sample Output 1:</h3>
<pre><code class="language-out">1 3 5
</code></pre>
<h3 id="sample-input-2">Sample Input 2:</h3>
<pre><code>4 8
7 2 4 3
</code></pre>
<h3 id="sample-output-2">Sample Output 2:</h3>
<pre><code>No Solution
</code></pre>
<hr>
<p>题目描述：商店有多种商品，给出多种商品的重量，而你的购物车有规定的称重量，不能超过规定的重量，现在要你求出在购物车刚好能够装满其重量时，能够装的最多件物品数。</p>
</br>
<p>输入：第一行n表示商品数，m表示购物车能够称的总重量。第二行为n个物品的重量。</p>
<p>输出：输出购物车总重量刚好等于m的商品的重量，递增输出。如果没有则输出No Solution。</p>
<p>因为题目要求递增输出，需要先给wet排个序。</p>
</br>
<p>解题思路：01背包问题。这道题中可以假设weight=value，dp可以用一维数组来维护。</p>
<p>01背包(思想)：有n种物品，每种物品只有一件，给出物品重量weight和价值value。</p>
<p>dp[ i ][ j ] 表示 在面对第 i 件物品，且背包容量为 j 时所能获得的最大价值</p>
<ol>
<li>
<p>j &lt; weight[ i ]，背包容纳不了第 i 件物品，dp[ i ][ j ] = dp[ i-1 ][ j ]</p>
</li>
<li>
<p>j &gt;= weight[ i ]，背包可容纳第 i 件物品，可选放或不放，如果放入则dp[ i ][ j ] = dp[ i-1 ][ j - weight[ i ] ] + value[ i ]，如果不放入则与1)相同</p>
</li>
</ol>
<p>转移方程：dp[ i ][ j ]=max{ dp [ i-1 ][ j ],dp[ i-1 ][ j-v[ i ]]+w[ i ]}</p>
<pre><code>for i=1~N:
	for j=N~0:
		dp[j] = max{dp[j],dp[j-v[i]]+w[i]}
</code></pre>
</br>
<p>补充：</p>
<p>完全背包：有n种物品，每种物品有无数件，给出物品重量weight和价值value。</p>
<p>转移方程：dp[ i ][ v ] = max{ f [ i-1 ][ v - k*v[ i ]]+k*w[ i ] |0&lt;=k*v[ i ]&lt;=j}</p>
<pre><code>for i=1~N:
	for j=0~N:
		dp[j] = max{dp[j],dp[j-v[i]]+w[i]}
</code></pre>
<p>提示：每种背包都是无限的。当我们把i从1到N循环时，dp[j]表示容量为j在前i种背包时所得的价值，这里我们要添加的不是前一个背包，而是当前背包。所以我们要考虑的是当前状态。</p>
</br>
<p>多重背包：有n种物品，每种物品给定了数量count，商品重量weight和价值value。</p>
<p>dp[ i ][ j ] = max{ dp[ i-1 ][ j-  k* v[ i ]]+k*w[ i ] |0&lt;=k&lt;=n[ i ]}</p>
<hr>
<pre><code class="language-c++">#include&lt;bits/stdc++.h&gt;
using namespace std;
const int maxn = 10086;
int wet[maxn];
int dp[maxn];
int vis[maxn][110];
int n, m;
bool cmp(int a, int b){
	return a &gt; b;
}
int main()
{
	scanf(&quot;%d %d&quot;, &amp;n, &amp;m);
	memset(dp,0,sizeof(dp));
	memset(vis,false,sizeof(vis));
	for(int i=1; i&lt;=n; i++) scanf(&quot;%d&quot;, &amp;wet[i]);
	sort(wet+1,wet+n+1,cmp);
	for(int i=1; i&lt;=n; i++){
		for(int j=m; j&gt;=wet[i]; j--){//确保一定可放入第i件物品 
			if(dp[j-wet[i]]+wet[i]&gt;=dp[j]){
				dp[j] = dp[j-wet[i]]+wet[i];
				vis[i][j] = true;
			}
		}
	}
	vector&lt;int&gt; ans;
	if(dp[m]!=m) printf(&quot;No Solution&quot;);
	else{
		int x = n, y = m;
		while(y&gt;0){
			if(vis[x][y]){
				ans.push_back(wet[x]);
				y -= wet[x];
			}
			x--;
		}
		for(int i=0; i&lt;ans.size(); i++){
			if(i) printf(&quot; &quot;);
			printf(&quot;%d&quot;, ans[i]);
		}
	}
	return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[1075 PAT Judge (25分)题解]]></title>
        <id>https://ygytl.github.io/post/1075-pat-judge-25-fen-ti-jie/</id>
        <link href="https://ygytl.github.io/post/1075-pat-judge-25-fen-ti-jie/">
        </link>
        <updated>2020-06-03T10:16:48.000Z</updated>
        <content type="html"><![CDATA[<p>1075 PAT Judge (25分)</p>
<p>The ranklist of PAT is generated from the status list, which shows the scores of the submissions. This time you are supposed to generate the ranklist for PAT.</p>
<h3 id="input-specification">Input Specification:</h3>
<p>Each input file contains one test case. For each case, the first line contains 3 positive integers, <em>N</em> (≤10<sup>4</sup>), the total number of users, <em>K</em> (≤5), the total number of problems, and <em>M</em> (≤10<sup>5</sup>), the total number of submissions. It is then assumed that the user id's are 5-digit numbers from 00001 to <em>N</em>, and the problem id's are from 1 to <em>K</em>. The next line contains <em>K</em> positive integers <code>p[i]</code> (<code>i</code>=1, ..., <em>K</em>), where <code>p[i]</code> corresponds to the full mark of the i-th problem. Then <em>M</em> lines follow, each gives the information of a submission in the following format:</p>
<pre><code>user_id problem_id partial_score_obtained
</code></pre>
<p>where <code>partial_score_obtained</code> is either −1 if the submission cannot even pass the compiler, or is an integer in the range [0, <code>p[problem_id]</code>]. All the numbers in a line are separated by a space.</p>
<h3 id="output-specification">Output Specification:</h3>
<p>For each test case, you are supposed to output the ranklist in the following format:</p>
<pre><code>rank user_id total_score s[1] ... s[K]
</code></pre>
<p>where <code>rank</code> is calculated according to the <code>total_score</code>, and all the users with the same <code>total_score</code> obtain the same <code>rank</code>; and <code>s[i]</code> is the partial score obtained for the <code>i</code>-th problem. If a user has never submitted a solution for a problem, then &quot;-&quot; must be printed at the corresponding position. If a user has submitted several solutions to solve one problem, then the highest score will be counted.</p>
<p>The ranklist must be printed in non-decreasing order of the ranks. For those who have the same rank, users must be sorted in nonincreasing order according to the number of perfectly solved problems. And if there is still a tie, then they must be printed in increasing order of their id's. For those who has never submitted any solution that can pass the compiler, or has never submitted any solution, they must NOT be shown on the ranklist. It is guaranteed that at least one user can be shown on the ranklist.</p>
<h3 id="sample-input">Sample Input:</h3>
<pre><code class="language-in">7 4 20
20 25 25 30
00002 2 12
00007 4 17
00005 1 19
00007 2 25
00005 1 20
00002 2 2
00005 1 15
00001 1 18
00004 3 25
00002 2 25
00005 3 22
00006 4 -1
00001 2 18
00002 1 20
00004 1 15
00002 4 18
00001 3 4
00001 4 2
00005 2 -1
00004 2 0
</code></pre>
<h3 id="sample-output">Sample Output:</h3>
<pre><code class="language-out">1 00002 63 20 25 - 18
2 00005 42 20 0 22 -
2 00007 42 - 25 - 17
2 00001 42 18 18 4 2
5 00004 40 15 0 25 -
</code></pre>
<hr>
<p>题目描述：PAT的成绩排序，排序规则（总分递增排序；总分相同，完美解答题目数多者优先；前两者都相同时，id递增排序）</p>
</br>
<p>输入：第一行三个参数。n为参赛人数，k为总题数，M为参赛者答题情况数。下列m行，每行三个参数，分别为参赛者id，题号，答题所得分数</p>
<p>输出：输出有分数的参赛者参赛的排名、id、总分、各题得分。</p>
</br>
<p>解题思路：emmmm后续再长篇大论解释，现在先写一些注意事项</p>
<p>注意：</p>
<p>测试点2：编译未通过者得分为-1，不计入得分，编译通过者，但是得分为0，成绩记为0。有一参赛者1，他所有题目都编译未通过，他得分岁为0，但不将他计入排名。有一参赛者2，他只编译通过了1道题，但这道题成绩为0，而且他的其他题都编译未通过，那他与参赛者1是不同的，他是可以计入排名的。</p>
<p>测试点4：有些人，某道题已经提交过并且为满分了，他又去提交了一次，那么，他这第二次提交的满分记录，不计入完美答题数中。</p>
<hr>
<pre><code class="language-c++">#include&lt;bits/stdc++.h&gt;
using namespace std;
int n, k, m;
const int maxn = 1e5+1;
int score[maxn];
struct node{
	int id;
	int b[6];//记录每道题的分数 
	int all_score;
	int TG;
	int perfit_count;//记录完美答题个数 
	node(){
		TG = all_score = 0;
		perfit_count = 0;
		memset(b,-1,sizeof(b));
	}
};
map&lt;int,node&gt; p;
map&lt;int,int&gt; vis;
vector&lt;node&gt; v;
bool cmp(node a, node b){
	if(a.all_score!=b.all_score) return a.all_score &gt; b.all_score;
	else if(a.perfit_count!=b.perfit_count) return a.perfit_count &gt; b.perfit_count;
	else return a.id &lt; b.id;
}
int main()
{
	int A, B, C;
	scanf(&quot;%d %d %d&quot;, &amp;n, &amp;k, &amp;m);
	for(int i=1; i&lt;=k; i++) scanf(&quot;%d&quot;, &amp;score[i]);
	for(int i=0; i&lt;m; i++){
		scanf(&quot;%d %d %d&quot;, &amp;A, &amp;B, &amp;C);
		if(vis[A]==0){//没有记录过，把他添加到map中 
			node t;
			if(C==-1) C=0;
			else t.TG = 1;
			t.id = A;
			t.all_score = C;
			t.b[B] = C;
			if(C==score[B]){//标记B题已经满分 
				t.perfit_count++;
			}
			vis[A] = 1;
			p[A] = t;
		}
		else{//该学生之前已经答过题了 
			node t;
			t = p[A];
			if(C==-1) C=0;
			else t.TG = 1;
			if(t.b[B]==-1){//第B道题没有回答过 
				t.b[B] = C;
				t.all_score += C;
				if(C==score[B]){//标记B题已经满分 
					t.perfit_count++;
				}
			}
			else if(C&gt;t.b[B]){
				t.all_score -= t.b[B];
				t.all_score += C;
				t.b[B] = C;
				if(C==score[B]){//标记B题已经满分 
					t.perfit_count++;
				}
			}
			p[A] = t;
		}
	}
	map&lt;int,node&gt;::iterator it;
	node t;
	for(it=p.begin(); it!=p.end(); it++){
		t = it-&gt;second;
		if(t.TG) v.push_back(t);
	}
	sort(v.begin(),v.end(),cmp);
	int rank = 1, tscore=0;
	for(int i=0; i&lt;v.size(); i++){
		t = v[i];
		if(i==0) tscore = t.all_score;
		if(t.all_score!=tscore){
			rank = i+1;
			tscore = t.all_score;
		}
		printf(&quot;%d %05d %d&quot;, rank, t.id, t.all_score);
		for(int j=1; j&lt;=k; j++){
			if(t.b[j]==-1) printf(&quot; -&quot;);
			else printf(&quot; %d&quot;, t.b[j]);
		}
		printf(&quot;\n&quot;);
	}
	return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[1070 Mooncake (25分)题解]]></title>
        <id>https://ygytl.github.io/post/1070-mooncake-25-fen-ti-jie/</id>
        <link href="https://ygytl.github.io/post/1070-mooncake-25-fen-ti-jie/">
        </link>
        <updated>2020-06-03T07:58:17.000Z</updated>
        <content type="html"><![CDATA[<p>1070 Mooncake (25分)</p>
<p>Mooncake is a Chinese bakery product traditionally eaten during the Mid-Autumn Festival. Many types of fillings and crusts can be found in traditional mooncakes according to the region's culture. Now given the inventory amounts and the prices of all kinds of the mooncakes, together with the maximum total demand of the market, you are supposed to tell the maximum profit that can be made.</p>
<p>Note: partial inventory storage can be taken. The sample shows the following situation: given three kinds of mooncakes with inventory amounts being 180, 150, and 100 thousand tons, and the prices being 7.5, 7.2, and 4.5 billion yuans. If the market demand can be at most 200 thousand tons, the best we can do is to sell 150 thousand tons of the second kind of mooncake, and 50 thousand tons of the third kind. Hence the total profit is 7.2 + 4.5/2 = 9.45 (billion yuans).</p>
<h3 id="input-specification">Input Specification:</h3>
<p>Each input file contains one test case. For each case, the first line contains 2 positive integers <em>N</em> (≤1000), the number of different kinds of mooncakes, and <em>D</em> (≤500 thousand tons), the maximum total demand of the market. Then the second line gives the positive inventory amounts (in thousand tons), and the third line gives the positive prices (in billion yuans) of <em>N</em> kinds of mooncakes. All the numbers in a line are separated by a space.</p>
<h3 id="output-specification">Output Specification:</h3>
<p>For each test case, print the maximum profit (in billion yuans) in one line, accurate up to 2 decimal places.</p>
<h3 id="sample-input">Sample Input:</h3>
<pre><code class="language-in">3 200
180 150 100
7.5 7.2 4.5
</code></pre>
<h3 id="sample-output">Sample Output:</h3>
<pre><code class="language-out">9.45
</code></pre>
<hr>
<p>题目描述：月饼吧啦吧啦吧啦，直接分析样例，假设库存的月饼种数为3，三种月饼库存分别有180、150、100(千吨)，他们对应的总价值分别是7.5、7.2、4.5百万元。若现在市场的月饼需求量是200(千吨)，求出商家可赚的最大利润是多少。</p>
</br>
<p>输入：第一行包括两个数，n--月饼种数，D--市场的月饼需求量。第二行有n个数，分别表示n种月饼的库存量。第三行有n个数，分别表示n种月饼各自的总价值。</p>
<p>输出：商家可赚的最大总利润。</p>
</br>
<p>解题思路：每种月饼的参数都存放到结构体中，还要求出每种月饼的单品价格。将结构体数组根据单价进行排序，单品价格高，那商家所得利润也比较高是不。排好序，根据市场需求量进行购买计算。很简单的就能得到商家获得的最高总利润啦。</p>
<p>注意点：测试点2，月饼的库存量要用浮点数来存啊！！！</p>
<hr>
<pre><code class="language-c++">#include&lt;bits/stdc++.h&gt;
using namespace std;
struct node{
	double amount, price, avg;
};
vector&lt;node&gt; v;
bool cmp(node a, node b){
	return a.avg &gt; b.avg; 
}
int main()
{
	int n;
	double ans=0, d;
	node t;
	scanf(&quot;%d %lf&quot;, &amp;n, &amp;d);
	v.resize(n);
	for(int i=0; i&lt;n; i++) scanf(&quot;%lf&quot;, &amp;v[i].amount);
	for(int i=0; i&lt;n; i++){
		scanf(&quot;%lf&quot;, &amp;v[i].price);
		v[i].avg = v[i].price/v[i].amount;
	}
	sort(v.begin(),v.end(),cmp);
	for(int i=0; i&lt;v.size()&amp;&amp;d&gt;0; i++){
		t = v[i];
		if(t.amount&lt;=d){
			d -= t.amount;
			ans += t.price;
		}
		else{
			ans += t.avg*d;
			d = 0;
		}
	}
	printf(&quot;%.2f\n&quot;, ans);
	return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[1074 Reversing Linked List (25分)题解]]></title>
        <id>https://ygytl.github.io/post/1074-reversing-linked-list-25-fen-ti-jie/</id>
        <link href="https://ygytl.github.io/post/1074-reversing-linked-list-25-fen-ti-jie/">
        </link>
        <updated>2020-06-03T06:59:10.000Z</updated>
        <content type="html"><![CDATA[<p>1074 Reversing Linked List (25分)</p>
<p>Given a constant <em>K</em> and a singly linked list <em>L</em>, you are supposed to reverse the links of every <em>K</em> elements on <em>L</em>. For example, given <em>L</em> being 1→2→3→4→5→6, if <em>K</em>=3, then you must output 3→2→1→6→5→4; if <em>K</em>=4, you must output 4→3→2→1→5→6.</p>
<h3 id="input-specification">Input Specification:</h3>
<p>Each input file contains one test case. For each case, the first line contains the address of the first node, a positive <em>N</em> (≤105) which is the total number of nodes, and a positive <em>K</em> (≤<em>N</em>) which is the length of the sublist to be reversed. The address of a node is a 5-digit nonnegative integer, and NULL is represented by -1.</p>
<p>Then <em>N</em> lines follow, each describes a node in the format:</p>
<pre><code>Address Data Next
</code></pre>
<p>where <code>Address</code> is the position of the node, <code>Data</code> is an integer, and <code>Next</code> is the position of the next node.</p>
<h3 id="output-specification">Output Specification:</h3>
<p>For each case, output the resulting ordered linked list. Each node occupies a line, and is printed in the same format as in the input.</p>
<h3 id="sample-input">Sample Input:</h3>
<pre><code class="language-in">00100 6 4
00000 4 99999
00100 1 12309
68237 6 -1
33218 3 00000
99999 5 68237
12309 2 33218
</code></pre>
<h3 id="sample-output">Sample Output:</h3>
<pre><code class="language-out">00000 4 33218
33218 3 12309
12309 2 00100
00100 1 99999
99999 5 68237
68237 6 -1
</code></pre>
<hr>
<p>题目描述：有一条链表L，假设链表为1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;6，现在要求你将链表分组为每k个数一组，每组的链表反转后串连在一起，最后输出。若k=3，则反转后的链表为3-&gt;2-&gt;1-&gt;6-&gt;5-&gt;4，若k=4，4-&gt;3-&gt;2-&gt;1-&gt;5-&gt;6，可以看到1、2、3、4这四个数可以分为1组，然后将其反序输出了，而5、6不足一组，则按顺序输出。</p>
</br>
<p>输入：第一行包括三个数，链表头节点Head，n表示链表节点数，k表示k个算组分为一组。接下来n行，包括每个结点的head结点、num、next结点</p>
<p>输出：将反转后链表的每个结点按顺序输出。</p>
</br>
<p>解题思路：题目输入的结点顺序不是正确，需要通过题目给定的head头节点先将链表串起来。在输入的时候，就可以将每个结点放入结构体数组中，使用每个结点的head作为索引，存放好后，可以通过给定的链表头节点Head，将链表串起来，放入l2结构体容器中。后面只需要将容器分组。为每组个数都小于等于k，然后进行反转，再存放到l3结构体容器中，最后输出。这就大功告成啦。</p>
<p>使用结构体数组来模拟链表，实现起来比较简单。</p>
<hr>
<pre><code class="language-c++">#include&lt;bits/stdc++.h&gt;
using namespace std;
struct node{
	int head, num, next;
};
const int maxn = 100005;
node l1[maxn];
vector&lt;node&gt; l2, l3;
int main()
{
	node t;
	int head, n, k;
	scanf(&quot;%d %d %d&quot;, &amp;head, &amp;n, &amp;k);
	for(int i=0; i&lt;n; i++){
		scanf(&quot;%d %d %d&quot;, &amp;t.head, &amp;t.num, &amp;t.next);
		l1[t.head] = t;
	}
	while(head!=-1){
		t = l1[head];
		l2.push_back(t);
		head = t.next;
	}
	for(int i=0, j; i&lt;l2.size(); i+=k){
		if(i+k&lt;=l2.size()){
			j = i+k-1;
			while(j&gt;=i){
				l3.push_back(l2[j]);
				j--;
			}
		}
		else{
			j = i;
			while(j&lt;l2.size()){
				l3.push_back(l2[j]);
				j++;
			}
			break;
		}
	}
	for(int i=0; i&lt;l3.size()-1; i++){
		printf(&quot;%05d %d %05d\n&quot;, l3[i].head, l3[i].num, l3[i+1].head);
	}
	printf(&quot;%05d %d -1\n&quot;, l3[l3.size()-1].head, l3[l3.size()-1].num);
	return 0;
}
</code></pre>
]]></content>
    </entry>
</feed>