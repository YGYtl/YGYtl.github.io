<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://ygytl.github.io/</id>
    <title>Grace</title>
    <updated>2020-06-06T03:48:58.093Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://ygytl.github.io/"/>
    <link rel="self" href="https://ygytl.github.io/atom.xml"/>
    <subtitle>Grace&apos;s blog</subtitle>
    <logo>https://ygytl.github.io/images/avatar.png</logo>
    <icon>https://ygytl.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, Grace</rights>
    <entry>
        <title type="html"><![CDATA[1079 Total Sales of Supply Chain (25分)题解]]></title>
        <id>https://ygytl.github.io/post/1079-total-sales-of-supply-chain-25-fen-ti-jie/</id>
        <link href="https://ygytl.github.io/post/1079-total-sales-of-supply-chain-25-fen-ti-jie/">
        </link>
        <updated>2020-06-06T03:48:31.000Z</updated>
        <content type="html"><![CDATA[<p>1079 Total Sales of Supply Chain (25分)</p>
<p>A supply chain is a network of retailers（零售商）, distributors（经销商）, and suppliers（供应商）-- everyone involved in moving a product from supplier to customer.</p>
<p>Starting from one root supplier, everyone on the chain buys products from one's supplier in a price <em>P</em> and sell or distribute them in a price that is <em>r</em>% higher than <em>P</em>. Only the retailers will face the customers. It is assumed that each member in the supply chain has exactly one supplier except the root supplier, and there is no supply cycle.</p>
<p>Now given a supply chain, you are supposed to tell the total sales from all the retailers.</p>
<h3 id="input-specification">Input Specification:</h3>
<p>Each input file contains one test case. For each case, the first line contains three positive numbers: <em>N</em> (≤105), the total number of the members in the supply chain (and hence their ID's are numbered from 0 to <em>N</em>−1, and the root supplier's ID is 0); <em>P</em>, the unit price given by the root supplier; and <em>r</em>, the percentage rate of price increment for each distributor or retailer. Then <em>N</em> lines follow, each describes a distributor or retailer in the following format:</p>
<p><em>K**i</em> ID[1] ID[2] ... ID[<em>K**i</em>]</p>
<p>where in the <em>i</em>-th line, <em>K**i</em> is the total number of distributors or retailers who receive products from supplier <em>i</em>, and is then followed by the ID's of these distributors or retailers. <em>K**j</em> being 0 means that the <em>j</em>-th member is a retailer, then instead the total amount of the product will be given after <em>K**j</em>. All the numbers in a line are separated by a space.</p>
<h3 id="output-specification">Output Specification:</h3>
<p>For each test case, print in one line the total sales we can expect from all the retailers, accurate up to 1 decimal place. It is guaranteed that the number will not exceed 1010.</p>
<h3 id="sample-input">Sample Input:</h3>
<pre><code class="language-in">10 1.80 1.00
3 2 3 5
1 9
1 4
1 7
0 7
2 6 1
1 8
0 9
0 4
0 3
</code></pre>
<h3 id="sample-output">Sample Output:</h3>
<pre><code class="language-out">42.4
</code></pre>
<hr>
<p>题目描述：有一条销售链，供应商、经销商、零售商，供应商提供货物给经销商，经销商提供货物给零售商，题目要求出零售商售出的总额是多少。0号索引表示供应商。供应商的售价p，经销商的售价p1 = r%*p，零售商售价p2 = r%*p1。</p>
</br>
<p>输入：第一行三个数，n为节点数，p为商品原价，即供应商的出价，r为售价的增幅。接下来n行（表示0~n-1个结点的情况），分两种情况</p>
<p>1)第一个值为0，第二个值就表示零售商需要销售商品的数量</p>
<p>2)第一个值不为0，则第一个值表示第i个结点的子结点个数m，后面接着m个子结点的编号。</p>
<p>输出：零售商售出的总额，保留一位小数</p>
</br>
<p>解题思路：典型的bfs题，使用邻接表存树，节约空间。</p>
<p>注意，题目给的是r，我们计算时要计算r%，所以r*1.0/100。</p>
<hr>
<pre><code class="language-c++">#include&lt;bits/stdc++.h&gt;
using namespace std;
int n;
double p, r;
const int maxn = 200005;
vector&lt;int&gt; G[maxn];
map&lt;int,int&gt; lvs_sell;
struct node{
	int index;
	double price;
};
void bfs(){
	node t, tt;
	t.index = 0; t.price = p;
	queue&lt;node&gt; q;
	q.push(t);
	double ans = 0;
	while(!q.empty()){
		t = q.front();
		q.pop();
		if(G[t.index].size()==0){
			ans += lvs_sell[t.index]*t.price;
		}
		else{
			for(int i=0; i&lt;G[t.index].size(); i++){
				int v = G[t.index][i];
				tt.index = v;
				tt.price = r*t.price;
				q.push(tt);
			}
		}
	}
	printf(&quot;%.1f&quot;, ans);
}
int main()
{
	scanf(&quot;%d %lf %lf&quot;, &amp;n, &amp;p, &amp;r);
	r = r*1.0/100 + 1;
	int a, b;
	for(int i=0; i&lt;n; i++){
		scanf(&quot;%d %d&quot;, &amp;a, &amp;b);
		if(a==0) lvs_sell[i] = b;
		else{
			G[i].push_back(b);
			for(int j=1; j&lt;a; j++){
				scanf(&quot;%d&quot;, &amp;b);
				G[i].push_back(b);
			}
		}
	}
	bfs();
	return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[1078 Hashing (25分)题解]]></title>
        <id>https://ygytl.github.io/post/1078-hashing-25-fen-ti-jie/</id>
        <link href="https://ygytl.github.io/post/1078-hashing-25-fen-ti-jie/">
        </link>
        <updated>2020-06-06T02:29:52.000Z</updated>
        <content type="html"><![CDATA[<p>1078 Hashing (25分)</p>
<p>The task of this problem is simple: insert a sequence of distinct positive integers into a hash table, and output the positions of the input numbers. The hash function is defined to be <em>H</em>(<em>k<strong>e</strong>y</em>)=<em>k<strong>e</strong>y</em>%<em>T<strong>S</strong>i<strong>z</strong>e</em> where <em>T<strong>S</strong>i<strong>z</strong>e</em> is the maximum size of the hash table. Quadratic probing (with positive increments only) is used to solve the collisions.</p>
<p>Note that the table size is better to be prime. If the maximum size given by the user is not prime, you must re-define the table size to be the smallest prime number which is larger than the size given by the user.</p>
<h3 id="input-specification">Input Specification:</h3>
<p>Each input file contains one test case. For each case, the first line contains two positive numbers: <em>M<strong>S</strong>i<strong>z</strong>e</em> (≤104) and <em>N</em> (≤<em>M<strong>S</strong>i<strong>z</strong>e</em>) which are the user-defined table size and the number of input numbers, respectively. Then <em>N</em> distinct positive integers are given in the next line. All the numbers in a line are separated by a space.</p>
<h3 id="output-specification">Output Specification:</h3>
<p>For each test case, print the corresponding positions (index starts from 0) of the input numbers in one line. All the numbers in a line are separated by a space, and there must be no extra space at the end of the line. In case it is impossible to insert the number, print &quot;-&quot; instead.</p>
<h3 id="sample-input">Sample Input:</h3>
<pre><code class="language-in">4 4
10 6 4 15
</code></pre>
<h3 id="sample-output">Sample Output:</h3>
<pre><code class="language-out">0 1 4 -
</code></pre>
<hr>
<p>题目描述：把哈希表实现出来。</p>
</br>
<p>输入：Msize数组长度，n插入值得个数</p>
<p>输出：插入每个值得位置</p>
</br>
<p>解题思路：Quadratic probing (with positive increments only) is used to solve the collisions.</p>
<p>这句话是重点，必须理解，Quadratic二次方，probe探测，collision冲突；遇到冲突使用二次探测存放！</p>
<p>二次探测公式：H(Key) = (Key + i*i)  (i=0....n-1)</p>
<p>解这道题，因为哈希表得的长度规定选为素数，所以，当Msize不为素数，需要将大于Msize的最小素数求出，可以用一个数组先将素数表存好，方便查询。然后把二次探测公式实现就行了。</p>
<hr>
<pre><code class="language-c++">#include&lt;bits/stdc++.h&gt;
using namespace std;
const int maxn = 20005;
vector&lt;int&gt; prime;
int p[maxn];
bool is_prime(int k){
	if(k==0||k==1) return false;
	for(int i=2; i&lt;=sqrt(k); i++){
		if(k%i==0) return false;
	}
	return true;
}
int find_prime(int k){
	for(int i=0; i&lt;prime.size(); i++){
		if(prime[i]&gt;k) return prime[i];
	}
	return 0;
}
int main()
{
	memset(p,-1,sizeof(p));
	prime.push_back(2);
	for(int i=3; i&lt;=maxn; i+=2){
		if(is_prime(i)) prime.push_back(i);
	}
	int n, m;
	long long k;
	scanf(&quot;%d %d&quot;, &amp;n, &amp;m);
	if(!is_prime(n)) n = find_prime(n);
	
	for(int i=0; i&lt;m; i++){
		scanf(&quot;%lld&quot;, &amp;k);
		if(i) printf(&quot; &quot;);
		int g = k%n, c=0;
		while(p[g]!=-1&amp;&amp;c&lt;n){
			c++;
			g = (k+c*c)%n;
		}
		if(p[g]!=-1) printf(&quot;-&quot;);
		else{
			p[g%n] = g%n;
			printf(&quot;%d&quot;, g%n);
		}
	}
	return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[1077 Kuchiguse (20分)题解]]></title>
        <id>https://ygytl.github.io/post/1077-kuchiguse-20-fen-ti-jie/</id>
        <link href="https://ygytl.github.io/post/1077-kuchiguse-20-fen-ti-jie/">
        </link>
        <updated>2020-06-05T14:43:46.000Z</updated>
        <content type="html"><![CDATA[<p>1077 Kuchiguse (20分)</p>
<p>The Japanese language is notorious for its sentence ending particles. Personal preference of such particles can be considered as a reflection of the speaker's personality. Such a preference is called &quot;Kuchiguse&quot; and is often exaggerated artistically in Anime and Manga. For example, the artificial sentence ending particle &quot;nyan~&quot; is often used as a stereotype for characters with a cat-like personality:</p>
<ul>
<li>Itai nyan~ (It hurts, nyan~)</li>
<li>Ninjin wa iyada nyan~ (I hate carrots, nyan~)</li>
</ul>
<p>Now given a few lines spoken by the same character, can you find her Kuchiguse?</p>
<h3 id="input-specification">Input Specification:</h3>
<p>Each input file contains one test case. For each case, the first line is an integer <em>N</em> (2≤<em>N</em>≤100). Following are <em>N</em> file lines of 0~256 (inclusive) characters in length, each representing a character's spoken line. The spoken lines are case sensitive.</p>
<h3 id="output-specification">Output Specification:</h3>
<p>For each test case, print in one line the kuchiguse of the character, i.e., the longest common suffix of all <em>N</em> lines. If there is no such suffix, write <code>nai</code>.</p>
<h3 id="sample-input-1">Sample Input 1:</h3>
<pre><code class="language-in">3
Itai nyan~
Ninjin wa iyadanyan~
uhhh nyan~
</code></pre>
<h3 id="sample-output-1">Sample Output 1:</h3>
<pre><code class="language-out">nyan~
</code></pre>
<h3 id="sample-input-2">Sample Input 2:</h3>
<pre><code class="language-in">3
Itai!
Ninjinnwaiyada T_T
T_T
</code></pre>
<h3 id="sample-output-2">Sample Output 2:</h3>
<pre><code class="language-out">nai
</code></pre>
<hr>
<p>题目描述：找到一个人平时说话最常用的结尾语。</p>
</br>
<p>输入：第一行n，接下来n行字符串。</p>
<p>输出：每行共同的后缀字符串。若没有公共字符串后缀，则输出nai。</p>
</br>
<p>解题思路：先读入n，然后保存第一串字符串，与之后的n-1串字符串相比较，找到每行中相同的后缀。怎么找呢？比较两个字符串长度，取字符串长度较小的进行for循环，保证字符数组不会越界，两个字符串同时从末尾开始比较。这样就可以得到他们的公共后缀长度啦，当有一组公共后缀长度为0，用flag标记一下，最后输出结果就行。</p>
<hr>
<pre><code class="language-c++">#include&lt;bits/stdc++.h&gt;
using namespace std;
int main()
{
	int n, l, l1, l2, common;
	bool flag = true;
	scanf(&quot;%d&quot;, &amp;n);
	getchar();
	string s, tmp;
	for(int i=0; i&lt;n; i++){
		getline(cin,tmp);
		if(i==0){
			s = tmp;
			l1 = s.length();
			common = l1;
			continue;
		}
		l2 = tmp.length();
		l = min(l1,l2);
		int count = 0;
		for(int j=1; j&lt;=l; j++){
			if(tmp[l2-j]==s[l1-j]){
				count++;
			}
			else break;
		}
		if(count==0){
			flag = false;
		}
		common = min(common,count);
	}
	if(flag){
		string ans = s.substr(l1-common);
		cout &lt;&lt; ans &lt;&lt; endl;
	}
	else printf(&quot;nai\n&quot;);
	return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[1068 Find More Coins (30分)题解]]></title>
        <id>https://ygytl.github.io/post/1068-find-more-coins-30-fen-ti-jie/</id>
        <link href="https://ygytl.github.io/post/1068-find-more-coins-30-fen-ti-jie/">
        </link>
        <updated>2020-06-04T08:13:06.000Z</updated>
        <content type="html"><![CDATA[<p>1068 Find More Coins (30分)</p>
<p>Eva loves to collect coins from all over the universe, including some other planets like Mars. One day she visited a universal shopping mall which could accept all kinds of coins as payments. However, there was a special requirement of the payment: for each bill, she must pay the exact amount. Since she has as many as 104 coins with her, she definitely needs your help. You are supposed to tell her, for any given amount of money, whether or not she can find some coins to pay for it.</p>
<h3 id="input-specification">Input Specification:</h3>
<p>Each input file contains one test case. For each case, the first line contains 2 positive numbers: <code>N</code> (≤104, the total number of coins) and <code>M</code> (≤102, the amount of money Eva has to pay). The second line contains <code>N</code> face values of the coins, which are all positive numbers. All the numbers in a line are separated by a space.</p>
<h3 id="output-specification">Output Specification:</h3>
<p>For each test case, print in one line the face values <em>V</em>1≤<em>V</em>2≤⋯≤<em>V**k</em> such that <em>V</em>1+<em>V</em>2+⋯+<em>V**k</em>=<code>M</code>. All the numbers must be separated by a space, and there must be no extra space at the end of the line. If such a solution is not unique, output the smallest sequence. If there is no solution, output &quot;No Solution&quot; instead.</p>
<p>Note: sequence {A[1], A[2], ...} is said to be &quot;smaller&quot; than sequence {B[1], B[2], ...} if there exists <em>k</em>≥1 such that A[<em>i</em>]=B[<em>i</em>] for all <em>i</em>&lt;<em>k</em>, and A[<em>k</em>] &lt; B[<em>k</em>].</p>
<h3 id="sample-input-1">Sample Input 1:</h3>
<pre><code class="language-in">8 9
5 9 8 7 2 3 4 1
</code></pre>
<h3 id="sample-output-1">Sample Output 1:</h3>
<pre><code class="language-out">1 3 5
</code></pre>
<h3 id="sample-input-2">Sample Input 2:</h3>
<pre><code>4 8
7 2 4 3
</code></pre>
<h3 id="sample-output-2">Sample Output 2:</h3>
<pre><code>No Solution
</code></pre>
<hr>
<p>题目描述：商店有多种商品，给出多种商品的重量，而你的购物车有规定的称重量，不能超过规定的重量，现在要你求出在购物车刚好能够装满其重量时，能够装的最多件物品数。</p>
</br>
<p>输入：第一行n表示商品数，m表示购物车能够称的总重量。第二行为n个物品的重量。</p>
<p>输出：输出购物车总重量刚好等于m的商品的重量，递增输出。如果没有则输出No Solution。</p>
<p>因为题目要求递增输出，需要先给wet排个序。</p>
</br>
<p>解题思路：01背包问题。这道题中可以假设weight=value，dp可以用一维数组来维护。</p>
<p>01背包(思想)：有n种物品，每种物品只有一件，给出物品重量weight和价值value。</p>
<p>dp[ i ][ j ] 表示 在面对第 i 件物品，且背包容量为 j 时所能获得的最大价值</p>
<ol>
<li>
<p>j &lt; weight[ i ]，背包容纳不了第 i 件物品，dp[ i ][ j ] = dp[ i-1 ][ j ]</p>
</li>
<li>
<p>j &gt;= weight[ i ]，背包可容纳第 i 件物品，可选放或不放，如果放入则dp[ i ][ j ] = dp[ i-1 ][ j - weight[ i ] ] + value[ i ]，如果不放入则与1)相同</p>
</li>
</ol>
<p>转移方程：dp[ i ][ j ]=max{ dp [ i-1 ][ j ],dp[ i-1 ][ j-v[ i ]]+w[ i ]}</p>
<pre><code>for i=1~N:
	for j=N~0:
		dp[j] = max{dp[j],dp[j-v[i]]+w[i]}
</code></pre>
</br>
<p>补充：</p>
<p>完全背包：有n种物品，每种物品有无数件，给出物品重量weight和价值value。</p>
<p>转移方程：dp[ i ][ v ] = max{ f [ i-1 ][ v - k*v[ i ]]+k*w[ i ] |0&lt;=k*v[ i ]&lt;=j}</p>
<pre><code>for i=1~N:
	for j=0~N:
		dp[j] = max{dp[j],dp[j-v[i]]+w[i]}
</code></pre>
<p>提示：每种背包都是无限的。当我们把i从1到N循环时，dp[j]表示容量为j在前i种背包时所得的价值，这里我们要添加的不是前一个背包，而是当前背包。所以我们要考虑的是当前状态。</p>
</br>
<p>多重背包：有n种物品，每种物品给定了数量count，商品重量weight和价值value。</p>
<p>dp[ i ][ j ] = max{ dp[ i-1 ][ j-  k* v[ i ]]+k*w[ i ] |0&lt;=k&lt;=n[ i ]}</p>
<hr>
<pre><code class="language-c++">#include&lt;bits/stdc++.h&gt;
using namespace std;
const int maxn = 10086;
int wet[maxn];
int dp[maxn];
int vis[maxn][110];
int n, m;
bool cmp(int a, int b){
	return a &gt; b;
}
int main()
{
	scanf(&quot;%d %d&quot;, &amp;n, &amp;m);
	memset(dp,0,sizeof(dp));
	memset(vis,false,sizeof(vis));
	for(int i=1; i&lt;=n; i++) scanf(&quot;%d&quot;, &amp;wet[i]);
	sort(wet+1,wet+n+1,cmp);
	for(int i=1; i&lt;=n; i++){
		for(int j=m; j&gt;=wet[i]; j--){//确保一定可放入第i件物品 
			if(dp[j-wet[i]]+wet[i]&gt;=dp[j]){
				dp[j] = dp[j-wet[i]]+wet[i];
				vis[i][j] = true;
			}
		}
	}
	vector&lt;int&gt; ans;
	if(dp[m]!=m) printf(&quot;No Solution&quot;);
	else{
		int x = n, y = m;
		while(y&gt;0){
			if(vis[x][y]){
				ans.push_back(wet[x]);
				y -= wet[x];
			}
			x--;
		}
		for(int i=0; i&lt;ans.size(); i++){
			if(i) printf(&quot; &quot;);
			printf(&quot;%d&quot;, ans[i]);
		}
	}
	return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[1075 PAT Judge (25分)题解]]></title>
        <id>https://ygytl.github.io/post/1075-pat-judge-25-fen-ti-jie/</id>
        <link href="https://ygytl.github.io/post/1075-pat-judge-25-fen-ti-jie/">
        </link>
        <updated>2020-06-03T10:16:48.000Z</updated>
        <content type="html"><![CDATA[<p>1075 PAT Judge (25分)</p>
<p>The ranklist of PAT is generated from the status list, which shows the scores of the submissions. This time you are supposed to generate the ranklist for PAT.</p>
<h3 id="input-specification">Input Specification:</h3>
<p>Each input file contains one test case. For each case, the first line contains 3 positive integers, <em>N</em> (≤10<sup>4</sup>), the total number of users, <em>K</em> (≤5), the total number of problems, and <em>M</em> (≤10<sup>5</sup>), the total number of submissions. It is then assumed that the user id's are 5-digit numbers from 00001 to <em>N</em>, and the problem id's are from 1 to <em>K</em>. The next line contains <em>K</em> positive integers <code>p[i]</code> (<code>i</code>=1, ..., <em>K</em>), where <code>p[i]</code> corresponds to the full mark of the i-th problem. Then <em>M</em> lines follow, each gives the information of a submission in the following format:</p>
<pre><code>user_id problem_id partial_score_obtained
</code></pre>
<p>where <code>partial_score_obtained</code> is either −1 if the submission cannot even pass the compiler, or is an integer in the range [0, <code>p[problem_id]</code>]. All the numbers in a line are separated by a space.</p>
<h3 id="output-specification">Output Specification:</h3>
<p>For each test case, you are supposed to output the ranklist in the following format:</p>
<pre><code>rank user_id total_score s[1] ... s[K]
</code></pre>
<p>where <code>rank</code> is calculated according to the <code>total_score</code>, and all the users with the same <code>total_score</code> obtain the same <code>rank</code>; and <code>s[i]</code> is the partial score obtained for the <code>i</code>-th problem. If a user has never submitted a solution for a problem, then &quot;-&quot; must be printed at the corresponding position. If a user has submitted several solutions to solve one problem, then the highest score will be counted.</p>
<p>The ranklist must be printed in non-decreasing order of the ranks. For those who have the same rank, users must be sorted in nonincreasing order according to the number of perfectly solved problems. And if there is still a tie, then they must be printed in increasing order of their id's. For those who has never submitted any solution that can pass the compiler, or has never submitted any solution, they must NOT be shown on the ranklist. It is guaranteed that at least one user can be shown on the ranklist.</p>
<h3 id="sample-input">Sample Input:</h3>
<pre><code class="language-in">7 4 20
20 25 25 30
00002 2 12
00007 4 17
00005 1 19
00007 2 25
00005 1 20
00002 2 2
00005 1 15
00001 1 18
00004 3 25
00002 2 25
00005 3 22
00006 4 -1
00001 2 18
00002 1 20
00004 1 15
00002 4 18
00001 3 4
00001 4 2
00005 2 -1
00004 2 0
</code></pre>
<h3 id="sample-output">Sample Output:</h3>
<pre><code class="language-out">1 00002 63 20 25 - 18
2 00005 42 20 0 22 -
2 00007 42 - 25 - 17
2 00001 42 18 18 4 2
5 00004 40 15 0 25 -
</code></pre>
<hr>
<p>题目描述：PAT的成绩排序，排序规则（总分递增排序；总分相同，完美解答题目数多者优先；前两者都相同时，id递增排序）</p>
</br>
<p>输入：第一行三个参数。n为参赛人数，k为总题数，M为参赛者答题情况数。下列m行，每行三个参数，分别为参赛者id，题号，答题所得分数</p>
<p>输出：输出有分数的参赛者参赛的排名、id、总分、各题得分。</p>
</br>
<p>解题思路：emmmm后续再长篇大论解释，现在先写一些注意事项</p>
<p>注意：</p>
<p>测试点2：编译未通过者得分为-1，不计入得分，编译通过者，但是得分为0，成绩记为0。有一参赛者1，他所有题目都编译未通过，他得分岁为0，但不将他计入排名。有一参赛者2，他只编译通过了1道题，但这道题成绩为0，而且他的其他题都编译未通过，那他与参赛者1是不同的，他是可以计入排名的。</p>
<p>测试点4：有些人，某道题已经提交过并且为满分了，他又去提交了一次，那么，他这第二次提交的满分记录，不计入完美答题数中。</p>
<hr>
<pre><code class="language-c++">#include&lt;bits/stdc++.h&gt;
using namespace std;
int n, k, m;
const int maxn = 1e5+1;
int score[maxn];
struct node{
	int id;
	int b[6];//记录每道题的分数 
	int all_score;
	int TG;
	int perfit_count;//记录完美答题个数 
	node(){
		TG = all_score = 0;
		perfit_count = 0;
		memset(b,-1,sizeof(b));
	}
};
map&lt;int,node&gt; p;
map&lt;int,int&gt; vis;
vector&lt;node&gt; v;
bool cmp(node a, node b){
	if(a.all_score!=b.all_score) return a.all_score &gt; b.all_score;
	else if(a.perfit_count!=b.perfit_count) return a.perfit_count &gt; b.perfit_count;
	else return a.id &lt; b.id;
}
int main()
{
	int A, B, C;
	scanf(&quot;%d %d %d&quot;, &amp;n, &amp;k, &amp;m);
	for(int i=1; i&lt;=k; i++) scanf(&quot;%d&quot;, &amp;score[i]);
	for(int i=0; i&lt;m; i++){
		scanf(&quot;%d %d %d&quot;, &amp;A, &amp;B, &amp;C);
		if(vis[A]==0){//没有记录过，把他添加到map中 
			node t;
			if(C==-1) C=0;
			else t.TG = 1;
			t.id = A;
			t.all_score = C;
			t.b[B] = C;
			if(C==score[B]){//标记B题已经满分 
				t.perfit_count++;
			}
			vis[A] = 1;
			p[A] = t;
		}
		else{//该学生之前已经答过题了 
			node t;
			t = p[A];
			if(C==-1) C=0;
			else t.TG = 1;
			if(t.b[B]==-1){//第B道题没有回答过 
				t.b[B] = C;
				t.all_score += C;
				if(C==score[B]){//标记B题已经满分 
					t.perfit_count++;
				}
			}
			else if(C&gt;t.b[B]){
				t.all_score -= t.b[B];
				t.all_score += C;
				t.b[B] = C;
				if(C==score[B]){//标记B题已经满分 
					t.perfit_count++;
				}
			}
			p[A] = t;
		}
	}
	map&lt;int,node&gt;::iterator it;
	node t;
	for(it=p.begin(); it!=p.end(); it++){
		t = it-&gt;second;
		if(t.TG) v.push_back(t);
	}
	sort(v.begin(),v.end(),cmp);
	int rank = 1, tscore=0;
	for(int i=0; i&lt;v.size(); i++){
		t = v[i];
		if(i==0) tscore = t.all_score;
		if(t.all_score!=tscore){
			rank = i+1;
			tscore = t.all_score;
		}
		printf(&quot;%d %05d %d&quot;, rank, t.id, t.all_score);
		for(int j=1; j&lt;=k; j++){
			if(t.b[j]==-1) printf(&quot; -&quot;);
			else printf(&quot; %d&quot;, t.b[j]);
		}
		printf(&quot;\n&quot;);
	}
	return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[1070 Mooncake (25分)题解]]></title>
        <id>https://ygytl.github.io/post/1070-mooncake-25-fen-ti-jie/</id>
        <link href="https://ygytl.github.io/post/1070-mooncake-25-fen-ti-jie/">
        </link>
        <updated>2020-06-03T07:58:17.000Z</updated>
        <content type="html"><![CDATA[<p>1070 Mooncake (25分)</p>
<p>Mooncake is a Chinese bakery product traditionally eaten during the Mid-Autumn Festival. Many types of fillings and crusts can be found in traditional mooncakes according to the region's culture. Now given the inventory amounts and the prices of all kinds of the mooncakes, together with the maximum total demand of the market, you are supposed to tell the maximum profit that can be made.</p>
<p>Note: partial inventory storage can be taken. The sample shows the following situation: given three kinds of mooncakes with inventory amounts being 180, 150, and 100 thousand tons, and the prices being 7.5, 7.2, and 4.5 billion yuans. If the market demand can be at most 200 thousand tons, the best we can do is to sell 150 thousand tons of the second kind of mooncake, and 50 thousand tons of the third kind. Hence the total profit is 7.2 + 4.5/2 = 9.45 (billion yuans).</p>
<h3 id="input-specification">Input Specification:</h3>
<p>Each input file contains one test case. For each case, the first line contains 2 positive integers <em>N</em> (≤1000), the number of different kinds of mooncakes, and <em>D</em> (≤500 thousand tons), the maximum total demand of the market. Then the second line gives the positive inventory amounts (in thousand tons), and the third line gives the positive prices (in billion yuans) of <em>N</em> kinds of mooncakes. All the numbers in a line are separated by a space.</p>
<h3 id="output-specification">Output Specification:</h3>
<p>For each test case, print the maximum profit (in billion yuans) in one line, accurate up to 2 decimal places.</p>
<h3 id="sample-input">Sample Input:</h3>
<pre><code class="language-in">3 200
180 150 100
7.5 7.2 4.5
</code></pre>
<h3 id="sample-output">Sample Output:</h3>
<pre><code class="language-out">9.45
</code></pre>
<hr>
<p>题目描述：月饼吧啦吧啦吧啦，直接分析样例，假设库存的月饼种数为3，三种月饼库存分别有180、150、100(千吨)，他们对应的总价值分别是7.5、7.2、4.5百万元。若现在市场的月饼需求量是200(千吨)，求出商家可赚的最大利润是多少。</p>
</br>
<p>输入：第一行包括两个数，n--月饼种数，D--市场的月饼需求量。第二行有n个数，分别表示n种月饼的库存量。第三行有n个数，分别表示n种月饼各自的总价值。</p>
<p>输出：商家可赚的最大总利润。</p>
</br>
<p>解题思路：每种月饼的参数都存放到结构体中，还要求出每种月饼的单品价格。将结构体数组根据单价进行排序，单品价格高，那商家所得利润也比较高是不。排好序，根据市场需求量进行购买计算。很简单的就能得到商家获得的最高总利润啦。</p>
<p>注意点：测试点2，月饼的库存量要用浮点数来存啊！！！</p>
<hr>
<pre><code class="language-c++">#include&lt;bits/stdc++.h&gt;
using namespace std;
struct node{
	double amount, price, avg;
};
vector&lt;node&gt; v;
bool cmp(node a, node b){
	return a.avg &gt; b.avg; 
}
int main()
{
	int n;
	double ans=0, d;
	node t;
	scanf(&quot;%d %lf&quot;, &amp;n, &amp;d);
	v.resize(n);
	for(int i=0; i&lt;n; i++) scanf(&quot;%lf&quot;, &amp;v[i].amount);
	for(int i=0; i&lt;n; i++){
		scanf(&quot;%lf&quot;, &amp;v[i].price);
		v[i].avg = v[i].price/v[i].amount;
	}
	sort(v.begin(),v.end(),cmp);
	for(int i=0; i&lt;v.size()&amp;&amp;d&gt;0; i++){
		t = v[i];
		if(t.amount&lt;=d){
			d -= t.amount;
			ans += t.price;
		}
		else{
			ans += t.avg*d;
			d = 0;
		}
	}
	printf(&quot;%.2f\n&quot;, ans);
	return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[1074 Reversing Linked List (25分)题解]]></title>
        <id>https://ygytl.github.io/post/1074-reversing-linked-list-25-fen-ti-jie/</id>
        <link href="https://ygytl.github.io/post/1074-reversing-linked-list-25-fen-ti-jie/">
        </link>
        <updated>2020-06-03T06:59:10.000Z</updated>
        <content type="html"><![CDATA[<p>1074 Reversing Linked List (25分)</p>
<p>Given a constant <em>K</em> and a singly linked list <em>L</em>, you are supposed to reverse the links of every <em>K</em> elements on <em>L</em>. For example, given <em>L</em> being 1→2→3→4→5→6, if <em>K</em>=3, then you must output 3→2→1→6→5→4; if <em>K</em>=4, you must output 4→3→2→1→5→6.</p>
<h3 id="input-specification">Input Specification:</h3>
<p>Each input file contains one test case. For each case, the first line contains the address of the first node, a positive <em>N</em> (≤105) which is the total number of nodes, and a positive <em>K</em> (≤<em>N</em>) which is the length of the sublist to be reversed. The address of a node is a 5-digit nonnegative integer, and NULL is represented by -1.</p>
<p>Then <em>N</em> lines follow, each describes a node in the format:</p>
<pre><code>Address Data Next
</code></pre>
<p>where <code>Address</code> is the position of the node, <code>Data</code> is an integer, and <code>Next</code> is the position of the next node.</p>
<h3 id="output-specification">Output Specification:</h3>
<p>For each case, output the resulting ordered linked list. Each node occupies a line, and is printed in the same format as in the input.</p>
<h3 id="sample-input">Sample Input:</h3>
<pre><code class="language-in">00100 6 4
00000 4 99999
00100 1 12309
68237 6 -1
33218 3 00000
99999 5 68237
12309 2 33218
</code></pre>
<h3 id="sample-output">Sample Output:</h3>
<pre><code class="language-out">00000 4 33218
33218 3 12309
12309 2 00100
00100 1 99999
99999 5 68237
68237 6 -1
</code></pre>
<hr>
<p>题目描述：有一条链表L，假设链表为1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;6，现在要求你将链表分组为每k个数一组，每组的链表反转后串连在一起，最后输出。若k=3，则反转后的链表为3-&gt;2-&gt;1-&gt;6-&gt;5-&gt;4，若k=4，4-&gt;3-&gt;2-&gt;1-&gt;5-&gt;6，可以看到1、2、3、4这四个数可以分为1组，然后将其反序输出了，而5、6不足一组，则按顺序输出。</p>
</br>
<p>输入：第一行包括三个数，链表头节点Head，n表示链表节点数，k表示k个算组分为一组。接下来n行，包括每个结点的head结点、num、next结点</p>
<p>输出：将反转后链表的每个结点按顺序输出。</p>
</br>
<p>解题思路：题目输入的结点顺序不是正确，需要通过题目给定的head头节点先将链表串起来。在输入的时候，就可以将每个结点放入结构体数组中，使用每个结点的head作为索引，存放好后，可以通过给定的链表头节点Head，将链表串起来，放入l2结构体容器中。后面只需要将容器分组。为每组个数都小于等于k，然后进行反转，再存放到l3结构体容器中，最后输出。这就大功告成啦。</p>
<p>使用结构体数组来模拟链表，实现起来比较简单。</p>
<hr>
<pre><code class="language-c++">#include&lt;bits/stdc++.h&gt;
using namespace std;
struct node{
	int head, num, next;
};
const int maxn = 100005;
node l1[maxn];
vector&lt;node&gt; l2, l3;
int main()
{
	node t;
	int head, n, k;
	scanf(&quot;%d %d %d&quot;, &amp;head, &amp;n, &amp;k);
	for(int i=0; i&lt;n; i++){
		scanf(&quot;%d %d %d&quot;, &amp;t.head, &amp;t.num, &amp;t.next);
		l1[t.head] = t;
	}
	while(head!=-1){
		t = l1[head];
		l2.push_back(t);
		head = t.next;
	}
	for(int i=0, j; i&lt;l2.size(); i+=k){
		if(i+k&lt;=l2.size()){
			j = i+k-1;
			while(j&gt;=i){
				l3.push_back(l2[j]);
				j--;
			}
		}
		else{
			j = i;
			while(j&lt;l2.size()){
				l3.push_back(l2[j]);
				j++;
			}
			break;
		}
	}
	for(int i=0; i&lt;l3.size()-1; i++){
		printf(&quot;%05d %d %05d\n&quot;, l3[i].head, l3[i].num, l3[i+1].head);
	}
	printf(&quot;%05d %d -1\n&quot;, l3[l3.size()-1].head, l3[l3.size()-1].num);
	return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[1073 Scientific Notation (20分)题解]]></title>
        <id>https://ygytl.github.io/post/1073-scientific-notation-20-fen-ti-jie/</id>
        <link href="https://ygytl.github.io/post/1073-scientific-notation-20-fen-ti-jie/">
        </link>
        <updated>2020-06-03T04:29:47.000Z</updated>
        <content type="html"><![CDATA[<p>1073 Scientific Notation (20分)</p>
<p>Scientific notation is the way that scientists easily handle very large numbers or very small numbers. The notation matches the regular expression [+-][1-9]<code>.</code>[0-9]+E[+-][0-9]+ which means that the integer portion has exactly one digit, there is at least one digit in the fractional portion, and the number and its exponent's signs are always provided even when they are positive.</p>
<p>Now given a real number <em>A</em> in scientific notation, you are supposed to print <em>A</em> in the conventional notation while keeping all the significant figures.</p>
<h3 id="input-specification">Input Specification:</h3>
<p>Each input contains one test case. For each case, there is one line containing the real number <em>A</em> in scientific notation. The number is no more than 9999 bytes in length and the exponent's absolute value is no more than 9999.</p>
<h3 id="output-specification">Output Specification:</h3>
<p>For each test case, print in one line the input number <em>A</em> in the conventional notation, with all the significant figures kept, including trailing zeros.</p>
<h3 id="sample-input-1">Sample Input 1:</h3>
<pre><code class="language-in">+1.23400E-03
</code></pre>
<h3 id="sample-output-1">Sample Output 1:</h3>
<pre><code class="language-out">0.00123400
</code></pre>
<h3 id="sample-input-2">Sample Input 2:</h3>
<pre><code class="language-in">-1.2E+10
</code></pre>
<h3 id="sample-output-2">Sample Output 2:</h3>
<pre><code class="language-out">-12000000000
</code></pre>
<hr>
<p>题目描述：给定一串表达式，其正则表达式可写为 [+-] [1-9] .[0-9]+E[+-][0-9]+，这里提示一下+ 这个符号，在正则表达式中，表示前一个字符的出现次数为&gt;=1。现在要你将这个表达式以它规定的规则输出。</p>
<p>输出规则：</p>
<p>1)表达式的第一个字符判断该数为正数或负数，若为负数，则输出'-'号</p>
<p>2)字母E后接的是正符号 或 负符号，正号表示将这个数扩大，负号表示将这个数缩小</p>
<p>3)字母E后面接的数字表示扩大或缩小多少，小数点往前移多少位，往后移多少位。</p>
</br>
<p>输入：字符串</p>
<p>输出：按规则输出</p>
</br>
<p>解题思路：</p>
<p>​    表达式中'.'和'E'是固定给出的，可以根据这两个字符将字符串切分。将数字部分提取出来，稍后进行字符串拼接。例如将小数点前的数字记为s1，小数点到字母E之间的数字记为s2，字母E后面的数字记为s3，且将s3转化为整数k，以便将数字放大或缩小。</p>
<p>​    可以将放大和缩小分开来求。1、若k=0，就表示不需要将数据放大或缩小，直接将s1和s2进行拼接，注意s1和s2之间还需加上个小数点；2、将数据缩小其实就是考虑怎么在数据前补0的问题，讨论要不要补0，或要补多少。直接用k减去s1的长度就能求出该在0.后追加几个0了；3、将数据放大则考虑在s2后补多少个0，这要分两部分讨论，1)当扩大倍数小于s2字符串长度(数据本身的小数点位数)时，这种情况下不用补0，需要把小数点放到正确的位置，再将字符串进行拼接就行。2)当扩大倍数大于s2字符串长度时，需要补0，补多少个0，直接k减去s2字符串长度即可。</p>
<p>注意：测试点4，就是讨论当扩大倍数小于s2字符串长度(数据本身的小数点位数)时的情况。</p>
<p>附加测试点4测试数据：</p>
<p>输入：-1.123456E+03，输出-1123.456</p>
<hr>
<pre><code class="language-c++">#include&lt;bits/stdc++.h&gt;
using namespace std;
int get_num(string s){
	int ans = 0;
	for(int i=0; i&lt;s.size(); i++){
		ans = ans*10 + s[i]-'0';
	}
	return ans;
}
int main()
{
	string s, str;
	cin &gt;&gt; s;
	if(s[0]=='-') cout &lt;&lt; '-';
	
	str = s.substr(1);
	string s1=&quot;&quot;, s2=&quot;&quot;, s3=&quot;&quot;;
	int g1=0, g2=0;
	g1 = str.find('.');
	g2 = str.find('E');
	
	s1 = str.substr(0,g1);
	s2 = str.substr(g1+1,g2-g1-1);
	s3 = str.substr(g2+2);
	
	int k = get_num(s3);
	if(k==0){
		cout &lt;&lt; s1 + '.' + s2 &lt;&lt; endl;
		return 0;
	}
	
	string ans = &quot;&quot;;
	if(str[g2+1]=='-'){//前面追加 
		ans = &quot;0.&quot;;
		k-=s1.size();
		while(k){
			ans += '0';
			k--;
		}
		ans = ans + s1 + s2; 
	}
	else{//后面追加 
		int l = s2.size();
		if(k-l&lt;0){
			ans += s1;
			ans += s2.substr(0,k);
			ans += '.';
			ans += s2.substr(k);
		}
		else{
			k-=s2.size();
			ans = ans + s1 + s2;
			while(k){
				ans += '0';
				k--;
			}
		}
	}
	cout &lt;&lt; ans &lt;&lt; endl;
	return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[1064 Complete Binary Search Tree (30分)题解]]></title>
        <id>https://ygytl.github.io/post/1064-complete-binary-search-tree-30-fen-ti-jie/</id>
        <link href="https://ygytl.github.io/post/1064-complete-binary-search-tree-30-fen-ti-jie/">
        </link>
        <updated>2020-06-02T16:06:30.000Z</updated>
        <content type="html"><![CDATA[<p>1064 Complete Binary Search Tree (30分)</p>
<p>A Binary Search Tree (BST) is recursively defined as a binary tree which has the following properties:</p>
<ul>
<li>The left subtree of a node contains only nodes with keys less than the node's key.</li>
<li>The right subtree of a node contains only nodes with keys greater than or equal to the node's key.</li>
<li>Both the left and right subtrees must also be binary search trees.</li>
</ul>
<p>A Complete Binary Tree (CBT) is a tree that is completely filled, with the possible exception of the bottom level, which is filled from left to right.</p>
<p>Now given a sequence of distinct non-negative integer keys, a unique BST can be constructed if it is required that the tree must also be a CBT. You are supposed to output the level order traversal sequence of this BST.</p>
<h3 id="input-specification">Input Specification:</h3>
<p>Each input file contains one test case. For each case, the first line contains a positive integer <em>N</em> (≤1000). Then <em>N</em> distinct non-negative integer keys are given in the next line. All the numbers in a line are separated by a space and are no greater than 2000.</p>
<h3 id="output-specification">Output Specification:</h3>
<p>For each test case, print in one line the level order traversal sequence of the corresponding complete binary search tree. All the numbers in a line must be separated by a space, and there must be no extra space at the end of the line.</p>
<h3 id="sample-input">Sample Input:</h3>
<pre><code class="language-in">10
1 2 3 4 5 6 7 8 9 0
</code></pre>
<h3 id="sample-output">Sample Output:</h3>
<pre><code class="language-out">6 3 8 1 5 7 9 0 2 4
</code></pre>
<hr>
<p>题目描述：给一棵完全二叉搜索树（满二叉搜索树），求输出它的层序遍历。</p>
<p>二叉搜索树的性质：</p>
<p>1、左子结点权值小于其父结点的权值</p>
<p>2、右子结点权值大于其父结点的权值</p>
<p>3、每个左右子结点都是二叉搜索树</p>
</br>
<p>输入：第一行n表示结点个数，第二行表示结点的权值。</p>
<p>输出：输出其层序遍历的结果</p>
</br>
<p>解题思路：不需要建树。先将各个结点的权值保存到数组中，接着将数组从小到大排序，以便放入正确的层序遍历数组中。通常将树放入数组中时，都会牺牲0号索引，从索引1开始存储。用递归算法就能获得层序遍历的结果，接下来利用题目给出的例子分析下这个递归算法。</p>
<p>样例构建出来的树长这样：<br>
<img src="https://ygytl.github.io//post-images/1591114718233.jpg" alt="" width="300" height="400" loading="lazy"></p>
<p>根据上图，可得到层序遍历数组：</p>
<table>
<thead>
<tr>
<th>index</th>
<th style="text-align:center">1</th>
<th style="text-align:center">2</th>
<th style="text-align:center">3</th>
<th style="text-align:center">4</th>
<th style="text-align:center">5</th>
<th style="text-align:center">6</th>
<th style="text-align:center">7</th>
<th style="text-align:center">8</th>
<th style="text-align:center">9</th>
<th style="text-align:center">10</th>
</tr>
</thead>
<tbody>
<tr>
<td>num</td>
<td style="text-align:center">6</td>
<td style="text-align:center">3</td>
<td style="text-align:center">8</td>
<td style="text-align:center">1</td>
<td style="text-align:center">5</td>
<td style="text-align:center">7</td>
<td style="text-align:center">9</td>
<td style="text-align:center">0</td>
<td style="text-align:center">2</td>
<td style="text-align:center">4</td>
</tr>
</tbody>
</table>
<p>现在模拟递归算法的过程：</p>
<p>n = 10</p>
<ol>
<li>
<p>root = 1，root&lt;=n为true，进入if语句中---后续还未完成</p>
</li>
<li>
<p>执行get_level(root*2)，即get_level(1*2)，root=2，root&lt;=n为true，进入if语句中---后续还未完成</p>
</li>
<li>
<p>执行get_level(root*2)，即get_level(2*2)，root=4，root&lt;=n为true，进入if语句中---后续还未完成</p>
</li>
<li>
<p>执行get_level(root*2)，即get_level(4*2)，root=8，root&lt;=n为true，进入if语句中---后续还未完成</p>
</li>
<li>
<p>执行get_level(roo*2)，即get_level(8*2)，root=16，root&lt;=n为false！<em>步骤 5)执行完毕</em>。返回上一条语句，即步骤 4)，执行未完成的部分。</p>
</li>
</ol>
<p>这时，步骤5) 返回到 步骤 4) 的后续执行步骤，root=8且c=0，level[root]=v[c++]即level[8]=v[0]，且c=1。</p>
<ol start="6">
<li>
<p>接着往下执行，root = 8， get_level(root*2+1)，即get_level(8*2+1)---步骤6)只是个过渡，已完成。</p>
</li>
<li>
<p>get_level(17)，root = 17，root&lt;=n为false！<em>步骤7) 执行完毕</em>。至此，<em>步骤4才真正执行完毕</em>。返回上一条语句，即步骤 3)，执行未完成的部分。</p>
</li>
</ol>
<p>这时，步骤7) 返回到 步骤3) 的后续执行步骤，root=4且c=1，level[root]=v[c++]即level[4]=v[1]，且c=2。</p>
<ol start="8">
<li>
<p>接着往下执行，root = 4，get_level(root*2+1)，即get_level(4*2+1)---步骤8)只是个过渡，已完成。</p>
</li>
<li>
<p>get_level(9)，root = 9，root&lt;=n为true，进入if语句中---后续还未完成</p>
</li>
<li>
<p>执行get_level(root*2)，即get_level(9*2)，root=18，root&lt;=n为false！<em>步骤10) 执行完毕</em>。返回到上一条语句，即步骤9)，执行未完成部分</p>
</li>
</ol>
<p>这时，步骤10) 返回到 步骤 9)的后续执行步骤，root=9且c=2，level[root]=v[c++]即level[9]=v[2]，且c=3。</p>
<ol start="11">
<li>
<p>接着往下执行，root = 9，get_level(root*2+1)，即get_level(9*2+1)---步骤11)只是个过渡，已完成。</p>
</li>
<li>
<p>get_level(19)，root = 19，root&lt;=n为false！至此，<em>步骤 9)执行完毕</em>，<em>步骤3)也执行完毕</em>。---步骤12)只是个过渡，已完成。</p>
</li>
<li>
<p>步骤12) 执行完比后，会返回上一个为执行完成的步骤，即步骤2)，往后以此类推。。。</p>
</li>
</ol>
</br>
<p>上述过程写的看似复杂，但是自己动手把数据带入进去，模拟一下就也就那么回事，不难不难。</p>
<hr>
<pre><code class="language-c++">#include&lt;bits/stdc++.h&gt;
using namespace std;
int n, c=0;
vector&lt;int&gt; level, v;
void get_level(int root){
	if(root&lt;=n){
		get_level(root*2);
		level[root] = v[c++];
		get_level(root*2+1);
	}
}
int main()
{
	scanf(&quot;%d&quot;, &amp;n);
	v.resize(n);
	level.resize(n+1);
	for(int i=0; i&lt;n; i++){
		scanf(&quot;%d&quot;, &amp;v[i]);
	}
	sort(v.begin() ,v.end());
	get_level(1);
	for(int i=1; i&lt;=n; i++){
		if(i!=1) printf(&quot; &quot;);
		printf(&quot;%d&quot;, level[i]);
	}
	return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[1053 Path of Equal Weight (30分)题解]]></title>
        <id>https://ygytl.github.io/post/1053-path-of-equal-weight-30-fen-ti-jie/</id>
        <link href="https://ygytl.github.io/post/1053-path-of-equal-weight-30-fen-ti-jie/">
        </link>
        <updated>2020-06-02T04:29:04.000Z</updated>
        <content type="html"><![CDATA[<p>1053 Path of Equal Weight (30分)</p>
<p>Given a non-empty tree with root <em>R</em>, and with weight <em>W**i</em> assigned to each tree node <em>T**i</em>. The <strong>weight of a path from *R* to *L*</strong> is defined to be the sum of the weights of all the nodes along the path from <em>R</em> to any leaf node <em>L</em>.</p>
<p>Now given any weighted tree, you are supposed to find all the paths with their weights equal to a given number. For example, let's consider the tree showed in the following figure: for each node, the upper number is the node ID which is a two-digit number, and the lower number is the weight of that node. Suppose that the given number is 24, then there exists 4 different paths which have the same given weight: {10 5 2 7}, {10 4 10}, {10 3 3 6 2} and {10 3 3 6 2}, which correspond to the red edges in the figure.</p>
<figure data-type="image" tabindex="1"><img src="https://images.ptausercontent.com/212" alt="img" loading="lazy"></figure>
<h3 id="input-specification">Input Specification:</h3>
<p>Each input file contains one test case. Each case starts with a line containing 0&lt;<em>N</em>≤100, the number of nodes in a tree, <em>M</em> (&lt;<em>N</em>), the number of non-leaf nodes, and 0&lt;<em>S</em>&lt;230, the given weight number. The next line contains <em>N</em> positive numbers where <em>W**i</em> (&lt;1000) corresponds to the tree node <em>T**i</em>. Then <em>M</em> lines follow, each in the format:</p>
<pre><code>ID K ID[1] ID[2] ... ID[K]
</code></pre>
<p>where <code>ID</code> is a two-digit number representing a given non-leaf node, <code>K</code> is the number of its children, followed by a sequence of two-digit <code>ID</code>'s of its children. For the sake of simplicity, let us fix the root ID to be <code>00</code>.</p>
<h3 id="output-specification">Output Specification:</h3>
<p>For each test case, print all the paths with weight S in <strong>non-increasing</strong> order. Each path occupies a line with printed weights from the root to the leaf in order. All the numbers must be separated by a space with no extra space at the end of the line.</p>
<p>Note: sequence {<em>A</em>1,<em>A</em>2,⋯,<em>A**n</em>} is said to be <strong>greater than</strong> sequence {<em>B</em>1,<em>B</em>2,⋯,<em>B**m</em>} if there exists 1≤<em>k</em>&lt;<em>m<strong>i</strong>n</em>{<em>n</em>,<em>m</em>} such that <em>A**i</em>=<em>B**i</em> for <em>i</em>=1,⋯,<em>k</em>, and <em>A**k</em>+1&gt;<em>B**k</em>+1.</p>
<h3 id="sample-input">Sample Input:</h3>
<pre><code class="language-in">20 9 24
10 2 4 3 5 10 2 18 9 7 2 2 1 3 12 1 8 6 2 2
00 4 01 02 03 04
02 1 05
04 2 06 07
03 3 11 12 13
06 1 09
07 2 08 10
16 1 15
13 3 14 16 17
17 2 18 19
</code></pre>
<h3 id="sample-output">Sample Output:</h3>
<pre><code class="language-out">10 5 2 7
10 4 10
10 3 3 6 2
10 3 3 6 2
</code></pre>
<hr>
<p>题目描述：现在有一棵树，让你找到根结点到叶子结点总权值为给定值的路径。</p>
</br>
<p>输入：n：节点总数，m：非叶子结点个数；s：假定要求的根节点到叶子节点总权值；接下来m行，包括id：结点编号，k：子结点个数，接下来k个子结点编号。</p>
<p>输出：根结点到叶子结点的过程中经过的总权值等于s，输出所经过结点的权值。</p>
</br>
<p>解题思路：这道题不用建树，用有向图保存这棵树就行。可以用BFS算法或DFS算法。</p>
<p>这里列举BFS算法详解：每个结点的权值保存在weight数组中，边的关系保存在G邻接表中。从root结点层层遍历，很简单的就可以得到根节点到各个叶子结点的总权值了。最重要的还是输出顺序的问题，我先将符合条件的路径权值数组存入ans二维数组容器中，最后将二维数组进行排序。排序规则是每个数组中同一位置的权值最大的序列排在前面输出。</p>
<hr>
<pre><code class="language-c++">//BFS 广度优先
#include&lt;bits/stdc++.h&gt;
using namespace std;
struct node{
	int id;
	long long ss;
	vector&lt;int&gt; list;
	node(){
		ss = 0;
	}
};
int n, m;
long long s;
const int maxn = 220;
int weight[maxn];
vector&lt;int&gt; G[maxn];
vector&lt; vector&lt;int&gt; &gt; ans;
bool cmp(vector&lt;int&gt; a, vector&lt;int&gt; b){
	int l=0;
	l = min(a.size(),b.size());
	for(int i=0; i&lt;l; i++){
		if(a[i]==b[i]) continue;
		else return a[i] &gt; b[i];
	}
	return false; //如果没有，最后一个测试点段错误! 
}
void bfs(int root){
	node t, tt;
	queue&lt;node&gt; q;
	t.id = root; t.ss = weight[root];
	t.list.push_back(weight[root]);
	q.push(t);
	
	int u, v;
	while(!q.empty()){
		t = q.front();
		u = t.id;
		q.pop();
		if(t.ss==s&amp;&amp;G[u].size()==0){
			ans.push_back(t.list);
			continue;
		}
		else if(t.ss &gt; s) continue;
		for(int i=0; i&lt;G[u].size(); i++){
			v = G[u][i];
			tt.id = v; tt.ss = t.ss + weight[v]; tt.list = t.list;
			tt.list.push_back(weight[v]);
			q.push(tt);
		}
	}
	sort(ans.begin(),ans.end(),cmp);
	
	for(int i=0; i&lt;ans.size(); i++){
		for(int j=0; j&lt;ans[i].size(); j++){
			if(j) printf(&quot; &quot;);
			printf(&quot;%d&quot;, ans[i][j]);
		}
		printf(&quot;\n&quot;);
	}
}
int main()
{
	scanf(&quot;%d %d %lld&quot;, &amp;n, &amp;m, &amp;s);
	int id, k, g;
	for(int i=0; i&lt;n; i++) scanf(&quot;%d&quot;, &amp;weight[i]);
	for(int i=0; i&lt;m; i++){
		scanf(&quot;%d %d&quot;, &amp;id, &amp;k);
		for(int j=0; j&lt;k; j++){
			scanf(&quot;%d&quot;, &amp;g);
			G[id].push_back(g);
		}
	}
	bfs(0);
	return 0;
}
</code></pre>
<pre><code class="language-c++">//DFS 深度优先
#include&lt;bits/stdc++.h&gt;
using namespace std;
struct node{
	int w;
	vector&lt;int&gt; child;
};
vector&lt;node&gt; v;
vector&lt;int&gt; path;
int target;
void dfs(int index, int nodenum, int sum){
	if(sum&gt;target) return ;
	if(sum==target){
		if(v[index].child.size()!=0) return;
		for(int i=0; i&lt;nodenum; i++){
			printf(&quot;%d%c&quot;, v[path[i]].w, i!=nodenum-1?' ':'\n');
		}
		return;
	}
	for(int i=0; i&lt;v[index].child.size(); i++){
		int nd = v[index].child[i];
		path[nodenum] = nd;
		dfs(nd,nodenum+1,sum+v[nd].w);
	}
}
int cmp(int a, int b){
	return v[a].w &gt; v[b].w;
}
int main()
{
	int n, m, node, k;
	scanf(&quot;%d %d %d&quot;, &amp;n, &amp;m, &amp;target);
	v.resize(n), path.resize(n);
	for(int i=0; i&lt;n; i++){
		scanf(&quot;%d&quot;, &amp;v[i].w);
	}
	for(int i=0; i&lt;m; i++){
		scanf(&quot;%d %d&quot;, &amp;node, &amp;k);
		v[node].child.resize(k);
		for(int j=0; j&lt;k; j++) scanf(&quot;%d&quot;, &amp;v[node].child[j]);
		sort(v[node].child.begin(),v[node].child.end(),cmp);
	}
	dfs(0,1,v[0].w);
	return 0;
}
</code></pre>
]]></content>
    </entry>
</feed>