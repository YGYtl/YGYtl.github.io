<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://ygytl.github.io/</id>
    <title>Grace</title>
    <updated>2020-06-08T13:09:25.122Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://ygytl.github.io/"/>
    <link rel="self" href="https://ygytl.github.io/atom.xml"/>
    <subtitle>Grace&apos;s blog</subtitle>
    <logo>https://ygytl.github.io/images/avatar.png</logo>
    <icon>https://ygytl.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, Grace</rights>
    <entry>
        <title type="html"><![CDATA[1086 Tree Traversals Again (25分)题解]]></title>
        <id>https://ygytl.github.io/post/1086-tree-traversals-again-25-fen-ti-jie/</id>
        <link href="https://ygytl.github.io/post/1086-tree-traversals-again-25-fen-ti-jie/">
        </link>
        <updated>2020-06-08T13:08:50.000Z</updated>
        <content type="html"><![CDATA[<p>1086 Tree Traversals Again (25分)</p>
<p>An inorder binary tree traversal can be implemented in a non-recursive way with a stack. For example, suppose that when a 6-node binary tree (with the keys numbered from 1 to 6) is traversed, the stack operations are: push(1); push(2); push(3); pop(); pop(); push(4); pop(); pop(); push(5); push(6); pop(); pop(). Then a unique binary tree (shown in Figure 1) can be generated from this sequence of operations. Your task is to give the postorder traversal sequence of this tree.</p>
<p><img src="https://images.ptausercontent.com/30" alt="img" loading="lazy"><br>
Figure 1</p>
<h3 id="input-specification">Input Specification:</h3>
<p>Each input file contains one test case. For each case, the first line contains a positive integer <em>N</em> (≤30) which is the total number of nodes in a tree (and hence the nodes are numbered from 1 to <em>N</em>). Then 2<em>N</em> lines follow, each describes a stack operation in the format: &quot;Push X&quot; where X is the index of the node being pushed onto the stack; or &quot;Pop&quot; meaning to pop one node from the stack.</p>
<h3 id="output-specification">Output Specification:</h3>
<p>For each test case, print the postorder traversal sequence of the corresponding tree in one line. A solution is guaranteed to exist. All the numbers must be separated by exactly one space, and there must be no extra space at the end of the line.</p>
<h3 id="sample-input">Sample Input:</h3>
<pre><code class="language-in">6
Push 1
Push 2
Push 3
Pop
Pop
Push 4
Pop
Pop
Push 5
Push 6
Pop
Pop
</code></pre>
<h3 id="sample-output">Sample Output:</h3>
<pre><code class="language-out">3 4 2 6 5 1
</code></pre>
<hr>
<p>题目描述：题目给定一个二叉树的中序遍历，不过，这个中序遍历要用过出栈入栈的方法得到，出栈的顺序就是这棵二叉树的中序遍历，而入栈的顺序就是先序遍历(这个有一丢丢难看出来哈，画画图就知道了)。给出先序和中序遍历，求后序遍历。</p>
</br>
<p>输入：第一行n为二叉树的节点数，接下来2*n行出栈入栈操作。</p>
<p>输出：输出这棵树的后序遍历。每个值间有个空格隔开。</p>
</br>
<p>解题思路：分别将先序遍历和中序遍历用数组存放。然后通过递归得到后序遍历结果。怎么实现已知先序和中序遍历，就能得到后序遍历呢？主要找根节点，从先序遍历的第一个值，就是树的根结点开始递归。我们用样例来分析。</p>
<table>
<thead>
<tr>
<th>index</th>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
</tr>
</thead>
<tbody>
<tr>
<td>Pre</td>
<td>1</td>
<td>2</td>
<td>3</td>
<td>4</td>
<td>5</td>
<td>6</td>
</tr>
<tr>
<td>In</td>
<td>3</td>
<td>2</td>
<td>4</td>
<td>1</td>
<td>6</td>
<td>5</td>
</tr>
</tbody>
</table>
<p>后序遍历结果：3 4 2 6 5 1</p>
<p>1）递归一开始，root=0，inl=0，inr=n-1=5，这些传入函数的值分别是根节点在先序遍历Pre中的索引位置，中序遍历的左右索引边界。</p>
<p>2）递归的退出口是非常重要的，要想好放在哪。这里就是当inl大于inr时，递归结束。</p>
<p>3）while循环得到的是根节点在中序遍历中的位置，用i来标记。</p>
<p>4）接着分别找到先序遍历中，当前根节点的左右子结点索引，充当递归的根节点索引。为什么找索引，知道索引，那么值也就很容易得到啦</p>
<p>5）左子结点直接root+1就行；右子节点需要计算一下，式子为root+(i-inl)+1，i-inl是左子树值的个数，这里需要把他们排除了，再加一，就得到右子节点的索引了。</p>
<p>6）为什么post_back写在最后面，题目求的是后序遍历嘛。放在while循环后面得到先序遍历，放在两个get_post之间得到中序遍历。</p>
<hr>
<pre><code class="language-c++">#include&lt;bits/stdc++.h&gt;
using namespace std;
int n;
const int maxn = 100;
int in[maxn], pre[maxn];
vector&lt;int&gt; post;
void get_post(int root, int l, int r){
	if(l&gt;r) return ;
	int i = l;
	while(i&lt;=r&amp;&amp;pre[root]!=in[i]) i++;
	get_post(root+1,l,i-1);
	get_post(root+i-l+1,i+1,r);
	post.push_back(pre[root]);
}
int main()
{
	string str;
	int c1=0, c2=0, c3=0, k;
	stack&lt;int&gt; s; 
	cin &gt;&gt; n;
	for(int i=0; i&lt;2*n; i++){
		cin &gt;&gt; str;
		if(str==&quot;Push&quot;){
			cin &gt;&gt; k;
			pre[c1++] = k;
			s.push(k);
		}
		else{
			in[c2++] = s.top();
			s.pop();
		}
	}
	get_post(0, 0, n-1);
	for(int i=0; i&lt;post.size(); i++){
		if(i) printf(&quot; &quot;);
		printf(&quot;%d&quot;, post[i]);
	}
	return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[1085 Perfect Sequence (25分)题解]]></title>
        <id>https://ygytl.github.io/post/1085-perfect-sequence-25-fen-ti-jie/</id>
        <link href="https://ygytl.github.io/post/1085-perfect-sequence-25-fen-ti-jie/">
        </link>
        <updated>2020-06-07T16:12:19.000Z</updated>
        <content type="html"><![CDATA[<p>1085 Perfect Sequence (25分)</p>
<p>Given a sequence of positive integers and another positive integer <em>p</em>. The sequence is said to be a <strong>perfect sequence</strong> if <em>M</em>≤<em>m</em>×<em>p</em> where <em>M</em> and <em>m</em> are the maximum and minimum numbers in the sequence, respectively.</p>
<p>Now given a sequence and a parameter <em>p</em>, you are supposed to find from the sequence as many numbers as possible to form a perfect subsequence.</p>
<h3 id="input-specification">Input Specification:</h3>
<p>Each input file contains one test case. For each case, the first line contains two positive integers <em>N</em> and <em>p</em>, where <em>N</em> (≤105) is the number of integers in the sequence, and <em>p</em> (≤109) is the parameter. In the second line there are <em>N</em> positive integers, each is no greater than 109.</p>
<h3 id="output-specification">Output Specification:</h3>
<p>For each test case, print in one line the maximum number of integers that can be chosen to form a perfect subsequence.</p>
<h3 id="sample-input">Sample Input:</h3>
<pre><code class="language-in">10 8
2 3 20 4 5 1 6 7 8 9
</code></pre>
<h3 id="sample-output">Sample Output:</h3>
<pre><code class="language-out">8
</code></pre>
<hr>
<p>题目描述：求完美数列，要求数列元素尽可能多。完美数列公式：M&lt;=m*p，M为数列中最大值，m为数列中最小值，p是给定的值。</p>
</br>
<p>输入：第一行两个值n，p，分别为数列元素个数，p是给定的值；第二行n个值给出无序的数列。</p>
<p>输出：完美数列元素的个数。</p>
</br>
<p>解题思路：要用long long类型存值，不然测试点5报错。将给定的数列从小到大排序，接着从索引0开始遍历，用二分查找找到每个元素能组成的最大完美子序列长度，进行比较后得出结果。</p>
<hr>
<pre><code class="language-c++">#include&lt;bits/stdc++.h&gt;
using namespace std;
const int maxn = 200000+5;
long long v[maxn];
int n, p;
int search(int g){
	int l=g, r=n-1, mid;
	int tx = 0;
	while(l&lt;=r){
		mid = (l+r)/2;
		if(v[mid]&lt;=v[g]*p){
			tx = max(tx,mid-g+1);
			l = mid + 1;
		}
		else r = mid-1;
	}
	return tx;
}
int main()
{
	int ans=0;
	scanf(&quot;%d %d&quot;, &amp;n, &amp;p);
	for(int i=0; i&lt;n; i++) scanf(&quot;%lld&quot;, &amp;v[i]);
	sort(v,v+n);//小到大 
	for(int i=0; i&lt;n; i++){
		ans = max(ans,search(i));
	}
	printf(&quot;%d&quot;, ans);
	return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[1084 Broken Keyboard (20分)题解]]></title>
        <id>https://ygytl.github.io/post/1084-broken-keyboard-20-fen-ti-jie/</id>
        <link href="https://ygytl.github.io/post/1084-broken-keyboard-20-fen-ti-jie/">
        </link>
        <updated>2020-06-07T14:47:11.000Z</updated>
        <content type="html"><![CDATA[<p>1084 Broken Keyboard (20分)</p>
<p>On a broken keyboard, some of the keys are worn out. So when you type some sentences, the characters corresponding to those keys will not appear on screen.</p>
<p>Now given a string that you are supposed to type, and the string that you actually type out, please list those keys which are for sure worn out.</p>
<h3 id="input-specification">Input Specification:</h3>
<p>Each input file contains one test case. For each case, the 1st line contains the original string, and the 2nd line contains the typed-out string. Each string contains no more than 80 characters which are either English letters [A-Z] (case insensitive), digital numbers [0-9], or <code>_</code> (representing the space). It is guaranteed that both strings are non-empty.</p>
<h3 id="output-specification">Output Specification:</h3>
<p>For each test case, print in one line the keys that are worn out, in the order of being detected. The English letters must be capitalized. Each worn out key must be printed once only. It is guaranteed that there is at least one worn out key.</p>
<h3 id="sample-input">Sample Input:</h3>
<pre><code class="language-in">7_This_is_a_test
_hs_s_a_es
</code></pre>
<h3 id="sample-output">Sample Output:</h3>
<pre><code class="language-out">7TI
</code></pre>
<hr>
<p>题目描述：在一个坏掉的键盘上，有些键是损坏的，我们通过输入一串字符串，来找到那些坏掉的键。</p>
</br>
<p>输入：第一行一串字符串，若键盘没有坏，他应该像第一行的字符串这样完整的显示在电脑屏幕上。第二行也是字符串，他是坏掉的键盘输入后，显示在电脑上的效果。</p>
<p>输出：坏掉的键值，若是拼音，则输出他的大写形式。</p>
</br>
<p>解题思路：两个字符串同时从索引0开始扫描，对比一下两个字符串，结果就出来了。哦，因为题目要求输出字母大写的形式，若字符串中出现小写字母，要转换处理一下再输出。</p>
<hr>
<pre><code class="language-c++">#include&lt;bits/stdc++.h&gt;
using namespace std;
int main()
{
	string s1, s2;
	getline(cin,s1);
	getline(cin,s2);
	int c = 0;
	map&lt;char,bool&gt; p;
	for(int i=0; i&lt;s1.length(); i++){
		char ch1=s1[i], ch2=s2[c];
		if(s1[i]&gt;='a'&amp;&amp;s1[i]&lt;='z') ch1 = s1[i]-'a'+'A';
		if(s2[c]&gt;='a'&amp;&amp;s2[c]&lt;='z') ch2 = s2[c]-'a'+'A'; 
		if(ch1!=ch2&amp;&amp;p[ch1]==false){
			cout &lt;&lt; ch1;
			p[ch1] = true;
		}
		else if(ch1==ch2) c++;
	}
    cout &lt;&lt; endl;
	return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[1083 List Grades (25分)题解]]></title>
        <id>https://ygytl.github.io/post/1083-list-grades-25-fen-ti-jie/</id>
        <link href="https://ygytl.github.io/post/1083-list-grades-25-fen-ti-jie/">
        </link>
        <updated>2020-06-07T14:19:56.000Z</updated>
        <content type="html"><![CDATA[<p>1083 List Grades (25分)</p>
<p>Given a list of <em>N</em> student records with name, ID and grade. You are supposed to sort the records with respect to the grade in non-increasing order, and output those student records of which the grades are in a given interval.</p>
<h3 id="input-specification">Input Specification:</h3>
<p>Each input file contains one test case. Each case is given in the following format:</p>
<pre><code>N
name[1] ID[1] grade[1]
name[2] ID[2] grade[2]
... ...
name[N] ID[N] grade[N]
grade1 grade2
</code></pre>
<p>where <code>name[i]</code> and <code>ID[i]</code> are strings of no more than 10 characters with no space, <code>grade[i]</code> is an integer in [0, 100], <code>grade1</code> and <code>grade2</code> are the boundaries of the grade's interval. It is guaranteed that all the grades are <strong>distinct</strong>.</p>
<h3 id="output-specification">Output Specification:</h3>
<p>For each test case you should output the student records of which the grades are in the given interval [<code>grade1</code>, <code>grade2</code>] and are in non-increasing order. Each student record occupies a line with the student's name and ID, separated by one space. If there is no student's grade in that interval, output <code>NONE</code> instead.</p>
<h3 id="sample-input-1">Sample Input 1:</h3>
<pre><code class="language-in">4
Tom CS000001 59
Joe Math990112 89
Mike CS991301 100
Mary EE990830 95
60 100
</code></pre>
<h3 id="sample-output-1">Sample Output 1:</h3>
<pre><code class="language-out">Mike CS991301
Mary EE990830
Joe Math990112
</code></pre>
<h3 id="sample-input-2">Sample Input 2:</h3>
<pre><code class="language-in">2
Jean AA980920 60
Ann CS01 80
90 95
</code></pre>
<h3 id="sample-output-2">Sample Output 2:</h3>
<pre><code class="language-out">NONE
</code></pre>
<hr>
<p>题目描述：题目给定某些学生的信息，包括姓名、课程号、课程得分，现在给定一个区间的分数，若有学生分数在给定区间内，则输出该学生的姓名及性别。没有则输出NONE。</p>
</br>
<p>输入：第一行n表示学生信息个数。接下来n行提供学生信息。</p>
<p>输出：输出分数在给定区间分数的学生信息，输出时按成绩递减输出，若没有符合的学生，输出NONE。</p>
</br>
<p>解题思路：写个cmp函数比较排序一下就行了。</p>
<hr>
<pre><code class="language-c++">#include&lt;bits/stdc++.h&gt;
using namespace std;
struct node{
	string name, class_name;
	int score;
};
vector&lt;node&gt; v, List;
bool cmp(node a, node b){
	return a.score &gt; b.score;
}
int main()
{
	int n, l, r;
	node t;
	scanf(&quot;%d&quot;, &amp;n);
	for(int i=0; i&lt;n; i++){
		cin &gt;&gt; t.name &gt;&gt; t.class_name &gt;&gt; t.score;
		v.push_back(t);
	}
	scanf(&quot;%d %d&quot;, &amp;l, &amp;r);
	for(int i=0; i&lt;n; i++){
		t = v[i];
		if(t.score &gt;= l &amp;&amp; t.score &lt;= r){
			List.push_back(t);
		}
	}
	sort(List.begin(),List.end(),cmp);
	if(List.size()==0) printf(&quot;NONE&quot;);
	for(int i=0; i&lt;List.size(); i++){
		cout &lt;&lt; List[i].name &lt;&lt; &quot; &quot; &lt;&lt; List[i].class_name &lt;&lt; endl;
	}
	return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[1082 Read Number in Chinese (25分)题解]]></title>
        <id>https://ygytl.github.io/post/1082-read-number-in-chinese-25-fen-ti-jie/</id>
        <link href="https://ygytl.github.io/post/1082-read-number-in-chinese-25-fen-ti-jie/">
        </link>
        <updated>2020-06-07T13:17:11.000Z</updated>
        <content type="html"><![CDATA[<p>1082 Read Number in Chinese (25分)</p>
<p>Given an integer with no more than 9 digits, you are supposed to read it in the traditional Chinese way. Output <code>Fu</code> first if it is negative. For example, -123456789 is read as <code>Fu yi Yi er Qian san Bai si Shi wu Wan liu Qian qi Bai ba Shi jiu</code>. Note: zero (<code>ling</code>) must be handled correctly according to the Chinese tradition. For example, 100800 is <code>yi Shi Wan ling ba Bai</code>.</p>
<h3 id="input-specification">Input Specification:</h3>
<p>Each input file contains one test case, which gives an integer with no more than 9 digits.</p>
<h3 id="output-specification">Output Specification:</h3>
<p>For each test case, print in a line the Chinese way of reading the number. The characters are separated by a space and there must be no extra space at the end of the line.</p>
<h3 id="sample-input-1">Sample Input 1:</h3>
<pre><code class="language-in">-123456789
</code></pre>
<h3 id="sample-output-1">Sample Output 1:</h3>
<pre><code class="language-out">Fu yi Yi er Qian san Bai si Shi wu Wan liu Qian qi Bai ba Shi jiu
</code></pre>
<h3 id="sample-input-2">Sample Input 2:</h3>
<pre><code class="language-in">100800
</code></pre>
<h3 id="sample-output-2">Sample Output 2:</h3>
<pre><code class="language-out">yi Shi Wan ling ba Bai
</code></pre>
<hr>
<p>题目描述：将数字转化为字母拼音的格式</p>
</br>
<p>输入：不超过9 digits的数</p>
<p>输出：汉字拼音格式</p>
</br>
<p>解题思路：把几个坑说下，测试点3是输入0的时候是否输出'ling'。难点是对零的处理，给几个测试数据吧，测试通过基本就行了；这里提供两个写法，细节处理有些许不同。</p>
<pre><code>9090909
jiu Bai ling jiu Wan ling jiu Bai ling jiu

100000009
yi Yi Wan ling jiu

0
ling

10086
yi Wan ling ba Shi liu

110110
yi Shi yi Wan ling yi Bai yi Shi
</code></pre>
<hr>
<pre><code class="language-c++">#include&lt;bits/stdc++.h&gt;
using namespace std;
//方法一
int main()
{
	string s;
	cin &gt;&gt; s;
	map&lt;int,string&gt; p;
	p[0]=&quot;ling&quot;; p[1]=&quot;yi&quot;; p[2]=&quot;er&quot;; p[3]=&quot;san&quot;; p[4]=&quot;si&quot;; p[5]=&quot;wu&quot;;
	p[6]=&quot;liu&quot;; p[7]=&quot;qi&quot;; p[8]=&quot;ba&quot;; p[9]=&quot;jiu&quot;;
	if(s[0]=='-'){
		printf(&quot;Fu &quot;);
	}
	else s = &quot;+&quot;+s;
	string ans=&quot;&quot;;
	bool flag = false;
	int l = s.size();
	for(int i=1; i&lt;l; i++){
		if(s[i]=='0'){
			if(l-i==5) ans += &quot; Wan&quot;; 
			flag = true;
			continue;
		}
		else{
			if(i!=1) ans += &quot; &quot;;
			if(flag){
				ans+= p[0] + &quot; &quot;;
			}
			flag = false;
			if(l-i==1) ans += p[s[i]-'0'];
			if(l-i==2||l-i==6) ans += p[s[i]-'0'] + &quot; Shi&quot;;
			if(l-i==3||l-i==7) ans += p[s[i]-'0'] + &quot; Bai&quot;;
			if(l-i==4||l-i==8) ans += p[s[i]-'0'] + &quot; Qian&quot;;
			if(l-i==5) ans += p[s[i]-'0'] + &quot; Wan&quot;;
			if(l-i==9) ans += p[s[i]-'0'] + &quot; Yi&quot;;
		}
	}
	if(s==&quot;+0&quot;||s==&quot;-0&quot;) ans = &quot;ling&quot;;
	cout &lt;&lt; ans &lt;&lt; endl;
	return 0;
}
</code></pre>
<pre><code class="language-c++">#include&lt;bits/stdc++.h&gt;
using namespace std;
//方法二
int main()
{
	map&lt;int,string&gt; p;
	p[0] = &quot;ling&quot;; p[1] = &quot;yi&quot;; p[2] = &quot;er&quot;; p[3] = &quot;san&quot;;
	p[4] = &quot;si&quot;; p[5] = &quot;wu&quot;; p[6] = &quot;liu&quot;; p[7] = &quot;qi&quot;;
	p[8] = &quot;ba&quot;; p[9] = &quot;jiu&quot;;
	string str, ans=&quot;&quot;;
	cin &gt;&gt; str;
	int l, s=0;
	bool flag = false;
	l = str.length();
	if(str[0]=='-'){
		ans += &quot;Fu&quot;;
		s++; l--; flag = true;
	}
	bool f1=false, f2=false, f3=false;
	for(int i=s; i&lt;str.length(); i++,l--){
		f1 = false;
		if(l&gt;=5&amp;&amp;l&lt;=8) f2 = true;
		if(str[i]=='0') f3 = true;
		else{
			f1 = true;
			if(flag) ans += &quot; &quot;;
			if(f3) ans += &quot;ling &quot;;
			ans += p[str[i]-'0'];
			flag = true;
			f3 = false;
		}
		if(f1){
			if(l==2||l==6) ans += &quot; Shi&quot;;
			if(l==3||l==7) ans += &quot; Bai&quot;;
			if(l==4||l==8) ans += &quot; Qian&quot;;
			if(l==9) ans += &quot; Yi&quot;;
		}
		if(f2&amp;&amp;l==5){
			ans += &quot; Wan&quot;; f2 = false;
		}
	}
	if(str==&quot;0&quot;) ans = &quot;ling&quot;;
	cout &lt;&lt; ans &lt;&lt; endl;
	return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[1080 Graduate Admission (30分)题解]]></title>
        <id>https://ygytl.github.io/post/1080-graduate-admission-30-fen-ti-jie/</id>
        <link href="https://ygytl.github.io/post/1080-graduate-admission-30-fen-ti-jie/">
        </link>
        <updated>2020-06-07T09:14:00.000Z</updated>
        <content type="html"><![CDATA[<p>1080 Graduate Admission (30分)</p>
<p>It is said that in 2011, there are about 100 graduate schools ready to proceed over 40,000 applications in Zhejiang Province. It would help a lot if you could write a program to automate the admission procedure.</p>
<p>Each applicant will have to provide two grades: the national entrance exam grade <em>G**E</em>, and the interview grade <em>G**I</em>. The final grade of an applicant is (<em>G**E</em>+<em>G**I</em>)/2. The admission rules are:</p>
<ul>
<li>The applicants are ranked according to their final grades, and will be admitted one by one from the top of the rank list.</li>
<li>If there is a tied final grade, the applicants will be ranked according to their national entrance exam grade <em>G**E</em>. If still tied, their ranks must be the same.</li>
<li>Each applicant may have <em>K</em> choices and the admission will be done according to his/her choices: if according to the rank list, it is one's turn to be admitted; and if the quota of one's most preferred shcool is not exceeded, then one will be admitted to this school, or one's other choices will be considered one by one in order. If one gets rejected by all of preferred schools, then this unfortunate applicant will be rejected.</li>
<li>If there is a tied rank, and if the corresponding applicants are applying to the same school, then that school must admit all the applicants with the same rank, <strong>even if its quota will be exceeded</strong>.</li>
</ul>
<h3 id="input-specification">Input Specification:</h3>
<p>Each input file contains one test case.</p>
<p>Each case starts with a line containing three positive integers: <em>N</em> (≤40,000), the total number of applicants; <em>M</em> (≤100), the total number of graduate schools; and <em>K</em> (≤5), the number of choices an applicant may have.</p>
<p>In the next line, separated by a space, there are <em>M</em> positive integers. The <em>i</em>-th integer is the quota of the <em>i</em>-th graduate school respectively.</p>
<p>Then <em>N</em> lines follow, each contains 2+<em>K</em> integers separated by a space. The first 2 integers are the applicant's <em>G**E</em> and <em>G**I</em>, respectively. The next <em>K</em> integers represent the preferred schools. For the sake of simplicity, we assume that the schools are numbered from 0 to <em>M</em>−1, and the applicants are numbered from 0 to <em>N</em>−1.</p>
<h3 id="output-specification">Output Specification:</h3>
<p>For each test case you should output the admission results for all the graduate schools. The results of each school must occupy a line, which contains the applicants' numbers that school admits. The numbers must be in increasing order and be separated by a space. There must be no extra space at the end of each line. If no applicant is admitted by a school, you must output an empty line correspondingly.</p>
<h3 id="sample-input">Sample Input:</h3>
<pre><code class="language-in">11 6 3
2 1 2 2 2 3
100 100 0 1 2
60 60 2 3 5
100 90 0 3 4
90 100 1 2 0
90 90 5 1 3
80 90 1 0 2
80 80 0 1 2
80 80 0 1 2
80 70 1 3 2
70 80 1 2 3
100 100 0 2 4
</code></pre>
<h3 id="sample-output">Sample Output:</h3>
<pre><code class="language-out">0 10
3
5 6 7
2 8

1 4
</code></pre>
<hr>
<p>题目描述：学校录取学生的模拟过程</p>
</br>
<p>输入：第一行n，m，k。分别为学生人数，学校数，学生可填报志愿数。第二行m个值，分别表示学校录取的人数。接下来n行，为学生的考试成绩GE，GI，以及填报的k个学校。</p>
<p>输出：每个学校录取的学生编号，从小到大输出。</p>
<p>录取规则：成绩排序，总分=（GE+GI）/2，总分高排在前面；当总分相同时，GE成绩高排在前面；当总分和GE都相同时，排名并列。如果学校最后录取的学生有多名排名是一样的，超额也要将他们都录取了。</p>
</br>
<p>解题思路：模拟题，很容易就把简单的问题复杂化了。先将学生按照成绩排序，分高的选择权。可以从第一名开始按其意愿选择学校，当他选择的学校没有录取满人时，他就会直接被学校录取，当学校录取满人了，其他成绩比较低的就无法再进入这满了人的学校，只能看其他志愿。</p>
<p>注意：在学校最后录取的学生成绩/排名不唯一时，怎么把排名相同的全部录取？这需要将学校最后录取的人的分数记录下来，就两个数组记录一下就行了。</p>
<p>模拟题得多做几道，找找感觉！</p>
<hr>
<pre><code class="language-c++">#include&lt;bits/stdc++.h&gt;
using namespace std;
const int maxn = 40000+5;
int n, m, k, snum[200], ltsum[200], ltge[200];
bool vis[maxn];
struct node{
	int ge, gi, id, sum;
	vector&lt;int&gt; sc;
	bool operator &lt;( const node &amp;x )const{
        if( sum!=x.sum ) return sum &gt; x.sum;
        return ge &gt; x.ge;
    }
};
vector&lt;int&gt; ans[200];
vector&lt;node&gt; v;
//bool cmp(node a, node b){
//	if(a.sum!=b.sum) return a.sum &gt; b.sum;
//	else return a.ge &gt; b.ge;
//}
int main()
{
	int g;
	memset(vis,true,sizeof(vis));
	scanf(&quot;%d %d %d&quot;, &amp;n, &amp;m, &amp;k);
	for(int i=0; i&lt;m; i++) scanf(&quot;%d&quot;, &amp;snum[i]);
	for(int i=0; i&lt;n; i++){//学生 
		node t;
		scanf(&quot;%d %d&quot;, &amp;t.ge, &amp;t.gi);
		t.id = i; t.sum = t.ge+t.gi;
		for(int j=0; j&lt;k; j++){
			scanf(&quot;%d&quot;, &amp;g);
			t.sc.push_back(g);//学生报志愿 
		}
		v.push_back(t);
	}
//	sort(v.begin(),v.end(),cmp);
	sort(v.begin(), v.end());
	for(int i=0; i&lt;n; i++){
		node t = v[i];
		for(int j=0; j&lt;k; j++){
			int cid = t.sc[j];
			if(!vis[t.id]) continue;
			if(ans[cid].size()&lt;snum[cid]){
				ltsum[cid] = t.sum;
				ltge[cid] = t.ge;
				ans[cid].push_back(t.id);
				vis[t.id] = false;
			}
			else if(t.sum==ltsum[cid]&amp;&amp;t.ge==ltge[cid]){
				ans[cid].push_back(t.id);
				vis[t.id] = false;
			}
		}
	}
	for(int i=0; i&lt;m; i++){
		sort(ans[i].begin(),ans[i].end());
		for(int j=0; j&lt;ans[i].size(); j++){
			if(j) printf(&quot; &quot;);
			printf(&quot;%d&quot;, ans[i][j]);
		}
		printf(&quot;\n&quot;);
	}
	return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[1076 Forwards on Weibo (30分)题解]]></title>
        <id>https://ygytl.github.io/post/1076-forwards-on-weibo-30-fen-ti-jie/</id>
        <link href="https://ygytl.github.io/post/1076-forwards-on-weibo-30-fen-ti-jie/">
        </link>
        <updated>2020-06-06T10:01:02.000Z</updated>
        <content type="html"><![CDATA[<p>1076 Forwards on Weibo (30分)</p>
<p>Weibo is known as the Chinese version of Twitter. One user on Weibo may have many followers, and may follow many other users as well. Hence a social network is formed with followers relations. When a user makes a post on Weibo, all his/her followers can view and forward his/her post, which can then be forwarded again by their followers. Now given a social network, you are supposed to calculate the maximum potential amount of forwards for any specific user, assuming that only <em>L</em> levels of indirect followers are counted.</p>
<h3 id="input-specification">Input Specification:</h3>
<p>Each input file contains one test case. For each case, the first line contains 2 positive integers: <em>N</em> (≤1000), the number of users; and <em>L</em> (≤6), the number of levels of indirect followers that are counted. Hence it is assumed that all the users are numbered from 1 to <em>N</em>. Then <em>N</em> lines follow, each in the format:</p>
<pre><code>M[i] user_list[i]
</code></pre>
<p>where <code>M[i]</code> (≤100) is the total number of people that <code>user[i]</code> follows; and <code>user_list[i]</code> is a list of the <code>M[i]</code> users that followed by <code>user[i]</code>. It is guaranteed that no one can follow oneself. All the numbers are separated by a space.</p>
<p>Then finally a positive <em>K</em> is given, followed by <em>K</em> <code>UserID</code>'s for query.</p>
<h3 id="output-specification">Output Specification:</h3>
<p>For each <code>UserID</code>, you are supposed to print in one line the maximum potential amount of forwards this user can trigger, assuming that everyone who can view the initial post will forward it once, and that only <em>L</em> levels of indirect followers are counted.</p>
<h3 id="sample-input">Sample Input:</h3>
<pre><code class="language-in">7 3
3 2 3 4
0
2 5 6
2 3 1
2 3 4
1 4
1 5
2 2 6
</code></pre>
<h3 id="sample-output">Sample Output:</h3>
<pre><code class="language-out">4
5
</code></pre>
<hr>
<p>题目描述：微博吧啦吧啦。。现在！给你一个社会网图，你需要求出最大潜在的转发数时多少，假设只能传到L层关系。</p>
</br>
<p>输入：第一行两个正整数N(&lt;=1000)用户数，L(&lt;=6)转发层。接下来有N行，每行代表第i个用户关注的人(i=1~N)，每行格式为M[i] user_list[i]，user_list时用户的编号。最后一行，第一个数K是带查询个数，接下来就是K个值啦。比如样例中最后一行K=2，带查询的第一个值是2。分析下样例，先把图画出来，当2发出一篇微博时，他最大能被转发的次数是多少？显然是4，他能被(1、4、5、6)转发。</p>
<p>输出：转发的次数</p>
</br>
<p>解题思路：要查询那个点，就从哪个点开始广搜遍历就行了。</p>
<p>注意：很简单的一道BFS题，不知道为什么会出现在30分这里。难道是因为最后一个测试点卡着了？最后一个测试点容易超时。</p>
<hr>
<pre><code class="language-c++">#include&lt;bits/stdc++.h&gt;
using namespace std;
int n, l;
const int maxn = 1000+5;
vector&lt;int&gt; G[maxn];
bool vis[maxn];
struct node{
	int index, level;
	node(){
		index = level = 0;
	}
};
void query(int start){
	fill(vis,vis+maxn,false);
	node t, tt;
	t.index = start;
	t.level = 0;
	queue&lt;node&gt; q;
	q.push(t);
	vis[start] = true;
	int ans = 0;
	while(!q.empty()){
		t = q.front(); q.pop();
		for(int i=0; i&lt;G[t.index].size(); ++i){
			int u = G[t.index][i];
			if(!vis[u]&amp;&amp;t.level&lt;l){
				ans++;
				vis[u] = true;
				tt.index = u;
				tt.level = t.level+1;
				q.push(tt);
			}
		}
	}
	printf(&quot;%d\n&quot;, ans);
}
int main()
{
	int k, g;
	scanf(&quot;%d %d&quot;, &amp;n, &amp;l);
	for(int i=1; i&lt;=n; ++i){
		scanf(&quot;%d&quot;, &amp;k);
		for(int j=0; j&lt;k; ++j){
			scanf(&quot;%d&quot;, &amp;g);
			G[g].push_back(i);
		}
	}
	scanf(&quot;%d&quot;, &amp;k);
	for(int i=0; i&lt;k; ++i){
		scanf(&quot;%d&quot;, &amp;g);
		query(g);
	}
	return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[1081 Rational Sum (20分)题解]]></title>
        <id>https://ygytl.github.io/post/1081-rational-sum-20-fen-ti-jie/</id>
        <link href="https://ygytl.github.io/post/1081-rational-sum-20-fen-ti-jie/">
        </link>
        <updated>2020-06-06T09:12:16.000Z</updated>
        <content type="html"><![CDATA[<p>1081 Rational Sum (20分)</p>
<p>Given <em>N</em> rational numbers in the form <code>numerator/denominator</code>, you are supposed to calculate their sum.</p>
<h3 id="input-specification">Input Specification:</h3>
<p>Each input file contains one test case. Each case starts with a positive integer <em>N</em> (≤100), followed in the next line <em>N</em> rational numbers <code>a1/b1 a2/b2 ...</code> where all the numerators and denominators are in the range of <strong>long int</strong>. If there is a negative number, then the sign must appear in front of the numerator.</p>
<h3 id="output-specification">Output Specification:</h3>
<p>For each test case, output the sum in the simplest form <code>integer numerator/denominator</code> where <code>integer</code> is the integer part of the sum, <code>numerator</code> &lt; <code>denominator</code>, and the numerator and the denominator have no common factor. You must output only the fractional part if the integer part is 0.</p>
<h3 id="sample-input-1">Sample Input 1:</h3>
<pre><code class="language-in">5
2/5 4/15 1/30 -2/60 8/3
</code></pre>
<h3 id="sample-output-1">Sample Output 1:</h3>
<pre><code class="language-out">3 1/3
</code></pre>
<h3 id="sample-input-2">Sample Input 2:</h3>
<pre><code class="language-in">2
4/3 2/3
</code></pre>
<h3 id="sample-output-2">Sample Output 2:</h3>
<pre><code class="language-out">2
</code></pre>
<h3 id="sample-input-3">Sample Input 3:</h3>
<pre><code class="language-in">3
1/3 -1/6 1/8
</code></pre>
<h3 id="sample-output-3">Sample Output 3:</h3>
<pre><code class="language-out">7/24
</code></pre>
<hr>
<p>题目描述：分数求和。</p>
</br>
<p>输入：第一行n表示分数的个数，第二行n个分数。</p>
<p>输出：分数之和。输出格式 1）4/3输出1 2/3；2）4 /4 输出 1；3）2/3输出2/3</p>
</br>
<p>解题思路：我习惯将程序分块写，这样程序看起来比较直观清晰；将所有分数加起来，可以先记录第一个分数，分子为a1、分母为b1，接着读第二个分数，第二个分数分子为a2，分母为b2，接着就可以将两个分数进行计算了，然后将计算结果分别再存入a1和b1；后面读入的分数都存在a2和b2中，重复上述过程。得到的结果a1和b1按照题目规定输出格式输出。</p>
<p>两个分数相加的过程：例如2/5和4/15相加，想求出两个分母的最大公因数为5，两个分母同时除于5，分别得到b1=1，b2=3，将分子a1乘与b2，a2乘与b1，则a1=6，a2=4，此时，分数分别为6/1和4/3，让a1=a1+a2=10，b1 = b1*b2*gcd(b1,b2)=15（分母进行通分的过程），这样就能将两分数相加的结果放入a1和b1了，即2/5 + 4 / 15 = 10 / 15。</p>
<hr>
<pre><code class="language-c++">#include&lt;bits/stdc++.h&gt;
using namespace std;
int n, a1, b1, a2, b2;
int gcd(int a, int b){ return a == 0 ? b : gcd(b % a, a); } 
void sum(){
	int g = gcd(b1,b2);
	b1 /= g;
	b2 /= g;
	a1*=b2; a2 *= b1;
	a1 += a2;
	b1 *= b2*g;
}
int main()
{
	scanf(&quot;%d&quot;, &amp;n);
	for(int i=0; i&lt;n; i++){
		if(i==0) scanf(&quot;%d/%d&quot;, &amp;a1, &amp;b1);
		else{
			scanf(&quot;%d/%d&quot;, &amp;a2, &amp;b2);
			sum();
		}
	}
	int g = gcd(a1,b1);
	a1 /= g; b1 /= g;
	if(a1%b1==0) printf(&quot;%d\n&quot;, a1/b1);
	else if(a1&gt;b1) printf(&quot;%d %d/%d\n&quot;, a1/b1, a1%b1, b1);
	else printf(&quot;%d/%d&quot;, a1%b1, b1);
	return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[1079 Total Sales of Supply Chain (25分)题解]]></title>
        <id>https://ygytl.github.io/post/1079-total-sales-of-supply-chain-25-fen-ti-jie/</id>
        <link href="https://ygytl.github.io/post/1079-total-sales-of-supply-chain-25-fen-ti-jie/">
        </link>
        <updated>2020-06-06T03:48:31.000Z</updated>
        <content type="html"><![CDATA[<p>1079 Total Sales of Supply Chain (25分)</p>
<p>A supply chain is a network of retailers（零售商）, distributors（经销商）, and suppliers（供应商）-- everyone involved in moving a product from supplier to customer.</p>
<p>Starting from one root supplier, everyone on the chain buys products from one's supplier in a price <em>P</em> and sell or distribute them in a price that is <em>r</em>% higher than <em>P</em>. Only the retailers will face the customers. It is assumed that each member in the supply chain has exactly one supplier except the root supplier, and there is no supply cycle.</p>
<p>Now given a supply chain, you are supposed to tell the total sales from all the retailers.</p>
<h3 id="input-specification">Input Specification:</h3>
<p>Each input file contains one test case. For each case, the first line contains three positive numbers: <em>N</em> (≤105), the total number of the members in the supply chain (and hence their ID's are numbered from 0 to <em>N</em>−1, and the root supplier's ID is 0); <em>P</em>, the unit price given by the root supplier; and <em>r</em>, the percentage rate of price increment for each distributor or retailer. Then <em>N</em> lines follow, each describes a distributor or retailer in the following format:</p>
<p><em>K**i</em> ID[1] ID[2] ... ID[<em>K**i</em>]</p>
<p>where in the <em>i</em>-th line, <em>K**i</em> is the total number of distributors or retailers who receive products from supplier <em>i</em>, and is then followed by the ID's of these distributors or retailers. <em>K**j</em> being 0 means that the <em>j</em>-th member is a retailer, then instead the total amount of the product will be given after <em>K**j</em>. All the numbers in a line are separated by a space.</p>
<h3 id="output-specification">Output Specification:</h3>
<p>For each test case, print in one line the total sales we can expect from all the retailers, accurate up to 1 decimal place. It is guaranteed that the number will not exceed 1010.</p>
<h3 id="sample-input">Sample Input:</h3>
<pre><code class="language-in">10 1.80 1.00
3 2 3 5
1 9
1 4
1 7
0 7
2 6 1
1 8
0 9
0 4
0 3
</code></pre>
<h3 id="sample-output">Sample Output:</h3>
<pre><code class="language-out">42.4
</code></pre>
<hr>
<p>题目描述：有一条销售链，供应商、经销商、零售商，供应商提供货物给经销商，经销商提供货物给零售商，题目要求出零售商售出的总额是多少。0号索引表示供应商。供应商的售价p，经销商的售价p1 = r%*p，零售商售价p2 = r%*p1。</p>
</br>
<p>输入：第一行三个数，n为节点数，p为商品原价，即供应商的出价，r为售价的增幅。接下来n行（表示0~n-1个结点的情况），分两种情况</p>
<p>1)第一个值为0，第二个值就表示零售商需要销售商品的数量</p>
<p>2)第一个值不为0，则第一个值表示第i个结点的子结点个数m，后面接着m个子结点的编号。</p>
<p>输出：零售商售出的总额，保留一位小数</p>
</br>
<p>解题思路：典型的bfs题，使用邻接表存树，节约空间。</p>
<p>注意，题目给的是r，我们计算时要计算r%，所以r*1.0/100。</p>
<hr>
<pre><code class="language-c++">#include&lt;bits/stdc++.h&gt;
using namespace std;
int n;
double p, r;
const int maxn = 200005;
vector&lt;int&gt; G[maxn];
map&lt;int,int&gt; lvs_sell;
struct node{
	int index;
	double price;
};
void bfs(){
	node t, tt;
	t.index = 0; t.price = p;
	queue&lt;node&gt; q;
	q.push(t);
	double ans = 0;
	while(!q.empty()){
		t = q.front();
		q.pop();
		if(G[t.index].size()==0){
			ans += lvs_sell[t.index]*t.price;
		}
		else{
			for(int i=0; i&lt;G[t.index].size(); i++){
				int v = G[t.index][i];
				tt.index = v;
				tt.price = r*t.price;
				q.push(tt);
			}
		}
	}
	printf(&quot;%.1f&quot;, ans);
}
int main()
{
	scanf(&quot;%d %lf %lf&quot;, &amp;n, &amp;p, &amp;r);
	r = r*1.0/100 + 1;
	int a, b;
	for(int i=0; i&lt;n; i++){
		scanf(&quot;%d %d&quot;, &amp;a, &amp;b);
		if(a==0) lvs_sell[i] = b;
		else{
			G[i].push_back(b);
			for(int j=1; j&lt;a; j++){
				scanf(&quot;%d&quot;, &amp;b);
				G[i].push_back(b);
			}
		}
	}
	bfs();
	return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[1078 Hashing (25分)题解]]></title>
        <id>https://ygytl.github.io/post/1078-hashing-25-fen-ti-jie/</id>
        <link href="https://ygytl.github.io/post/1078-hashing-25-fen-ti-jie/">
        </link>
        <updated>2020-06-06T02:29:52.000Z</updated>
        <content type="html"><![CDATA[<p>1078 Hashing (25分)</p>
<p>The task of this problem is simple: insert a sequence of distinct positive integers into a hash table, and output the positions of the input numbers. The hash function is defined to be <em>H</em>(<em>k<strong>e</strong>y</em>)=<em>k<strong>e</strong>y</em>%<em>T<strong>S</strong>i<strong>z</strong>e</em> where <em>T<strong>S</strong>i<strong>z</strong>e</em> is the maximum size of the hash table. Quadratic probing (with positive increments only) is used to solve the collisions.</p>
<p>Note that the table size is better to be prime. If the maximum size given by the user is not prime, you must re-define the table size to be the smallest prime number which is larger than the size given by the user.</p>
<h3 id="input-specification">Input Specification:</h3>
<p>Each input file contains one test case. For each case, the first line contains two positive numbers: <em>M<strong>S</strong>i<strong>z</strong>e</em> (≤104) and <em>N</em> (≤<em>M<strong>S</strong>i<strong>z</strong>e</em>) which are the user-defined table size and the number of input numbers, respectively. Then <em>N</em> distinct positive integers are given in the next line. All the numbers in a line are separated by a space.</p>
<h3 id="output-specification">Output Specification:</h3>
<p>For each test case, print the corresponding positions (index starts from 0) of the input numbers in one line. All the numbers in a line are separated by a space, and there must be no extra space at the end of the line. In case it is impossible to insert the number, print &quot;-&quot; instead.</p>
<h3 id="sample-input">Sample Input:</h3>
<pre><code class="language-in">4 4
10 6 4 15
</code></pre>
<h3 id="sample-output">Sample Output:</h3>
<pre><code class="language-out">0 1 4 -
</code></pre>
<hr>
<p>题目描述：把哈希表实现出来。</p>
</br>
<p>输入：Msize数组长度，n插入值得个数</p>
<p>输出：插入每个值得位置</p>
</br>
<p>解题思路：Quadratic probing (with positive increments only) is used to solve the collisions.</p>
<p>这句话是重点，必须理解，Quadratic二次方，probe探测，collision冲突；遇到冲突使用二次探测存放！</p>
<p>二次探测公式：H(Key) = (Key + i*i)  (i=0....n-1)</p>
<p>解这道题，因为哈希表得的长度规定选为素数，所以，当Msize不为素数，需要将大于Msize的最小素数求出，可以用一个数组先将素数表存好，方便查询。然后把二次探测公式实现就行了。</p>
<hr>
<pre><code class="language-c++">#include&lt;bits/stdc++.h&gt;
using namespace std;
const int maxn = 20005;
vector&lt;int&gt; prime;
int p[maxn];
bool is_prime(int k){
	if(k==0||k==1) return false;
	for(int i=2; i&lt;=sqrt(k); i++){
		if(k%i==0) return false;
	}
	return true;
}
int find_prime(int k){
	for(int i=0; i&lt;prime.size(); i++){
		if(prime[i]&gt;k) return prime[i];
	}
	return 0;
}
int main()
{
	memset(p,-1,sizeof(p));
	prime.push_back(2);
	for(int i=3; i&lt;=maxn; i+=2){
		if(is_prime(i)) prime.push_back(i);
	}
	int n, m;
	long long k;
	scanf(&quot;%d %d&quot;, &amp;n, &amp;m);
	if(!is_prime(n)) n = find_prime(n);
	
	for(int i=0; i&lt;m; i++){
		scanf(&quot;%lld&quot;, &amp;k);
		if(i) printf(&quot; &quot;);
		int g = k%n, c=0;
		while(p[g]!=-1&amp;&amp;c&lt;n){
			c++;
			g = (k+c*c)%n;
		}
		if(p[g]!=-1) printf(&quot;-&quot;);
		else{
			p[g%n] = g%n;
			printf(&quot;%d&quot;, g%n);
		}
	}
	return 0;
}
</code></pre>
]]></content>
    </entry>
</feed>