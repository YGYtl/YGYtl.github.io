<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://ygytl.github.io/</id>
    <title>Grace</title>
    <updated>2020-07-20T13:39:36.624Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://ygytl.github.io/"/>
    <link rel="self" href="https://ygytl.github.io/atom.xml"/>
    <subtitle>Grace&apos;s blog</subtitle>
    <logo>https://ygytl.github.io/images/avatar.png</logo>
    <icon>https://ygytl.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, Grace</rights>
    <entry>
        <title type="html"><![CDATA[7-1 Good in C (20分)题解]]></title>
        <id>https://ygytl.github.io/post/7-1-good-in-c-20-fen-ti-jie/</id>
        <link href="https://ygytl.github.io/post/7-1-good-in-c-20-fen-ti-jie/">
        </link>
        <updated>2020-07-20T13:39:04.000Z</updated>
        <content type="html"><![CDATA[<p>7-1 Good in C (20分)</p>
<p>When your interviewer asks you to write &quot;Hello World&quot; using C, can you do as the following figure shows?</p>
<figure data-type="image" tabindex="1"><img src="https://images.ptausercontent.com/ba3b8678-061d-4fc6-a87e-ce08e1434410.jpg" alt="HWC.jpg" loading="lazy"></figure>
<h3 id="input-specification">Input Specification:</h3>
<p>Each input file contains one test case. For each case, the first part gives the 26 capital English letters A-Z, each in a 7×5 matrix of <code>C</code>'s and <code>.</code>'s. Then a sentence is given in a line, ended by a return. The sentence is formed by several words (no more than 10 continuous capital English letters each), and the words are separated by any characters other than capital English letters.</p>
<p>It is guaranteed that there is at least one word given.</p>
<h3 id="output-specification">Output Specification:</h3>
<p>For each word, print the matrix form of each of its letters in a line, and the letters must be separated by exactly one column of space. There must be no extra space at the beginning or the end of the word.</p>
<p>Between two adjacent words, there must be a single empty line to separate them. There must be no extra line at the beginning or the end of the output.</p>
<h3 id="sample-input">Sample Input:</h3>
<pre><code class="language-in">..C..
.C.C.
C...C
CCCCC
C...C
C...C
C...C
CCCC.
C...C
C...C
CCCC.
C...C
C...C
CCCC.
.CCC.
C...C
C....
C....
C....
C...C
.CCC.
CCCC.
C...C
C...C
C...C
C...C
C...C
CCCC.
CCCCC
C....
C....
CCCC.
C....
C....
CCCCC
CCCCC
C....
C....
CCCC.
C....
C....
C....
CCCC.
C...C
C....
C.CCC
C...C
C...C
CCCC.
C...C
C...C
C...C
CCCCC
C...C
C...C
C...C
CCCCC
..C..
..C..
..C..
..C..
..C..
CCCCC
CCCCC
....C
....C
....C
....C
C...C
.CCC.
C...C
C..C.
C.C..
CC...
C.C..
C..C.
C...C
C....
C....
C....
C....
C....
C....
CCCCC
C...C
C...C
CC.CC
C.C.C
C...C
C...C
C...C
C...C
C...C
CC..C
C.C.C
C..CC
C...C
C...C
.CCC.
C...C
C...C
C...C
C...C
C...C
.CCC.
CCCC.
C...C
C...C
CCCC.
C....
C....
C....
.CCC.
C...C
C...C
C...C
C.C.C
C..CC
.CCC.
CCCC.
C...C
CCCC.
CC...
C.C..
C..C.
C...C
.CCC.
C...C
C....
.CCC.
....C
C...C
.CCC.
CCCCC
..C..
..C..
..C..
..C..
..C..
..C..
C...C
C...C
C...C
C...C
C...C
C...C
.CCC.
C...C
C...C
C...C
C...C
C...C
.C.C.
..C..
C...C
C...C
C...C
C.C.C
CC.CC
C...C
C...C
C...C
C...C
.C.C.
..C..
.C.C.
C...C
C...C
C...C
C...C
.C.C.
..C..
..C..
..C..
..C..
CCCCC
....C
...C.
..C..
.C...
C....
CCCCC
HELLO~WORLD!
</code></pre>
<h3 id="sample-output">Sample Output:</h3>
<pre><code class="language-out">C...C CCCCC C.... C.... .CCC.
C...C C.... C.... C.... C...C
C...C C.... C.... C.... C...C
CCCCC CCCC. C.... C.... C...C
C...C C.... C.... C.... C...C
C...C C.... C.... C.... C...C
C...C CCCCC CCCCC CCCCC .CCC.

C...C .CCC. CCCC. C.... CCCC.
C...C C...C C...C C.... C...C
C...C C...C CCCC. C.... C...C
C.C.C C...C CC... C.... C...C
CC.CC C...C C.C.. C.... C...C
C...C C...C C..C. C.... C...C
C...C .CCC. C...C CCCCC CCCC.
</code></pre>
<hr>
<p>题目描述：</p>
<p>输入：前面26*7行给出A-Z的字母输出格式，每7行为一个字母；最后一行是需要按格式输出的字符串。单词由不是A~Z的字符分隔。</p>
<p>输出：每个单词占7行，单词的字母中间用一个空格隔开。输出严格按照规定，最后一行不需输出空行。</p>
</br>
<p>解题思路：先将每个字母的输出格式存入字符数组，以便查找。在使用getline()接收需要分割的字符串----这点严重警告，否则测试点1、2、3会显示错误，如果不用getline接收，当遇到空格字符串就不能完整接收。需要算好在哪里空行！不能多不能少，太严格了。。</p>
<hr>
<pre><code class="language-c++">#include&lt;bits/stdc++.h&gt;
using namespace std;
string str[200];
string s;
int main()
{
	for(int i=0; i&lt;182; i++) cin &gt;&gt; str[i];
	getchar();
	getline(cin,s);
	string t = &quot;&quot;;
	bool flag = false;
	for(int i=0; i&lt;s.length(); i++){
		if(s[i]&gt;'Z'||s[i]&lt;'A'){
			if(t.length()&gt;0){
				if(flag==true) cout &lt;&lt; endl;
				for(int o2=0; o2&lt;7; o2++){
					for(int o1=0; o1&lt;t.length(); o1++){
						int k = t[o1]-'A';
						if(o1) cout &lt;&lt; &quot; &quot;;
						cout &lt;&lt; str[k*7+o2];
					}
					cout &lt;&lt; endl;
				}
				t = &quot;&quot;;
				flag = true;
			}
		}
		else{
			t += s[i];
		}
	}
	if(t.length()!=0){
		if(flag==true) cout &lt;&lt; endl;
		for(int o2=0; o2&lt;7; o2++){
			for(int o1=0; o1&lt;t.length(); o1++){
				int k = t[o1]-'A';
				if(o1) cout &lt;&lt; &quot; &quot;;
				cout &lt;&lt; str[k*7+o2];
			}
			cout &lt;&lt; endl;
		}
	}
	return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[1135 Is It A Red-Black Tree (30分)题解]]></title>
        <id>https://ygytl.github.io/post/1135-is-it-a-red-black-tree-30-fen-ti-jie/</id>
        <link href="https://ygytl.github.io/post/1135-is-it-a-red-black-tree-30-fen-ti-jie/">
        </link>
        <updated>2020-07-11T08:28:20.000Z</updated>
        <content type="html"><![CDATA[<p>1135 Is It A Red-Black Tree (30分)</p>
<p>There is a kind of balanced binary search tree named <strong>red-black tree</strong> in the data structure. It has the following 5 properties:</p>
<ul>
<li>(1) Every node is either red or black.</li>
<li>(2) The root is black.</li>
<li>(3) Every leaf (NULL) is black.</li>
<li>(4) If a node is red, then both its children are black.</li>
<li>(5) For each node, all simple paths from the node to descendant leaves contain the same number of black nodes.</li>
</ul>
<p>For example, the tree in Figure 1 is a red-black tree, while the ones in Figure 2 and 3 are not.</p>
<table>
<thead>
<tr>
<th style="text-align:center"><img src="https://images.ptausercontent.com/eff80bd4-c833-4818-9786-81680d1b304a.jpg" alt="rbf1.jpg" loading="lazy"></th>
<th style="text-align:center"><img src="https://images.ptausercontent.com/b11184df-eaab-451c-b7d4-7fc1dc82b028.jpg" alt="rbf2.jpg" loading="lazy"></th>
<th style="text-align:center"><img src="https://images.ptausercontent.com/625c532b-22fc-47b9-80ea-0537cf00d922.jpg" alt="rbf3.jpg" loading="lazy"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Figure 1</td>
<td style="text-align:center">Figure 2</td>
<td style="text-align:center">Figure 3</td>
</tr>
</tbody>
</table>
<p>For each given binary search tree, you are supposed to tell if it is a legal red-black tree.</p>
<h3 id="input-specification">Input Specification:</h3>
<p>Each input file contains several test cases. The first line gives a positive integer K (≤30) which is the total number of cases. For each case, the first line gives a positive integer N (≤30), the total number of nodes in the binary tree. The second line gives the preorder traversal sequence of the tree. While all the keys in a tree are positive integers, we use negative signs to represent red nodes. All the numbers in a line are separated by a space. The sample input cases correspond to the trees shown in Figure 1, 2 and 3.</p>
<h3 id="output-specification">Output Specification:</h3>
<p>For each test case, print in a line &quot;Yes&quot; if the given tree is a red-black tree, or &quot;No&quot; if not.</p>
<h3 id="sample-input">Sample Input:</h3>
<pre><code class="language-in">3
9
7 -2 1 5 -4 -11 8 14 -15
9
11 -2 1 -7 5 -4 8 14 -15
8
10 -7 5 -6 8 15 -11 17
</code></pre>
<h3 id="sample-output">Sample Output:</h3>
<pre><code class="language-out">Yes
No
No
</code></pre>
<hr>
<p>题目描述：红黑树是一个二叉搜索树，根节点的值大于左子结点，根节点的值小于或等于右子节点的值。红黑树的特点如下：</p>
<p>1)每一个结点由红色或黑色组成</p>
<p>2)根节点为黑色</p>
<p>3)每个叶子节点(NULL)都为黑色</p>
<p>4)如果节点为红色，那他的两个子结点必须为黑色</p>
<p>5)根节点到每个子结点的路径中，黑色子结点的个数都要相同</p>
<p>输入：第一行k为测试用例数，往下有k组；每组第一行n为结点总数，每组第二行有n个数，表示需要插入的结点的值，正整数为黑色，负整数为红色。</p>
<p>输出：输出是否能构成红黑树，是为Yes，否为No。</p>
</br>
<p>解题思路：先构建一个红黑树，将题目给定的值依序插入就能将二叉搜索树构建出来，我是通过递归的方法构建的。树构建完成后，用BFS遍历每个结点，检查是否符合红黑树的特性。</p>
<p>注意：题目给出的结点值都不是叶子结点，叶子节点没有值为NULL，这是个坑，没注意到测试点2、3就会错。</p>
<hr>
<pre><code class="language-c++">#include&lt;bits/stdc++.h&gt;
using namespace std;
int n, m, cnt;
bool flag;
struct node{
	int num;
	node *l, *r;
	node(){
		l = r = NULL;
	}
};
node *Insert(node *root, int k){
	if(root==NULL){
		root = new node();
		root-&gt;num = k;
		root-&gt;l = root-&gt;r = NULL;
	}
	else if(abs(k)&gt;=abs(root-&gt;num)){
		root-&gt;r = Insert(root-&gt;r,k);
	}
	else root-&gt;l = Insert(root-&gt;l,k);
	return root;
}
void bfs(node *root){
	pair&lt;node*,int&gt; t, tt;
	node *troot;
	queue&lt;pair&lt;node*,int&gt;&gt; q;
	t.first = root; t.second = 0;
	q.push(t);
	while(!q.empty()&amp;&amp;flag){
		t = q.front(); q.pop();
		troot = t.first;
		if(troot==NULL){
			t.second++;
			if(cnt==-1) cnt = t.second;
			if(cnt!=t.second) flag = false;
			continue;
		}
		if(troot-&gt;num&gt;0) t.second++;
		
		if(troot-&gt;l!=NULL&amp;&amp;troot-&gt;num&lt;0&amp;&amp;troot-&gt;l-&gt;num&lt;0) flag = false;
		tt.first = troot-&gt;l; tt.second = t.second;
		q.push(tt);
		
		if(troot-&gt;r!=NULL&amp;&amp;troot-&gt;num&lt;0&amp;&amp;troot-&gt;r-&gt;num&lt;0) flag = false;
		tt.first = troot-&gt;r; tt.second = t.second;
		q.push(tt);
	}
}
int main()
{
	int k;
	scanf(&quot;%d&quot;, &amp;n);
	for(int i=0; i&lt;n; i++){
		scanf(&quot;%d&quot;, &amp;m);
		node *tree = NULL;
		for(int j=0; j&lt;m; j++){
			scanf(&quot;%d&quot;, &amp;k);
			tree = Insert(tree,k);
		}
		flag = true;
		cnt = -1;
		if(tree-&gt;num&lt;0) flag = false;
		else bfs(tree);
		if(flag) printf(&quot;Yes\n&quot;);
		else printf(&quot;No\n&quot;);
	}
	return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[1130 Infix Expression (25分)题解]]></title>
        <id>https://ygytl.github.io/post/1130-infix-expression-25-fen-ti-jie/</id>
        <link href="https://ygytl.github.io/post/1130-infix-expression-25-fen-ti-jie/">
        </link>
        <updated>2020-07-09T14:06:17.000Z</updated>
        <content type="html"><![CDATA[<p>1130 Infix Expression (25分)</p>
<p>Given a syntax tree (binary), you are supposed to output the corresponding infix expression, with parentheses reflecting the precedences of the operators.</p>
<h3 id="input-specification">Input Specification:</h3>
<p>Each input file contains one test case. For each case, the first line gives a positive integer N (≤ 20) which is the total number of nodes in the syntax tree. Then N lines follow, each gives the information of a node (the <em>i</em>-th line corresponds to the <em>i</em>-th node) in the format:</p>
<pre><code>data left_child right_child
</code></pre>
<p>where <code>data</code> is a string of no more than 10 characters, <code>left_child</code> and <code>right_child</code> are the indices of this node's left and right children, respectively. The nodes are indexed from 1 to N. The NULL link is represented by −1. The figures 1 and 2 correspond to the samples 1 and 2, respectively.</p>
<table>
<thead>
<tr>
<th style="text-align:center"><img src="https://images.ptausercontent.com/4d1c4a98-33cc-45ff-820f-c548845681ba.JPG" alt="infix1.JPG" loading="lazy"></th>
<th style="text-align:center"><img src="https://images.ptausercontent.com/b5a3c36e-91ad-494a-8853-b46e1e8b60cc.JPG" alt="infix2.JPG" loading="lazy"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Figure 1</td>
<td style="text-align:center">Figure 2</td>
</tr>
</tbody>
</table>
<h3 id="output-specification">Output Specification:</h3>
<p>For each case, print in a line the infix expression, with parentheses reflecting the precedences of the operators. Note that there must be no extra parentheses for the final expression, as is shown by the samples. There must be no space between any symbols.</p>
<h3 id="sample-input-1">Sample Input 1:</h3>
<pre><code class="language-in">8
* 8 7
a -1 -1
* 4 1
+ 2 5
b -1 -1
d -1 -1
- -1 6
c -1 -1
</code></pre>
<h3 id="sample-output-1">Sample Output 1:</h3>
<pre><code class="language-out">(a+b)*(c*(-d))
</code></pre>
<h3 id="sample-input-2">Sample Input 2:</h3>
<pre><code class="language-in">8
2.35 -1 -1
* 6 1
- -1 4
% 7 8
+ 2 3
a -1 -1
str -1 -1
871 -1 -1
</code></pre>
<h3 id="sample-output-2">Sample Output 2:</h3>
<pre><code class="language-out">(a*2.35)+(-(str%871))
</code></pre>
<hr>
<p>题目描述：二叉树，以算式格式输出。</p>
<p>输入：第一行n为节点数，接下来n行，表示第i个结点的值、左右节点编号。</p>
<p>输出：算式格式输出。</p>
</br>
<p>解题方法：题目没有给出根节点的编号，所以需要先求出根节点编号；得到树的中序遍历，之后得到算式还难吗？</p>
<hr>
<p>方法一：</p>
<pre><code class="language-c++">#include&lt;bits/stdc++.h&gt;
using namespace std;
int n;
const int maxn = 100;
string ans=&quot;&quot;;
struct node{
	string ch;
	int l, r;
};
vector&lt;node&gt; tree(maxn);
bool vis[maxn];
void bfs(int index){
	queue&lt;int&gt; q;
	q.push(index);
	while(!q.empty()){
		int u = q.front(); q.pop();
		vis[u] = true;
		node t = tree[u];
		if(t.l!=-1) q.push(t.l);
		if(t.r!=-1) q.push(t.r);
	}
}
void get_inorder(int index, int g){
	if(index==-1) return ;
	node t = tree[index];
	if(tree[index].r!=-1&amp;&amp;g&gt;1) ans += &quot;(&quot;;
	get_inorder(t.l,g+1);
	ans += t.ch;
	get_inorder(t.r,g+1);
	if(tree[index].r!=-1&amp;&amp;g&gt;1) ans += &quot;)&quot;;
}
int main()
{
	scanf(&quot;%d&quot;, &amp;n);
	int root;
	for(int i=1; i&lt;=n; i++){
		getchar();
		node t;
		cin &gt;&gt; t.ch &gt;&gt; t.l &gt;&gt; t.r;
		tree[i] = t;
	}
	for(int i=1; i&lt;=n; i++){
		memset(vis,false,sizeof(vis));
		bfs(i);
		bool flag = true;
		for(int j=1; j&lt;=n; j++){
			if(vis[j]==false){
				flag = false;
				break;
			}
		}
		if(flag){
			root = i;
			break;
		}
	}
	get_inorder(root,1);
	cout &lt;&lt; ans &lt;&lt; endl;
	return 0;
}
</code></pre>
<p>方法二：</p>
<pre><code class="language-c++">#include&lt;bits/stdc++.h&gt;
using namespace std;
int n;
const int maxn = 100;
string ans=&quot;&quot;;
struct node{
	string ch;
	int l, r;
};
vector&lt;node&gt; tree(maxn);
bool vis[maxn];
void get_inorder(int index, int g){
	if(index==-1) return ;
	node t = tree[index];
	if(tree[index].r!=-1&amp;&amp;g&gt;1) ans += &quot;(&quot;;
	get_inorder(t.l,g+1);
	ans += t.ch;
	get_inorder(t.r,g+1);
	if(tree[index].r!=-1&amp;&amp;g&gt;1) ans += &quot;)&quot;;
}
int main()
{
	scanf(&quot;%d&quot;, &amp;n);
	int root;
	memset(vis,false,sizeof(vis));
	for(int i=1; i&lt;=n; i++){
		getchar();
		node t;
		cin &gt;&gt; t.ch &gt;&gt; t.l &gt;&gt; t.r;
		tree[i] = t;
		if(t.l!=-1) vis[t.l] = true;
		if(t.r!=-1) vis[t.r] = true;
	}
	for(int i=1; i&lt;=n; i++){
		if(vis[i]==false){
			root = i;
			break;
		}
	}
	get_inorder(root,1);
	cout &lt;&lt; ans &lt;&lt; endl;
	return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[1129 Recommendation System (25分)题解]]></title>
        <id>https://ygytl.github.io/post/1129-recommendation-system-25-fen-ti-jie/</id>
        <link href="https://ygytl.github.io/post/1129-recommendation-system-25-fen-ti-jie/">
        </link>
        <updated>2020-07-09T12:31:41.000Z</updated>
        <content type="html"><![CDATA[<p>1129 Recommendation System (25分)</p>
<p>Recommendation system predicts the preference that a user would give to an item. Now you are asked to program a very simple recommendation system that rates the user's preference by the number of times that an item has been accessed by this user.</p>
<h3 id="input-specification">Input Specification:</h3>
<p>Each input file contains one test case. For each test case, the first line contains two positive integers: N (≤ 50,000), the total number of queries, and K (≤ 10), the maximum number of recommendations the system must show to the user. Then given in the second line are the indices of items that the user is accessing -- for the sake of simplicity, all the items are indexed from 1 to N. All the numbers in a line are separated by a space.</p>
<h3 id="output-specification">Output Specification:</h3>
<p>For each case, process the queries one by one. Output the recommendations for each query in a line in the format:</p>
<pre><code>query: rec[1] rec[2] ... rec[K]
</code></pre>
<p>where <code>query</code> is the item that the user is accessing, and <code>rec[i]</code> (<code>i</code>=1, ... K) is the <code>i</code>-th item that the system recommends to the user. The first K items that have been accessed most frequently are supposed to be recommended in non-increasing order of their frequencies. If there is a tie, the items will be ordered by their indices in increasing order.</p>
<p>Note: there is no output for the first item since it is impossible to give any recommendation at the time. It is guaranteed to have the output for at least one query.</p>
<h3 id="sample-input">Sample Input:</h3>
<pre><code class="language-in">12 3
3 5 7 5 5 3 2 1 8 3 8 12
</code></pre>
<h3 id="sample-output">Sample Output:</h3>
<pre><code class="language-out">5: 3
7: 3 5
5: 3 5 7
5: 5 3 7
3: 5 3 7
2: 5 3 7
1: 5 3 2
8: 5 3 1
3: 5 3 1
8: 3 5 1
12: 3 5 8
</code></pre>
<hr>
<p>题目描述：更新推荐系统。</p>
<p>输入描述：第一行n为推荐数，m为最多推荐个数。第二行有m个值，为每次推荐的编号。</p>
<p>输出描述：输出此次推荐编号之前的排序，例如样例，第一个推荐编号为3，第二个推荐编号为5，应该从5开始输出它前面最优的推荐。</p>
<p>系统推荐排序规则：推荐次数多的排在前面，若推荐次数相同，则按编号从小到大排序。</p>
</br>
<p>测试点3、4容易超时，要找准遍历目标。</p>
<hr>
<pre><code class="language-c++">#include&lt;bits/stdc++.h&gt;
using namespace std;
int n, m, k;
map&lt;int,int&gt; p, pid;
struct node{
	int num, cnt = 0;
};
vector&lt;node&gt; G;
bool cmp(node a, node b){
	if(a.cnt!=b.cnt) return a.cnt &gt; b.cnt;//降序 
	else return a.num &lt; b.num;//升序 
}
int main()
{
	map&lt;int,int&gt;::iterator it;
	scanf(&quot;%d %d&quot;, &amp;n, &amp;m);
	for(int i=0; i&lt;n; i++){
		scanf(&quot;%d&quot;, &amp;k);
		pid[k] = i;
		node t;
		if(i){
			printf(&quot;%d:&quot;, k);
			for(int j=0; j&lt;m&amp;&amp;j&lt;G.size(); j++){
				printf(&quot; %d&quot;, G[j].num);
			}
			printf(&quot;\n&quot;);
		}
		p[k]++;
		t.num = k; t.cnt = p[k];
		bool flag = true;
		for(int j=0; j&lt;G.size(); j++){
			if(G[j].num==k){
				G[j].cnt = t.cnt;
				flag = false;
				break;
			}
		}
		if(flag) G.push_back(t);
		sort(G.begin(),G.end(),cmp);
		if(G.size()&gt;m) G.pop_back();
	}
	return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[1127 ZigZagging on a Tree (30分)题解]]></title>
        <id>https://ygytl.github.io/post/1127-zigzagging-on-a-tree-30-fen-ti-jie/</id>
        <link href="https://ygytl.github.io/post/1127-zigzagging-on-a-tree-30-fen-ti-jie/">
        </link>
        <updated>2020-07-08T14:14:46.000Z</updated>
        <content type="html"><![CDATA[<p>1127 ZigZagging on a Tree (30分)</p>
<p>Suppose that all the keys in a binary tree are distinct positive integers. A unique binary tree can be determined by a given pair of postorder and inorder traversal sequences. And it is a simple standard routine to print the numbers in level-order. However, if you think the problem is too simple, then you are too naive. This time you are supposed to print the numbers in &quot;zigzagging order&quot; -- that is, starting from the root, print the numbers level-by-level, alternating between left to right and right to left. For example, for the following tree you must output: 1 11 5 8 17 12 20 15.</p>
<figure data-type="image" tabindex="1"><img src="https://images.ptausercontent.com/337cbfb0-a7b2-4500-9664-318e9ffc870e.jpg" alt="zigzag.jpg" loading="lazy"></figure>
<h3 id="input-specification">Input Specification:</h3>
<p>Each input file contains one test case. For each case, the first line gives a positive integer N (≤30), the total number of nodes in the binary tree. The second line gives the inorder sequence and the third line gives the postorder sequence. All the numbers in a line are separated by a space.</p>
<h3 id="output-specification">Output Specification:</h3>
<p>For each test case, print the zigzagging sequence of the tree in a line. All the numbers in a line must be separated by exactly one space, and there must be no extra space at the end of the line.</p>
<h3 id="sample-input">Sample Input:</h3>
<pre><code class="language-in">8
12 11 20 17 1 15 8 5
12 20 17 11 15 8 5 1
</code></pre>
<h3 id="sample-output">Sample Output:</h3>
<pre><code class="language-out">1 11 5 8 17 12 20 15
</code></pre>
<hr>
<p>题目描述：已知中序遍历和后序遍历可以得到唯一的二叉树；已知中序遍历和先序遍历，可以得到唯一的二叉树。现在题目给出中序和后序遍历，需要求出层序遍历的结果。但是这个层序遍历需要按照Z字行输出。</p>
</br>
<p>解题思路：不需要建树，递归就能得到层序遍历的结果。1086题解解释了已知先序遍历和中序遍历，求后序遍历的结果，思路与这题差不多，可以参考。</p>
<hr>
<pre><code class="language-c++">#include&lt;bits/stdc++.h&gt;
using namespace std;
int n, cnt;
const int maxn = 1e4+5;
vector&lt;int&gt; inorder, post;
vector&lt;int&gt; level[maxn];
void get_level(int root, int inl, int inr, int index){
	if(inl&gt;inr) return ;
	int i = inl;
	cnt = index;
	level[index].push_back(post[root]);
	while(i&lt;=inr&amp;&amp;inorder[i]!=post[root]) i++;
	get_level(root-(inr-i+1),inl,i-1,index+1);
	get_level(root-1,i+1,inr,index+1);
}
int main()
{
	scanf(&quot;%d&quot;, &amp;n);
	inorder.resize(n);
	post.resize(n);
	for(int i=0; i&lt;n; i++) scanf(&quot;%d&quot;, &amp;inorder[i]);
	for(int i=0; i&lt;n; i++) scanf(&quot;%d&quot;, &amp;post[i]);
	get_level(n-1,0,n-1,1);
	for(int i=1; i&lt;=cnt; i++){
		if(i%2==0){
			for(int j=0; j&lt;level[i].size(); j++){
				if(i!=1) printf(&quot; &quot;);
				printf(&quot;%d&quot;, level[i][j]);
			}
		}
		else{
			for(int j=level[i].size()-1; j&gt;=0; j--){
				if(i!=1) printf(&quot; &quot;);
				printf(&quot;%d&quot;, level[i][j]);
			}
		}
	}
	return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[1123 Is It a Complete AVL Tree (30分)题解]]></title>
        <id>https://ygytl.github.io/post/1123-is-it-a-complete-avl-tree-30-fen-ti-jie/</id>
        <link href="https://ygytl.github.io/post/1123-is-it-a-complete-avl-tree-30-fen-ti-jie/">
        </link>
        <updated>2020-07-07T14:24:07.000Z</updated>
        <content type="html"><![CDATA[<p>1123 Is It a Complete AVL Tree (30分)</p>
<p>An AVL tree is a self-balancing binary search tree. In an AVL tree, the heights of the two child subtrees of any node differ by at most one; if at any time they differ by more than one, rebalancing is done to restore this property. Figures 1-4 illustrate the rotation rules.</p>
<figure data-type="image" tabindex="1"><img src="https://ygytl.github.io//post-images/1594132084359.JPG" alt="" loading="lazy"></figure>
<p>Now given a sequence of insertions, you are supposed to output the level-order traversal sequence of the resulting AVL tree, and to tell if it is a complete binary tree.</p>
<h3 id="input-specification">Input Specification:</h3>
<p>Each input file contains one test case. For each case, the first line contains a positive integer N (≤ 20). Then N distinct integer keys are given in the next line. All the numbers in a line are separated by a space.</p>
<h3 id="output-specification">Output Specification:</h3>
<p>For each test case, insert the keys one by one into an initially empty AVL tree. Then first print in a line the level-order traversal sequence of the resulting AVL tree. All the numbers in a line must be separated by a space, and there must be no extra space at the end of the line. Then in the next line, print <code>YES</code> if the tree is complete, or <code>NO</code> if not.</p>
<h3 id="sample-input-1">Sample Input 1:</h3>
<pre><code class="language-in">5
88 70 61 63 65
</code></pre>
<h3 id="sample-output-1">Sample Output 1:</h3>
<pre><code class="language-out">70 63 88 61 65
YES
</code></pre>
<h3 id="sample-input-2">Sample Input 2:</h3>
<pre><code class="language-in">8
88 70 61 96 120 90 65 68
</code></pre>
<h3 id="sample-output-2">Sample Output 2:</h3>
<pre><code class="language-out">88 65 96 61 70 90 120 68
NO
</code></pre>
<hr>
<p>题目描述：完全平衡二叉树。具体参考1066的题解</p>
<p>该题需要建树，判断是否能形成完全平衡二叉树，是输出YES，否输出NO。还要输出树的层序遍历。</p>
</br>
<p>解题思路：建树，完成左转、右转、左右转、右左转的操作、求结点的高度等，最后利用BFS得到层序遍历。</p>
<hr>
<pre><code class="language-c++">#include&lt;bits/stdc++.h&gt;
using namespace std;
int n, k;
vector&lt;int&gt; level;
struct node{
	int num;
	node *l, *r;
	node(){
		l = r = NULL;
	}
};
node *LeftRoute(node *root){
	node *t;
	t = root-&gt;r;
	root-&gt;r = t-&gt;l;
	t-&gt;l = root;
	return t;
}
node *RightRoute(node *root){
	node *t;
	t = root-&gt;l;
	root-&gt;l = t-&gt;r;
	t-&gt;r = root;
	return t;
}
node *LeftRightRoute(node *root){
	root-&gt;l = LeftRoute(root-&gt;l);
	root = RightRoute(root);
	return root;
}
node *RightLeftRoute(node *root){
	root-&gt;r = RightRoute(root-&gt;r);
	root = LeftRoute(root);
	return root;
}
int height(node *root){
	if(root==NULL) return 1;
	return max(height(root-&gt;l),height(root-&gt;r))+1;
}
node *Insert(node *root, int k){
	if(root==NULL){
		root = new node();
		root-&gt;num = k;
		root-&gt;l = root-&gt;r = NULL;
	}
	else if(k&gt;=root-&gt;num){
		root-&gt;r = Insert(root-&gt;r,k);
		if(abs(height(root-&gt;r)-height(root-&gt;l))&gt;=2){
			root = k&gt;=root-&gt;r-&gt;num ? LeftRoute(root) : RightLeftRoute(root);
		}
	}
	else{
		root-&gt;l = Insert(root-&gt;l,k);
		if(abs(height(root-&gt;l)-height(root-&gt;r))&gt;=2){
			root = k&lt;=root-&gt;l-&gt;num ? RightRoute(root) : LeftRightRoute(root);
		}
	}
	return root;
}
void bfs(node *root){
	pair&lt;node *, int&gt; t, tt;
	queue&lt;pair&lt;node *, int&gt; &gt; q;
	t.first = root; t.second = 1;
	q.push(t);
	bool flag = true;
	int cnt = 1;
	while(!q.empty()){
		t = q.front(); q.pop();
		if(cnt!=t.second) flag = false;
		cnt++;
		level.push_back(t.first-&gt;num);
		if(t.first-&gt;l!=NULL){
			tt.first = t.first-&gt;l;
			tt.second = t.second*2;
			q.push(tt);
		}
		if(t.first-&gt;r!=NULL){
			tt.first = t.first-&gt;r;
			tt.second = t.second*2+1;
			q.push(tt);
		} 
	}
	for(int i=0; i&lt;level.size(); i++){
		if(i) printf(&quot; &quot;);
		printf(&quot;%d&quot;, level[i]);
	}
	printf(&quot;\n&quot;);
	if(flag) printf(&quot;YES\n&quot;);
	else printf(&quot;NO\n&quot;);
}
int main()
{
	node *tree = NULL;
	scanf(&quot;%d&quot;, &amp;n);
	for(int i=0; i&lt;n; i++){
		scanf(&quot;%d&quot;, &amp;k);
		tree = Insert(tree,k);
	}
	bfs(tree);
	return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[1119 Pre- and Post-order Traversals (30分)题解]]></title>
        <id>https://ygytl.github.io/post/1119-pre-and-post-order-traversals-30-fen-ti-jie/</id>
        <link href="https://ygytl.github.io/post/1119-pre-and-post-order-traversals-30-fen-ti-jie/">
        </link>
        <updated>2020-07-06T08:31:34.000Z</updated>
        <content type="html"><![CDATA[<p>1119 Pre- and Post-order Traversals (30分)</p>
<p>Suppose that all the keys in a binary tree are distinct positive integers. A unique binary tree can be determined by a given pair of postorder and inorder traversal sequences, or preorder and inorder traversal sequences. However, if only the postorder and preorder traversal sequences are given, the corresponding tree may no longer be unique.</p>
<p>Now given a pair of postorder and preorder traversal sequences, you are supposed to output the corresponding inorder traversal sequence of the tree. If the tree is not unique, simply output any one of them.</p>
<h3 id="input-specification">Input Specification:</h3>
<p>Each input file contains one test case. For each case, the first line gives a positive integer N (≤ 30), the total number of nodes in the binary tree. The second line gives the preorder sequence and the third line gives the postorder sequence. All the numbers in a line are separated by a space.</p>
<h3 id="output-specification">Output Specification:</h3>
<p>For each test case, first printf in a line <code>Yes</code> if the tree is unique, or <code>No</code> if not. Then print in the next line the inorder traversal sequence of the corresponding binary tree. If the solution is not unique, any answer would do. It is guaranteed that at least one solution exists. All the numbers in a line must be separated by exactly one space, and there must be no extra space at the end of the line.</p>
<h3 id="sample-input-1">Sample Input 1:</h3>
<pre><code class="language-in">7
1 2 3 4 6 7 5
2 6 7 4 5 3 1
</code></pre>
<h3 id="sample-output-1">Sample Output 1:</h3>
<pre><code class="language-out">Yes
2 1 6 4 7 3 5
</code></pre>
<h3 id="sample-input-2">Sample Input 2:</h3>
<pre><code class="language-in">4
1 2 3 4
2 4 3 1
</code></pre>
<h3 id="sample-output-2">Sample Output 2:</h3>
<pre><code class="language-out">No
2 1 3 4
</code></pre>
<hr>
<p>题目描述：提供一个二叉树的所有节点值(值为正整数)。唯一的二叉树可以由后序遍历和中序遍历得到，也可以由先序遍历和中序遍历得到。但是，如果只给出先序遍历和后序遍历，得到的二叉树有可能是不唯一的，则他的中序遍历也有可能不唯一。题目给出一对先序遍历和后序遍历数组，求出是否能得到唯一的二叉树，可以则输出Yes，否则输出No。最后一行输出中序遍历，若有多个，输出一个即可。</p>
</br>
<p>解题思路：设置一个flag标志，判断这个二叉树是否唯一。</p>
<p>用样例分析一下：</p>
<table>
<thead>
<tr>
<th>index</th>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
</tr>
</thead>
<tbody>
<tr>
<td>pre</td>
<td>1</td>
<td>2</td>
<td>3</td>
<td>4</td>
<td>6</td>
<td>7</td>
<td>5</td>
</tr>
<tr>
<td>post</td>
<td>2</td>
<td>6</td>
<td>7</td>
<td>4</td>
<td>5</td>
<td>3</td>
<td>1</td>
</tr>
</tbody>
</table>
<p>prel、prer分别是pre数组的左右索引边界值；postl、postr分别是post数组的左右索引边界值。</p>
<p>一开始prel=0，prer=6，postl=0，postr=6</p>
<p>当pre[prel]等于post[postr]，==&gt;pre[0]=1，post[6]=1，一开始就相等了，可以知道，这个值就是根节点的值。题目要求输出中序遍历，输出顺序是左、中(根)、右。当得到中(根)时，不能直接输出，要先求出左，才能将中(根)输出。后续的过程看代码，已加上注释。</p>
<hr>
<pre><code class="language-c++">#include&lt;bits/stdc++.h&gt;
using namespace std;
int n;
vector&lt;int&gt; pre, post, inorder;
bool flag = true;
void get_inorder(int prel, int prer, int postl, int postr){
	if(prel==prer){
		inorder.push_back(pre[prel]);
		return ;
	}
	int i=prel, j=postr-1, k;
	if(pre[prel]==post[postr]){//发现中间结点 
		while(i&lt;=prer&amp;&amp;j&gt;=0&amp;&amp;pre[i]!=post[j]) i++;//求出右子节点在pre数组的位置
		k = i-prel-1;//得到左子树的结点个数
		if(k&gt;0){
			get_inorder(prel+1,i-1,postl,postl+k-1);//左子树进入递归，相应的数组范围会改变
		}
		else flag = false;
	}
	inorder.push_back(post[postr]);
	get_inorder(i,prer,postl+k,postr-1);//右子树进入递归
}
int main()
{
	scanf(&quot;%d&quot;, &amp;n);
	pre.resize(n);
	post.resize(n);
	for(int i=0; i&lt;n; i++) scanf(&quot;%d&quot;, &amp;pre[i]);
	for(int i=0; i&lt;n; i++) scanf(&quot;%d&quot;, &amp;post[i]);
	get_inorder(0,n-1,0,n-1);
	if(flag) printf(&quot;Yes\n&quot;);
	else printf(&quot;No\n&quot;);
	for(int i=0; i&lt;inorder.size(); i++){
		if(i) printf(&quot; &quot;);
		printf(&quot;%d&quot;, inorder[i]);
	}
	printf(&quot;\n&quot;);//没有这个就格式错误，0分bug
	return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[1115 Counting Nodes in a BST (30分)题解]]></title>
        <id>https://ygytl.github.io/post/1115-counting-nodes-in-a-bst-30-fen-ti-jie/</id>
        <link href="https://ygytl.github.io/post/1115-counting-nodes-in-a-bst-30-fen-ti-jie/">
        </link>
        <updated>2020-07-05T06:06:15.000Z</updated>
        <content type="html"><![CDATA[<p>1115 Counting Nodes in a BST (30分)</p>
<p>A Binary Search Tree (BST) is recursively defined as a binary tree which has the following properties:</p>
<ul>
<li>The left subtree of a node contains only nodes with keys less than or equal to the node's key.</li>
<li>The right subtree of a node contains only nodes with keys greater than the node's key.</li>
<li>Both the left and right subtrees must also be binary search trees.</li>
</ul>
<p>Insert a sequence of numbers into an initially empty binary search tree. Then you are supposed to count the total number of nodes in the lowest 2 levels of the resulting tree.</p>
<h3 id="input-specification">Input Specification:</h3>
<p>Each input file contains one test case. For each case, the first line gives a positive integer <em>N</em> (≤1000) which is the size of the input sequence. Then given in the next line are the <em>N</em> integers in [−1000,1000] which are supposed to be inserted into an initially empty binary search tree.</p>
<h3 id="output-specification">Output Specification:</h3>
<p>For each case, print in one line the numbers of nodes in the lowest 2 levels of the resulting tree in the format:</p>
<pre><code>n1 + n2 = n
</code></pre>
<p>where <code>n1</code> is the number of nodes in the lowest level, <code>n2</code> is that of the level above, and <code>n</code> is the sum.</p>
<h3 id="sample-input">Sample Input:</h3>
<pre><code class="language-in">9
25 30 42 16 20 20 35 -5 28
</code></pre>
<h3 id="sample-output">Sample Output:</h3>
<pre><code class="language-out">2 + 4 = 6
</code></pre>
<hr>
<p>题目描述：二叉搜索树的特点有：</p>
<p>1）左子结点的值小于或等于根节点的值</p>
<p>2）右子结点的值大于根节点的值</p>
<p>3）所有左子树和右子树都是一个二叉搜索树</p>
<p>现在给出一组数，插入二叉搜索树中，求倒数第一层、倒数第二层的结点数，n1和n2，最后输出n1+n2。</p>
</br>
<p>解题思路：利用结构体建一棵二叉搜索树，再利用bfs将树的每一层结点分别存入vector数组中，很快就能得到结果了。写程序要有意识的将程序分块，不能将所有代码都写在主程序。</p>
<hr>
<pre><code class="language-c++">#include&lt;bits/stdc++.h&gt;
using namespace std;
int n, k;
const int maxn = 1e4+5;
vector&lt;int&gt; v[maxn];
struct node{
	int num;
	node *l, *r;
	node(){
		l = r = NULL;
	}
};
node* build(node *tree, int x){
	if(tree==NULL){
		tree = new node();
		tree-&gt;num = x;
		tree-&gt;l = tree-&gt;r = NULL;
	}
	else if(tree-&gt;num&lt;x){
		tree-&gt;r = build(tree-&gt;r,x);
	}
	else tree-&gt;l = build(tree-&gt;l,x);
	return tree;
}

void bfs(node *tree){
	int cnt = 0;
	queue&lt;pair&lt;node*,int&gt; &gt; q;
	pair&lt;node*,int&gt; t, tt;
	t.first = tree;
	t.second = 0;
	q.push(t);
	while(!q.empty()){
		t = q.front(); q.pop();
		cnt = t.second;
		v[t.second].push_back(t.first-&gt;num);
		if(t.first-&gt;l!=NULL){
			tt.first = t.first-&gt;l;
			tt.second = t.second+1;
			q.push(tt);
		}
		if(t.first-&gt;r!=NULL){
			tt.first = t.first-&gt;r;
			tt.second = t.second+1;
			q.push(tt);
		}
	}
	int n1 = v[cnt].size(), n2 = v[cnt-1].size();
	printf(&quot;%d + %d = %d\n&quot;, n1, n2, n1+n2);
}

int main()
{
	node *tree = NULL;
	scanf(&quot;%d&quot;, &amp;n);
	for(int i=0; i&lt;n; i++){
		scanf(&quot;%d&quot;, &amp;k);
		tree = build(tree,k);
	}
	bfs(tree);
	return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[1111 Online Map (30分)题解]]></title>
        <id>https://ygytl.github.io/post/1111-online-map-30-fen-ti-jie/</id>
        <link href="https://ygytl.github.io/post/1111-online-map-30-fen-ti-jie/">
        </link>
        <updated>2020-07-04T08:42:46.000Z</updated>
        <content type="html"><![CDATA[<p>1111 Online Map (30分)</p>
<p>Input our current position and a destination, an online map can recommend several paths. Now your job is to recommend two paths to your user: one is the shortest, and the other is the fastest. It is guaranteed that a path exists for any request.</p>
<h3 id="input-specification">Input Specification:</h3>
<p>Each input file contains one test case. For each case, the first line gives two positive integers <em>N</em> (2≤<em>N</em>≤500), and <em>M</em>, being the total number of streets intersections on a map, and the number of streets, respectively. Then <em>M</em> lines follow, each describes a street in the format:</p>
<pre><code>V1 V2 one-way length time
</code></pre>
<p>where <code>V1</code> and <code>V2</code> are the indices (from 0 to <em>N</em>−1) of the two ends of the street; <code>one-way</code> is 1 if the street is one-way from <code>V1</code> to <code>V2</code>, or 0 if not; <code>length</code> is the length of the street; and <code>time</code> is the time taken to pass the street.</p>
<p>Finally a pair of source and destination is given.</p>
<h3 id="output-specification">Output Specification:</h3>
<p>For each case, first print the shortest path from the source to the destination with distance <code>D</code> in the format:</p>
<pre><code>Distance = D: source -&gt; v1 -&gt; ... -&gt; destination
</code></pre>
<p>Then in the next line print the fastest path with total time <code>T</code>:</p>
<pre><code>Time = T: source -&gt; w1 -&gt; ... -&gt; destination
</code></pre>
<p>In case the shortest path is not unique, output the fastest one among the shortest paths, which is guaranteed to be unique. In case the fastest path is not unique, output the one that passes through the fewest intersections, which is guaranteed to be unique.</p>
<p>In case the shortest and the fastest paths are identical, print them in one line in the format:</p>
<pre><code>Distance = D; Time = T: source -&gt; u1 -&gt; ... -&gt; destination
</code></pre>
<h3 id="sample-input-1">Sample Input 1:</h3>
<pre><code class="language-in">10 15
0 1 0 1 1
8 0 0 1 1
4 8 1 1 1
3 4 0 3 2
3 9 1 4 1
0 6 0 1 1
7 5 1 2 1
8 5 1 2 1
2 3 0 2 2
2 1 1 1 1
1 3 0 3 1
1 4 0 1 1
9 7 1 3 1
5 1 0 5 2
6 5 1 1 2
3 5
</code></pre>
<h3 id="sample-output-1">Sample Output 1:</h3>
<pre><code class="language-out">Distance = 6: 3 -&gt; 4 -&gt; 8 -&gt; 5
Time = 3: 3 -&gt; 1 -&gt; 5
</code></pre>
<h3 id="sample-input-2">Sample Input 2:</h3>
<pre><code class="language-in">7 9
0 4 1 1 1
1 6 1 1 3
2 6 1 1 1
2 5 1 2 2
3 0 0 1 1
3 1 1 1 3
3 2 1 1 2
4 5 0 2 2
6 5 1 1 2
3 5
</code></pre>
<h3 id="sample-output-2">Sample Output 2:</h3>
<pre><code class="language-out">Distance = 3; Time = 4: 3 -&gt; 2 -&gt; 5
</code></pre>
<hr>
<p>题目描述：分别求出发地点到目的地的最短距离，最短时间路径；当最短路程路线不唯一时，找到当中花费时间最短的路径；当最短时间路径不唯一时，找分岔口最少的路径；</p>
<p>输出规则提示：当最短距离路径与最短时间路径相同时，按照Distance = D; Time = T: source -&gt; u1 -&gt; ... -&gt; destination 格式输出</p>
<p>解题思路：Dij</p>
<hr>
<pre><code class="language-c++">#include&lt;bits/stdc++.h&gt;
using namespace std;
int n, m, st, et;
const int maxn = 1000 + 5;
const int inf = 0x3f3f3f3f;
vector&lt;int&gt; G[maxn];
int G2[maxn][maxn], G3[maxn][maxn];
bool vis[maxn];
int dist1[maxn], T1[maxn], f1[maxn], f2[maxn], dist2[maxn], T2[maxn];
stack&lt;int&gt; s1, s2;
void Dij1(){
	int sst = st, eet = et;
	memset(vis,false,sizeof(vis));
	memset(dist1,inf,sizeof(dist1));
	memset(T1,inf,sizeof(T1));
	dist1[st] = 0; T1[st] = 0;
	f1[st] = st;
	while(1){
		int index=-1, mx = inf;
		for(int i=0; i&lt;n; i++){
			if(!vis[i]&amp;&amp;dist1[i]&lt;mx){
				mx = dist1[i];
				index = i;
			}
		}
		if(index==-1) break;
		vis[index] = true;
		int u = index, v;
		for(int i=0; i&lt;G[u].size(); i++){
			v = G[u][i];
			if(!vis[v]){
				if(dist1[v]&gt;dist1[u]+G2[u][v]){
					dist1[v] = dist1[u] + G2[u][v];
					T1[v] = T1[u] + G3[u][v];
					f1[v] = u;
				}
				else if(dist1[v]==dist1[u]+G2[u][v]){
					if(T1[v]&gt;T1[u] + G3[u][v]){
						T1[v] = T1[u] + G3[u][v];
						f1[v] = u;
					}
				}
			}
		}
	}
	while(f1[eet]!=eet){
		s1.push(eet);
		eet = f1[eet];
	}
	s1.push(sst);
}
void Dij2(){
	int sst = st, eet = et;
	memset(vis,false,sizeof(vis));
	memset(dist2,0,sizeof(dist2));
	memset(T2,inf,sizeof(T2));
	T2[st] = 0; dist2[st] = 1;
	f2[st] = st;
	while(1){
		int index=-1, mx = inf;
		for(int i=0; i&lt;n; i++){
			if(!vis[i]&amp;&amp;T2[i]&lt;mx){
				mx = T2[i];
				index = i;
			}
		}
		if(index==-1) break;
		vis[index] = true;
		int u = index, v;
		for(int i=0; i&lt;G[u].size(); i++){
			v = G[u][i];
			if(!vis[v]){
				if(T2[v]&gt;T2[u]+G3[u][v]){
					T2[v] = T2[u] + G3[u][v];
					f2[v] = u;
					dist2[v] = dist2[u] + 1;
				}
				else if(T2[v]==T2[u]+G3[u][v]){
					if(dist2[v]&gt;dist2[u]+1){
						dist2[v] = dist2[u] + 1;
						f2[v] = u;
					}
				}
			}
		}
	}
	while(f2[eet]!=eet){
		s2.push(eet);
		eet = f2[eet];
	}
	s2.push(sst);
}

int main()
{
	int v1, v2, way, length, time;
	scanf(&quot;%d %d&quot;, &amp;n, &amp;m);
	for(int i=0; i&lt;m; i++){
		scanf(&quot;%d %d %d %d %d&quot;, &amp;v1, &amp;v2, &amp;way, &amp;length, &amp;time);
		
		if(way==1) G[v1].push_back(v2);//v1 -&gt; v2
		else{
			G[v1].push_back(v2);
			G[v2].push_back(v1);
		}
		G2[v1][v2] = G2[v2][v1] = length;
		G3[v1][v2] = G3[v2][v1] = time;
	}
	scanf(&quot;%d %d&quot;, &amp;st, &amp;et);
	Dij1();
	Dij2();
	if(s1==s2){
		printf(&quot;Distance = %d; Time = %d:&quot;, dist1[et], T2[et]);
		int c = 0;
		while(!s1.empty()){
			if(c==0) printf(&quot; &quot;);
			else printf(&quot; -&gt; &quot;);
			printf(&quot;%d&quot;, s1.top());
			s1.pop(); c++;
		}
	}
	else{
		printf(&quot;Distance = %d:&quot;, dist1[et]);
		int c = 0;
		while(!s1.empty()){
			if(c==0) printf(&quot; &quot;);
			else printf(&quot; -&gt; &quot;);
			printf(&quot;%d&quot;, s1.top());
			s1.pop(); c++;
		}
		printf(&quot;\nTime = %d:&quot;, T2[et]);
		c = 0;
		while(!s2.empty()){
			if(c==0) printf(&quot; &quot;);
			else printf(&quot; -&gt; &quot;);
			printf(&quot;%d&quot;, s2.top());
			s2.pop(); c++;
		} 
	}
	return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[1107 Social Clusters (30分)题解]]></title>
        <id>https://ygytl.github.io/post/1107-social-clusters-30-fen-ti-jie/</id>
        <link href="https://ygytl.github.io/post/1107-social-clusters-30-fen-ti-jie/">
        </link>
        <updated>2020-07-03T10:05:36.000Z</updated>
        <content type="html"><![CDATA[<p>1107 Social Clusters (30分)</p>
<p>When register on a social network, you are always asked to specify your hobbies in order to find some potential friends with the same hobbies. A <strong>social cluster</strong> is a set of people who have some of their hobbies in common. You are supposed to find all the clusters.</p>
<h3 id="input-specification">Input Specification:</h3>
<p>Each input file contains one test case. For each test case, the first line contains a positive integer <em>N</em> (≤1000), the total number of people in a social network. Hence the people are numbered from 1 to <em>N</em>. Then <em>N</em> lines follow, each gives the hobby list of a person in the format:</p>
<p><em>K**i</em>: <em>h**i</em>[1] <em>h**i</em>[2] ... <em>h**i</em>[<em>K**i</em>]</p>
<p>where <em>K**i</em> (&gt;0) is the number of hobbies, and <em>h**i</em>[<em>j</em>] is the index of the <em>j</em>-th hobby, which is an integer in [1, 1000].</p>
<h3 id="output-specification">Output Specification:</h3>
<p>For each case, print in one line the total number of clusters in the network. Then in the second line, print the numbers of people in the clusters in non-increasing order. The numbers must be separated by exactly one space, and there must be no extra space at the end of the line.</p>
<h3 id="sample-input">Sample Input:</h3>
<pre><code class="language-in">8
3: 2 7 10
1: 4
2: 5 3
1: 4
1: 3
1: 4
4: 6 8 1 5
1: 4
</code></pre>
<h3 id="sample-output">Sample Output:</h3>
<pre><code class="language-out">3
4 3 1
</code></pre>
<hr>
<p>题目描述：潜在的朋友圈</p>
<p>输入：第一行n，表示人数；接着n行，每行是第i个人选择的课程数及课程id号。</p>
<p>输出：第一行输出多少个圈，接着输出按照圈里人数的大小递减输出。</p>
<p>解题思路：并查集，求出有多少个朋友圈，按照朋友圈的人数从大到小输出每个圈的人数就行了。</p>
<hr>
<pre><code class="language-c++">#include&lt;bits/stdc++.h&gt;
using namespace std;
int n, m;
const int maxn = 2000;
vector&lt;int&gt; v[maxn];
int f[maxn], g[maxn];
set&lt;int&gt; s;
int find(int x){
	while(f[x]!=x){
		x = f[x];
	}
	return x;
}
void Union(int x, int y){
	x = find(x);
	y = find(y);
	f[x] = y;
}
bool cmp(int a, int b){
	return a &gt; b;
}
int main()
{
	int k;
	scanf(&quot;%d&quot;, &amp;n);
	for(int i=1; i&lt;=n; i++) f[i] = i;
	for(int i=1; i&lt;=n; i++){
		scanf(&quot;%d:&quot;, &amp;m);
		for(int j=0; j&lt;m; j++){
			scanf(&quot;%d&quot;, &amp;k);
			v[k].push_back(i);
			s.insert(k);
		}
	}
	set&lt;int&gt;::iterator it;
	for(it=s.begin(); it!=s.end(); it++){//课程id 
		sort(v[*it].begin(),v[*it].end());
		int x, y;
		for(int i=0; i&lt;v[*it].size(); i++){
			if(i==0) x = find(v[*it][i]);
			else{
				y = find(v[*it][i]);
				Union(x,y);
			}
		}
	}
	map&lt;int,int&gt; p;
	for(int i=1; i&lt;=n; i++) p[find(i)]++;
	map&lt;int,int&gt;::iterator it1;
	int cnt=0; 
	for(it1=p.begin(); it1!=p.end(); it1++){
		g[cnt++] = it1-&gt;second;
	}
	sort(g,g+cnt,cmp);
	printf(&quot;%d\n&quot;, cnt);
	for(int i=0; i&lt;cnt; i++){
		if(i) printf(&quot; &quot;);
		printf(&quot;%d&quot;, g[i]);
	}
	return 0;
}
</code></pre>
]]></content>
    </entry>
</feed>