<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://ygytl.github.io/</id>
    <title>Grace</title>
    <updated>2020-05-31T03:29:00.056Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://ygytl.github.io/"/>
    <link rel="self" href="https://ygytl.github.io/atom.xml"/>
    <subtitle>Grace&apos;s blog</subtitle>
    <logo>https://ygytl.github.io/images/avatar.png</logo>
    <icon>https://ygytl.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, Grace</rights>
    <entry>
        <title type="html"><![CDATA[P3 同步阻塞下载]]></title>
        <id>https://ygytl.github.io/post/p3-tong-bu-zu-sai-xia-zai/</id>
        <link href="https://ygytl.github.io/post/p3-tong-bu-zu-sai-xia-zai/">
        </link>
        <updated>2020-05-31T03:18:14.000Z</updated>
        <content type="html"><![CDATA[<h3 id="环境搭建">环境搭建</h3>
<h4 id="安装centos7并配置nginx">安装centos7并配置nginx</h4>
<pre><code>1. 添加repo源
# vi /etc/yum.repos.d/nginx.repo

内容如下:
[nginx]
name=nginx repo
baseurl=http://nginx.org/packages/centos/7/$basearch/
gpgcheck=0
enabled=1

2. 安装
# yum install -y nginx

3. 启动
# systemctl start nginx
# systemctl enable nginx
</code></pre>
<h3 id="同步阻塞">同步阻塞</h3>
<h4 id="11-在windows下创建文件夹test在文件夹下创建日志模块loggerpy后续windows文件都放入同一个文件夹下">1.1 在windows下创建文件夹test，在文件夹下创建日志模块logger.py(后续windows文件都放入同一个文件夹下)</h4>
<pre><code class="language-python">import os
import time
import logging

logger = logging.getLogger('aiotest')
logger.setLevel(logging.DEBUG)
formatter = logging.Formatter(
    '%(asctime)s - %(filename)s[line:%(lineno)d] - &lt;%(threadName)s %(thread)d&gt;' +
    '- &lt;Process %(process)d&gt; - %(levelname)s: %(message)s'
)

basedir = os.path.abspath(os.path.dirname(__file__))
log_dest = os.path.join(basedir, 'logs')  # 日志文件所在目录
if not os.path.isdir(log_dest):
    os.mkdir(log_dest)
filename = time.strftime('%Y-%m-%d-%H-%M-%S', time.localtime(time.time())) + '.log'  file_handler = logging.FileHandler(os.path.join(log_dest, filename))  # 创建日志文件handler
file_handler.setFormatter(formatter)  # 设置Formatter
file_handler.setLevel(logging.INFO)  # 单独设置日志文件的日志级别

stream_handler = logging.StreamHandler()
stream_handler.setFormatter(formatter)
# stream_handler.setLevel(logging.INFO)  # 单独设置控制台日志的日志级别，注释掉则使用总日志级别
logger.addHandler(file_handler)
logger.addHandler(stream_handler)
</code></pre>
<h4 id="12-在centos中放入文件flagstargz">1.2 在centos中放入文件flags.tar.gz</h4>
<pre><code>将flags.tar.gz文件导入到/usr/share/nginx/html中，并解压tar xf flags.tar.gz
#cd /usr/share/nginx/html
#ls flags &gt; flags.txt
将flags文件夹下的文件名写入flags.txt中，以便后续使用
</code></pre>
<h4 id="13-在windows下创建commonpy">1.3 在windows下创建common.py</h4>
<pre><code class="language-python">import os
import time
import requests
from logger import logger

basepath = os.path.abspath(os.path.dirname(__file__))  # 当前模块文件的根目录

def setup_down_path():
    '''设置图片下载后的保存位置，所有图片放在同一个目录下'''
    down_path = os.path.join(basepath, 'downloads')
    if not os.path.isdir(down_path):
        os.mkdir(down_path)
        logger.info('Create download path {}'.format(down_path))
    return down_path

def get_links():
    '''获取所有图片的下载链接'''
    with open(os.path.join(basepath, 'flags.txt')) as f:
        return ['http://192.168.157.134/flags/' + flag.strip() for flag in f.readlines()]


def download_one(image):  #后续多线程时concurrent.futures.ThreadPoolExecutor.map()
    '''
    下载一张图片
    param image: 字典，包括图片的保存目录、图片的序号、图片的URL
    '''
    logger.info('Downloading No.{} [{}]'.format(image['linkno'], image['link']))
    t0 = time.time()

    resp = requests.get(image['link'])
    filename = os.path.split(image['link'])[1]
    with open(os.path.join(image['path'], filename), 'wb') as f:
        f.write(resp.content)  # resp.content是bytes类型，而resp.text是str类型

    t1 = time.time()
    logger.info('Task No.{} [{}] runs {} seconds.'.format(image['linkno'], image['link'], t1 - t0))
</code></pre>
<h4 id="14-在windows下创建sequentialpy">1.4  在windows下创建sequential.py</h4>
<pre><code class="language-python">import time
from common import setup_down_path, get_links, download_one
from logger import logger

def download_many():
    '''依序下载所有图片，同步阻塞'''
    down_path = setup_down_path()
    links = get_links()

    for linkno, link in enumerate(links, 1):
        image = {
            'path': down_path,
            'linkno': linkno,  # 图片序号，方便日志输出时，正在下载哪一张
            'link': link
        }
        download_one(image)

    return len(links)

if __name__ == '__main__':
    t0 = time.time()
    count = download_many()
    msg = '{} flags downloaded in {} seconds.'
    logger.info(msg.format(count, time.time() - t0))
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[1067 Sort with Swap(0, i) (25分)题解]]></title>
        <id>https://ygytl.github.io/post/1067-sort-with-swap0-i-25-fen/</id>
        <link href="https://ygytl.github.io/post/1067-sort-with-swap0-i-25-fen/">
        </link>
        <updated>2020-05-29T07:32:54.000Z</updated>
        <content type="html"><![CDATA[<p>1067 Sort with Swap(0, i) (25分)</p>
<p>Given any permutation of the numbers {0, 1, 2,..., <em>N</em>−1}, it is easy to sort them in increasing order. But what if <code>Swap(0, *)</code> is the ONLY operation that is allowed to use? For example, to sort {4, 0, 2, 1, 3} we may apply the swap operations in the following way:</p>
<pre><code>Swap(0, 1) =&gt; {4, 1, 2, 0, 3}
Swap(0, 3) =&gt; {4, 1, 2, 3, 0}
Swap(0, 4) =&gt; {0, 1, 2, 3, 4}
</code></pre>
<p>Now you are asked to find the minimum number of swaps need to sort the given permutation of the first <em>N</em> nonnegative integers.</p>
<h3 id="input-specification">Input Specification:</h3>
<p>Each input file contains one test case, which gives a positive <em>N</em> (≤105) followed by a permutation sequence of {0, 1, ..., <em>N</em>−1}. All the numbers in a line are separated by a space.</p>
<h3 id="output-specification">Output Specification:</h3>
<p>For each case, simply print in a line the minimum number of swaps need to sort the given permutation.</p>
<h3 id="sample-input">Sample Input:</h3>
<pre><code class="language-in">10
3 5 7 2 6 4 9 0 8 1
</code></pre>
<h3 id="sample-output">Sample Output:</h3>
<pre><code class="language-out">9
</code></pre>
<hr>
<p>题目描述：只能与0交换，求得到正确序列所需最少交换次数。</p>
<p>解题思路：找到序列中值与位置不匹配的元素，进行循环交换，将他们放回正确的位置，当该元素不为0时，交换次数要另外加2。</p>
<hr>
<pre><code class="language-c++">#include&lt;bits/stdc++.h&gt;
using namespace std;
int main()
{
	int n;
	vector&lt;int&gt; v;
	scanf(&quot;%d&quot;, &amp;n);
	v.resize(n);
	for(int i=0; i&lt;n; i++){
		scanf(&quot;%d&quot;, &amp;v[i]);
	}
	int ans = 0;
	for(int i=0; i&lt;n; i++){
		if(v[i]==i) continue;
		while(v[i]!=i){
			swap(v[i],v[v[i]]);
			ans++;
		}
		if(i!=0) ans+=2;
	}
	printf(&quot;%d\n&quot;, ans);
	return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[1065 A+B and C (64bit) (20分)题解]]></title>
        <id>https://ygytl.github.io/post/1065-ab-and-c-64bit-20-fen-ti-jie/</id>
        <link href="https://ygytl.github.io/post/1065-ab-and-c-64bit-20-fen-ti-jie/">
        </link>
        <updated>2020-05-29T02:42:07.000Z</updated>
        <content type="html"><![CDATA[<p>1065 A+B and C (64bit) (20分)</p>
<p>Given three integers <em>A</em>, <em>B</em> and <em>C</em> in [−2<sup>63</sup>,2<sup>63</sup>], you are supposed to tell whether <em>A</em>+<em>B</em>&gt;<em>C</em>.</p>
<h3 id="input-specification">Input Specification:</h3>
<p>The first line of the input gives the positive number of test cases, <em>T</em> (≤10). Then <em>T</em> test cases follow, each consists of a single line containing three integers <em>A</em>, <em>B</em> and <em>C</em>, separated by single spaces.</p>
<h3 id="output-specification">Output Specification:</h3>
<p>For each test case, output in one line <code>Case #X: true</code> if <em>A</em>+<em>B</em>&gt;<em>C</em>, or <code>Case #X: false</code> otherwise, where <em>X</em> is the case number (starting from 1).</p>
<h3 id="sample-input">Sample Input:</h3>
<pre><code class="language-in">3
1 2 3
2 3 4
9223372036854775807 -9223372036854775808 0
</code></pre>
<h3 id="sample-output">Sample Output:</h3>
<pre><code class="language-out">Case #1: false
Case #2: true
Case #3: false
</code></pre>
<hr>
<p>题目描述：A+B&gt;C，真返回true，假返回false</p>
<p>解题思路：一看就是大数据处理，long double类型杠，或者对数据处理一下</p>
<p>注：a&gt;&gt;1 与 a/2有区别，(a&amp;1) 与 a%2有区别，a+b==c 与 (g=a+b),g==c有区别</p>
<hr>
<p>方法一：</p>
<pre><code class="language-C++">#include&lt;bits/stdc++.h&gt;
using namespace std ;
int main()
{
    int n;
    scanf(&quot;%d&quot;, &amp;n);
    for( int i=1; i&lt;=n; i++){
        long double a, b, c;
        scanf(&quot;%Lf %Lf %Lf&quot;, &amp;a, &amp;b, &amp;c);
        printf(&quot;Case #%d: &quot;, i);
        if(a+b&gt;c) printf(&quot;yes\n&quot;);
        else printf(&quot;false\n&quot;);
    }
    return 0 ;
}
</code></pre>
<p>方法二：</p>
<pre><code class="language-c++">#include&lt;bits/stdc++.h&gt;
using namespace std;
int main()
{
	long long a, b, c;
	int n;
	scanf(&quot;%d&quot;, &amp;n);
	for(int i=1; i&lt;=n; i++){
		scanf(&quot;%lld %lld %lld&quot;, &amp;a, &amp;b, &amp;c);
		long long ta, tb, tc;
		ta = a&gt;&gt;1;
		tb = b&gt;&gt;1;
		tc = c&gt;&gt;1;
		printf(&quot;Case #%d: &quot;, i);
		if(ta+tb&gt;tc){
			printf(&quot;true\n&quot;);
		}
		else if(ta+tb==tc&amp;&amp;((a&amp;1)+(b&amp;1)&gt;(c&amp;1))){
			printf(&quot;true\n&quot;);
		}
		else printf(&quot;false\n&quot;);
	}
	return 0;
}
</code></pre>
<p>方法三：</p>
<pre><code class="language-python">n = int(input())
for i in range(1,n+1):
    g = input().split()
    a = int(g[0])
    b = int(g[1])
    c = int(g[2])
    if a+b &gt; c:
        print('Case #{}: true'.format(i))
    else:
        print('Case #{}: false'.format(i))

</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[linux常用命令]]></title>
        <id>https://ygytl.github.io/post/linux-chang-yong-ming-ling/</id>
        <link href="https://ygytl.github.io/post/linux-chang-yong-ming-ling/">
        </link>
        <updated>2020-05-28T13:18:52.000Z</updated>
        <content type="html"><![CDATA[<h5 id="复制文件或文件夹">复制文件或文件夹</h5>
<pre><code>cp dir1/a.doc dir2 //将dir1下的a.doc文件复制到dir2目录下
cp -r dir1 dir2 //将dir1及dir1下的文件复制到dir2
cp -r dir1/. dir2 //将dir1下的文件复制到dir2
</code></pre>
<h5 id="解压缩">解压缩</h5>
<pre><code>tar xf flag.tar.gz
</code></pre>
<h5 id="centos查看ip">CentOS查看ip</h5>
<pre><code>ip addr
</code></pre>
<h5 id="将flags文件夹里的文件名输出到txt文本">将flags文件夹里的文件名输出到txt文本</h5>
<pre><code>#ls flags &gt; flags.txt
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[1062 Talent and Virtue (25分)题解]]></title>
        <id>https://ygytl.github.io/post/1062-talent-and-virtue-25-fen/</id>
        <link href="https://ygytl.github.io/post/1062-talent-and-virtue-25-fen/">
        </link>
        <updated>2020-05-26T15:56:44.000Z</updated>
        <content type="html"><![CDATA[<p>1062 Talent and Virtue (25分)</p>
<p>About 900 years ago, a Chinese philosopher Sima Guang wrote a history book in which he talked about people's talent and virtue. According to his theory, a man being outstanding in both talent and virtue must be a &quot;sage（圣人）&quot;; being less excellent but with one's virtue outweighs talent can be called a &quot;nobleman（君子）&quot;; being good in neither is a &quot;fool man（愚人）&quot;; yet a fool man is better than a &quot;small man（小人）&quot; who prefers talent than virtue.</p>
<p>Now given the grades of talent and virtue of a group of people, you are supposed to rank them according to Sima Guang's theory.</p>
<h3 id="input-specification">Input Specification:</h3>
<p>Each input file contains one test case. Each case first gives 3 positive integers in a line: <em>N</em> (≤105), the total number of people to be ranked; <em>L</em> (≥60), the lower bound of the qualified grades -- that is, only the ones whose grades of talent and virtue are both not below this line will be ranked; and <em>H</em> (&lt;100), the higher line of qualification -- that is, those with both grades not below this line are considered as the &quot;sages&quot;, and will be ranked in non-increasing order according to their total grades. Those with talent grades below <em>H</em> but virtue grades not are cosidered as the &quot;noblemen&quot;, and are also ranked in non-increasing order according to their total grades, but they are listed after the &quot;sages&quot;. Those with both grades below <em>H</em>, but with virtue not lower than talent are considered as the &quot;fool men&quot;. They are ranked in the same way but after the &quot;noblemen&quot;. The rest of people whose grades both pass the <em>L</em> line are ranked after the &quot;fool men&quot;.</p>
<p>Then <em>N</em> lines follow, each gives the information of a person in the format:</p>
<pre><code>ID_Number Virtue_Grade Talent_Grade
</code></pre>
<p>where <code>ID_Number</code> is an 8-digit number, and both grades are integers in [0, 100]. All the numbers are separated by a space.</p>
<h3 id="output-specification">Output Specification:</h3>
<p>The first line of output must give <em>M</em> (≤<em>N</em>), the total number of people that are actually ranked. Then <em>M</em> lines follow, each gives the information of a person in the same format as the input, according to the ranking rules. If there is a tie of the total grade, they must be ranked with respect to their virtue grades in non-increasing order. If there is still a tie, then output in increasing order of their ID's.</p>
<h3 id="sample-input">Sample Input:</h3>
<pre><code class="language-in">14 60 80
10000001 64 90
10000002 90 60
10000011 85 80
10000003 85 80
10000004 80 85
10000005 82 77
10000006 83 76
10000007 90 78
10000008 75 79
10000009 59 90
10000010 88 45
10000012 80 100
10000013 90 99
10000014 66 60
</code></pre>
<h3 id="sample-output">Sample Output:</h3>
<pre><code class="language-out">12
10000013 90 99
10000012 80 100
10000003 85 80
10000011 85 80
10000004 80 85
10000007 90 78
10000006 83 76
10000005 82 77
10000002 90 60
10000014 66 60
10000008 75 79
10000001 64 90
</code></pre>
<hr>
<p>题目描述：排序。。。</p>
<p>解题思路：</p>
<p>A--talent &gt;= H, virtue &gt;= H --总分高优先；<br>
B--talent &lt;H , virtue &gt;= H --总分高优先；<br>
C--talent &lt; H, virtue &lt; H &amp;&amp; virtue &gt;= talent --总分高优先；<br>
D--talent &lt; H, virtue &lt;H &amp;&amp; virtue &lt; talent --总分高优先；</p>
<p>提示：当总分相同时，按照virtue递减排序；当总分和virtue相同时，按照ID递增排序。</p>
<hr>
<pre><code class="language-c++">#include&lt;bits/stdc++.h&gt;
using namespace std;
int n, l, h;
struct node{
	int id;
	int virtue, talent;
	int cid;
};
vector&lt;node&gt; v;
bool cmp(node a, node b){
	if(a.cid!=b.cid) return a.cid &lt; b.cid;
	else if(a.virtue+a.talent != b.virtue+b.talent) return a.virtue+a.talent &gt; b.virtue+b.talent;
	else if(a.virtue!=b.virtue) return a.virtue &gt; b.virtue;
	else if(a.id!=b.id) return a.id &lt; b.id;
}
int main()
{
	scanf(&quot;%d %d %d&quot;, &amp;n, &amp;l, &amp;h);
	for(int i=0; i&lt;n; i++){
		node t;
		scanf(&quot;%d %d %d&quot;, &amp;t.id, &amp;t.virtue, &amp;t.talent);
		if(t.talent&lt;l||t.virtue&lt;l) continue;
		if(t.talent&gt;=h&amp;&amp;t.virtue&gt;=h) t.cid = 1;
		else if(t.talent&lt;h&amp;&amp;t.virtue&gt;=h) t.cid = 2;
		else if(t.talent&lt;h&amp;&amp;t.virtue&lt;h&amp;&amp;t.virtue&gt;=t.talent) t.cid = 3;
		else t.cid = 4;
		v.push_back(t);
	}
	sort(v.begin(),v.end(),cmp);
	printf(&quot;%d\n&quot;, v.size());
	for(int i=0; i&lt;v.size(); i++){
		node t = v[i];
		printf(&quot;%d %d %d\n&quot;, t.id, t.virtue, t.talent);
	}
	return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[1045 Favorite Color Stripe (30分)题解]]></title>
        <id>https://ygytl.github.io/post/1045-favorite-color-stripe-30-fen-ti-jie/</id>
        <link href="https://ygytl.github.io/post/1045-favorite-color-stripe-30-fen-ti-jie/">
        </link>
        <updated>2020-05-25T15:39:27.000Z</updated>
        <summary type="html"><![CDATA[<p>1045 Favorite Color Stripe (30分)</p>
<p>Eva is trying to make her own color stripe out of a given one. She would like to keep only her favorite colors in her favorite order by cutting off those unwanted pieces and sewing the remaining parts together to form her favorite color stripe.</p>
<p>It is said that a normal human eye can distinguish about less than 200 different colors, so Eva's favorite colors are limited. However the original</p>
]]></summary>
        <content type="html"><![CDATA[<p>1045 Favorite Color Stripe (30分)</p>
<p>Eva is trying to make her own color stripe out of a given one. She would like to keep only her favorite colors in her favorite order by cutting off those unwanted pieces and sewing the remaining parts together to form her favorite color stripe.</p>
<p>It is said that a normal human eye can distinguish about less than 200 different colors, so Eva's favorite colors are limited. However the original</p>
<!-- more -->
<!-- more -->
<p>stripe could be very long, and Eva would like to have the remaining favorite stripe with the maximum length. So she needs your help to find her the best result.</p>
<p>Note that the solution might not be unique, but you only have to tell her the maximum length. For example, given a stripe of colors {2 2 4 1 5 5 6 3 1 1 5 6}. If Eva's favorite colors are given in her favorite order as {2 3 1 5 6}, then she has 4 possible best solutions {2 2 1 1 1 5 6}, {2 2 1 5 5 5 6}, {2 2 1 5 5 6 6}, and {2 2 3 1 1 5 6}.</p>
<h3 id="input-specification"><strong>Input Specification:</strong></h3>
<p>Each input file contains one test case. For each case, the first line contains a positive integer <strong>N</strong> (≤200) which is the total number of colors involved (and hence the colors are numbered from 1 to <strong>N</strong>). Then the next line starts with a positive integer <strong>M</strong> (≤200) followed by <strong>M</strong> Eva's favorite color numbers given in her favorite order. Finally the third line starts with a positive integer <strong>L</strong> (≤10<sup>4</sup>) which is the length of the given stripe, followed by <strong>L</strong> colors on the stripe. All the numbers in a line a separated by a space.</p>
<h3 id="output-specification"><strong>Output Specification:</strong></h3>
<p>For each test case, simply print in a line the maximum length of Eva's favorite stripe.</p>
<h3 id="sample-input"><strong>Sample Input:</strong></h3>
<pre><code class="language-in">
6

5 2 3 1 5 6

12 2 2 4 1 5 5 6 3 1 1 5 6

</code></pre>
<h3 id="sample-output"><strong>Sample Output:</strong></h3>
<pre><code class="language-out">
7

</code></pre>
<hr>
<p>题目描述：N为颜色求得色号吧(1~N)，给出M个数，表示用户最喜欢的摆放序列，从L个数中自主挑选排序，求出符合用户摆放序列要求的最长序列。</p>
<p>解题思路：动态规划</p>
<p>（1）将M个数用编号存放到数组</p>
<p>（2）从L个数中挑选用户喜欢的颜色序号放入容器</p>
<p>（3）动态规划的思想。。</p>
<hr>
<pre><code class="language-c++">#include&lt;bits/stdc++.h&gt;
using namespace std;
vector&lt;int&gt; v;
map&lt;int,int&gt; G;
const int maxn = 100050;
int dp[maxn];
int main()
{
	int n, m, k;
	int g;
	scanf(&quot;%d %d&quot;, &amp;n, &amp;m);
	for(int i=1; i&lt;=m; i++){
		scanf(&quot;%d&quot;, &amp;g);
		G[g] = i;
	}
	scanf(&quot;%d&quot;, &amp;k);
	for(int i=0; i&lt;k; i++){
		scanf(&quot;%d&quot;, &amp;g);
		if(G[g]!=0){
			v.push_back(G[g]);
		}
	}
	int l = v.size(), ans = 0;
	for(int i=0; i&lt;l; i++){
		dp[i] = 1;
		for(int j=0; j&lt;i; j++){
			if(v[j]&lt;=v[i]&amp;&amp;dp[i]&lt;dp[j]+1){
				dp[i] = dp[j]+1;
			}
		}
		ans = max(ans,dp[i]);
	}
	printf(&quot;%d\n&quot;, ans);
	return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[1063 Set Similarity (25分)题解]]></title>
        <id>https://ygytl.github.io/post/1063-set-similarity-25-fen-ti-jie/</id>
        <link href="https://ygytl.github.io/post/1063-set-similarity-25-fen-ti-jie/">
        </link>
        <updated>2020-05-25T01:49:12.000Z</updated>
        <content type="html"><![CDATA[<p>1063 Set Similarity (25分)</p>
<p>Given two sets of integers, the similarity of the sets is defined to be N<sub>c</sub>/N<sub>t</sub>×100%, where N<sub>c</sub> is the number of distinct common numbers shared by the two sets, and N<sub>t</sub> is the total number of distinct numbers in the two sets. Your job is to calculate the similarity of any given pair of sets.</p>
<h3 id="input-specification">Input Specification:</h3>
<p>Each input file contains one test case. Each case first gives a positive integer <em>N</em> (≤50) which is the total number of sets. Then <em>N</em> lines follow, each gives a set with a positive <em>M</em> (≤104) and followed by <em>M</em> integers in the range [0,109]. After the input of sets, a positive integer <em>K</em> (≤2000) is given, followed by <em>K</em> lines of queries. Each query gives a pair of set numbers (the sets are numbered from 1 to <em>N</em>). All the numbers in a line are separated by a space.</p>
<h3 id="output-specification">Output Specification:</h3>
<p>For each query, print in one line the similarity of the sets, in the percentage form accurate up to 1 decimal place.</p>
<h3 id="sample-input">Sample Input:</h3>
<pre><code class="language-in">3
3 99 87 101
4 87 101 5 87
7 99 101 18 5 135 18 99
2
1 2
1 3
</code></pre>
<h3 id="sample-output">Sample Output:</h3>
<pre><code class="language-out">50.0%
33.3%
</code></pre>
<hr>
<p>题目描述：求两个集合中，相同元素在两个集合中占比为多少。</p>
<p>输入数据：给n组集合，每组集合有m个元素，题目给出k组查询，每组询问两集合中相同元素的占比。</p>
<p>分析输入样例</p>
<p>查询1、2集合：相同数2（87 101）/总数4（87 101 99 87 5）=0.5<br>
查询1、3集合：相同数2（99 101）/总数6（99 87 101 18 5 135）=0.3</p>
<p>注意最后一个测试点容易超时，使用set的find()。</p>
<hr>
<pre><code class="language-C++">#include&lt;bits/stdc++.h&gt;
using namespace std;
vector&lt; set&lt;int&gt; &gt; v;
int main()
{
	int n, m, k, g;
	scanf(&quot;%d&quot;, &amp;n);
	v.resize(n+1);
	for(int i=1; i&lt;=n; i++){
		scanf(&quot;%d&quot;, &amp;m);
		for(int j=0; j&lt;m; j++){
			scanf(&quot;%d&quot;, &amp;g);
			v[i].insert(g);
		}
	}
	int count=0, all_num=0, a, b;
	scanf(&quot;%d&quot;, &amp;k);
	set&lt;int&gt;::iterator it;
	for(int i=0; i&lt;k; i++){
		scanf(&quot;%d %d&quot;, &amp;a, &amp;b);
		all_num = v[a].size()+v[b].size();
		count = 0;
		for(it=v[a].begin(); it!=v[a].end(); it++){
			if(v[b].find(*it)!=v[b].end()) count++;//在集合b中可以找到 
		}
		printf(&quot;%.1f%\n&quot;, count*100.0/(all_num-count));//共同的元素出现了两次 
	}
	return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[windows系统生成ssh key]]></title>
        <id>https://ygytl.github.io/post/windows-xi-tong-sheng-cheng-ssh-key/</id>
        <link href="https://ygytl.github.io/post/windows-xi-tong-sheng-cheng-ssh-key/">
        </link>
        <updated>2020-05-23T17:12:48.000Z</updated>
        <content type="html"><![CDATA[<h3 id="1-首先安装git工具运行git-bash输入指令进入ssh文件夹位置在桌面">1、首先安装Git工具，运行Git Bash，输入指令进入.ssh文件夹(位置在桌面)</h3>
<pre><code>cd ~/.ssh/
</code></pre>
<h3 id="2-如果提示-no-such-file-or-directory你可以手动的创建一个-ssh文件夹即可">2、 如果提示 “ No such file or directory”，你可以手动的创建一个 .ssh文件夹即可</h3>
<pre><code> mkdir ~/.ssh 
</code></pre>
<h3 id="3-配置全局的name和emailgithub的name和email">3、 配置全局的name和email，github的name和email</h3>
<pre><code> git config --global user.name &quot;yourname&quot;  

 git config --global user.email &quot;youremail@outlook.com&quot; 
</code></pre>
<h3 id="4-生成key">4、生成key</h3>
<pre><code> ssh-keygen -t rsa -C &quot;youremail@outlook.com&quot; 
</code></pre>
<p>连续按三次回车，这里设置的密码就为空了，并且创建了key。</p>
<p>最后得到了两个文件：id_rsa和id_rsa.pub</p>
<h3 id="5-打开id_rsapub复制里面的内容添加到你github就行了">5、 打开id_rsa.pub，复制里面的内容添加到你github就行了</h3>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Flask Vue.js全栈开发 第一章：创建github库与配置Flask]]></title>
        <id>https://ygytl.github.io/post/flask-vuejs-quan-zhan-kai-fa-di-yi-zhang-chuang-jian-di-yi-ge-flask-restful-api/</id>
        <link href="https://ygytl.github.io/post/flask-vuejs-quan-zhan-kai-fa-di-yi-zhang-chuang-jian-di-yi-ge-flask-restful-api/">
        </link>
        <updated>2020-05-23T17:05:23.000Z</updated>
        <content type="html"><![CDATA[<h2 id="1-1-创建github库">1-1. 创建github库</h2>
<ul>
<li>
<p>添加ssh keys</p>
<p>在Github <code>Settings</code>中找到<code>SSH and GPG keys</code>，单击<code>New SSH key</code>，复制公钥文件<code>id_rsa.pub</code>中的内容</p>
</li>
<li>
<p>测试ssh连接</p>
<p>在<code>Git Bash</code>中执行</p>
<pre><code>$ ssh -T git@github.com
</code></pre>
<p><code>Hi username! You've successfully authenticated, but GitHub does not provide shell access.</code>表示连接成功。</p>
</li>
</ul>
<h3 id="1-2-git-clone">1-2. git clone</h3>
<pre><code>cd /G/Python/flask/
git clone https://github.com/YGYtl/flask-vuejs-Graceblog.git
</code></pre>
<h3 id="1-3-分支管理">1-3. 分支管理</h3>
<pre><code>git checkout -b dev  //创建dev分支
git branch  //查看分支
</code></pre>
<h2 id="2-1-配置-flask">2-1. 配置 Flask</h2>
<ul>
<li>
<p>装python3</p>
</li>
<li>
<p>使用<code>命令窗口</code>，在文件夹<code>flask-vuejs-Graceblog</code>中创建目录back-end(文件夹)，这是<code>后端API应用</code>所在的位置</p>
</li>
<li>
<p>在back-end文件夹中，直接建立虚拟环境文件夹，同时生成虚拟环境 ，接着安装flask。</p>
<pre><code class="language-cmd">G:\flask-vuejs-Graceblog\back-end&gt;python -m venv venv  //建立虚拟环境文件夹，同时生成虚拟环境
G:\flask-vuejs-Graceblog\back-end&gt;venv\Scripts\activate  //通过\venv\Scripts\activate命令进入虚拟环境
(venv) G:\flask-vuejs-Graceblog\back-end&gt;pip install flask  //安装flask
(venv) G:\flask-vuejs-Graceblog\back-end&gt;pip freeze &gt; requirements.txt  //迁移模块
(venv) G:\flask-vuejs-Graceblog\back-end&gt;pip install python-dotenv  //加载读取环境变量信息的包
(venv) G:\flask-vuejs-Graceblog\back-end&gt;pip freeze &gt; requirements.txt  //迁移模块
</code></pre>
</li>
<li>
<p>在back-end文件夹中创建.gitignore文件：</p>
<pre><code>.idea/
__pycache__/
venv/
.env
app.db
yourblog.log*
</code></pre>
</li>
</ul>
<h3 id="2-2-应用工厂">2-2. 应用工厂</h3>
<ul>
<li>
<p>先在back-end文件夹下创建app文件夹，之后在app文件夹下创建__init__.py，创建Flask应用，代码如下：</p>
<pre><code class="language-python">from flask import Flask
from config import Config
def create_app(config_class=Config):
    app = Flask(__name__)
    app.config.from_object(config_class)
    
    #注册blueprint
    from app.api import bp as api_bp
    app.register_blueprint(api_bp, url_prefix='/api')
    return app
</code></pre>
</li>
</ul>
<h3 id="2-3-api蓝图">2-3. API蓝图</h3>
<ul>
<li>在app文件夹下创建api文件夹，新建__init__.py</li>
</ul>
<pre><code class="language-python">from flask import Blueprint
bp = Blueprint('api', __name__)
# 写在最后防止循环导入，ping.py文件也会导入 bp
from app.api import ping
</code></pre>
<ul>
<li>定义路由函数，在api文件夹下新建ping.py(客户端请求访问/ping时，响应并返回Pong!)</li>
</ul>
<pre><code class="language-python"> from flask import jsonify
 from app.api import bp
 @bp.route('/ping', methods=['GET'])
 def ping():
     '''前端Vue.js用来测试与后端Flask API的连通性'''
     return jsonify('Pong!')
</code></pre>
<h3 id="2-4-应用启动文件">2-4. 应用启动文件</h3>
<p>在back-end文件夹下新建Graceblog.py</p>
<pre><code class="language-python">from app import create_app
app = create_app()
</code></pre>
<h3 id="2-5-配置文件">2-5. 配置文件</h3>
<ul>
<li>
<p>在back-end文件夹下新建config.py</p>
<pre><code class="language-python">import os
from dotenv import load_dotenv
basedir = os.path.abspath(os.path.dirname(__file__))
load_dotenv(os.path.join(basedir, '.env'), encoding='utf-8')
class Config(object):
    pass
</code></pre>
</li>
<li>
<p>在back-end文件夹下新建.env</p>
<pre><code>FLASK_APP=Graceblog.py
FLASK_DEBUG=1
</code></pre>
</li>
</ul>
<h3 id="2-6-启动应用">2-6. 启动应用</h3>
<pre><code>(venv) G:\flask-vuejs-Graceblog\back-end&gt;flask run

尝试访问http://127.0.0.1:5000/api/ping
</code></pre>
<h3 id="2-7-git的一些操作">2-7. git的一些操作</h3>
<pre><code>举个栗子：
1、git branch显示*master，目前在master下

2、git checkout -b dev //新建并切换到dev分支下

3、git branch显示*dev，表示当前分支为dev

4、在dev分支下，加入要上传的文件为test.py
git add test.py
git commit -m &quot;dev分支的提交&quot;

5、git log --pretty=online //会显示dev分支的提交

6、dev分支完成，切换到master分支下
git checkout master

7、将master分支与dev分支合并
git merge dev

8、删除dev分支
git branch -D dev

9、将本地master分支上传到github仓库的master分支上
git push or git push -u origin master



git branch 分支名 // 新建分支
git branch // 查看当前所有分支
git checkout 分支名 // 检出分支
git checkout -b 分支名 // 创建并切换分支
git checkout commitId 文件名（文件路径下的文件名） 还原这个文件到对应的commitId的版本
git branch -v // 查看分支以及提交hash值和commit信息
git merge 分支名 // 把该分支的内容合并到现有分支上
git branch -d 分支名 // 删除分支
git branch -D 分支名 // 强制删除 若没有其他分支合并就删除 d会提示 D不会
git branch -m 旧分支名 新分支名 // 修改分支名
git branch -M 旧分支名 新分支名 // 修改分支名 M强制修改 若与其他分支有冲突也会创建(慎用)
git branch -r // 列出远程分支(远程所有分支名)
git branch -a // 查看远程分支(列出远程分支以及本地分支名)
git fetch // 更新remote索引
git push -u origin 分支名
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Markdown常用快捷键]]></title>
        <id>https://ygytl.github.io/post/markdown-chang-yong-kuai-jie-jian/</id>
        <link href="https://ygytl.github.io/post/markdown-chang-yong-kuai-jie-jian/">
        </link>
        <updated>2020-05-23T16:37:55.000Z</updated>
        <content type="html"><![CDATA[<h2 id="常用快捷键">常用快捷键：</h2>
<h4 id="插入代码~键3次-也就是三个">插入代码：(~键3次---也就是三个'`')</h4>
<pre><code>Ctrl + Shift + C
</code></pre>
<h4 id="插入链接">插入链接</h4>
<pre><code>Ctrl + K
</code></pre>
<h4 id="行内代码">行内代码</h4>
<pre><code>Ctrl + Shift + K
</code></pre>
<h4 id="无序列表">无序列表</h4>
<pre><code>Ctrl + Shift + L
</code></pre>
<h4 id="插入图片">插入图片</h4>
<pre><code>Ctrl + Shift + I
</code></pre>
<h4 id="撤销">撤销</h4>
<pre><code>Ctrl + Z
</code></pre>
<h4 id="n阶标题">n阶标题</h4>
<pre><code>Ctrl + N
</code></pre>
<h4 id="返回typora顶部">返回Typora顶部</h4>
<pre><code>Ctrl + Home
</code></pre>
<h4 id="返回typora底部">返回Typora底部</h4>
<pre><code>Ctrl + End
</code></pre>
<h4 id="创建表格">创建表格</h4>
<pre><code>Ctrl + T
</code></pre>
<h4 id="创建超链接">创建超链接</h4>
<pre><code>Ctrl + K
</code></pre>
<h4 id="搜索">搜索</h4>
<pre><code>Ctrl + F
</code></pre>
<h4 id="选中某句话">选中某句话</h4>
<pre><code>Ctrl + L
</code></pre>
<h4 id="选中某个单词">选中某个单词</h4>
<pre><code>Ctrl + D
</code></pre>
<h4 id="选中相同格式的文字">选中相同格式的文字</h4>
<pre><code>Ctrl + E
</code></pre>
<h4 id="搜索并替换">搜索并替换</h4>
<pre><code>Ctrl + H
</code></pre>
<h4 id="删除线">删除线</h4>
<pre><code>Alt + Shift + 5
</code></pre>
<h4 id="插入图片-2">插入图片</h4>
<pre><code>Ctrl + Shift + I
</code></pre>
<h4 id="公式块">公式块</h4>
<pre><code>Ctrl + Shift + M
</code></pre>
<h4 id="引用">引用</h4>
<pre><code>Ctrl + Shift + Q
</code></pre>
<h2 id="块元素">块元素：</h2>
<h4 id="转义字符">转义字符'\'</h4>
<pre><code>\   反斜线
`   反引号
*   星号
_   下划线
{}  花括号
[]  方括号
()  小括号
#   井字号
+   加号
-   减号
.   英文句点
!   感叹号
</code></pre>
<h4 id="标题级别">标题级别：#.......</h4>
<h4 id="引用文字-空格-引用文字">引用文字：&gt; + 空格 + 引用文字</h4>
<h4 id="无序列表使用-都可以后面要加个空格哦">无序列表：使用‘*‘、’+‘、’-’ 都可以(后面要加个空格哦)</h4>
<h4 id="有序列表1-2等等后面加个空格就行">有序列表：‘1.’、'2.'等等，后面加个空格就行</h4>
<h4 id="任务列表">任务列表</h4>
<pre><code>\-[]不勾选
\-[x]勾选
</code></pre>
<h4 id="插入表格弹出表格设置">插入表格(弹出表格设置)</h4>
<h4 id="分割线或-按回车即得分割线">分割线：***或---按回车即得分割线</h4>
<h4 id="设置目录">设置目录</h4>
<pre><code>[toc]回车即可
</code></pre>
<h4 id="内部链接">内部链接</h4>
<pre><code>[链接](http://example.com/ &quot;标题&quot;)
[链接](http://example.net/)
</code></pre>
<h4 id="图片">图片</h4>
<pre><code>![显示文字](C:\images\cat.png &quot;图片标题&quot;)
![显示文字](C:\images\cat.png)
还可以直接拖入
</code></pre>
<h4 id="斜体">斜体</h4>
<pre><code>*单个星号*  或者  _单个下划线_
</code></pre>
<h4 id="加粗">加粗</h4>
<pre><code>**两个星号** 或者  __两个下划线__
</code></pre>
<h4 id="删除线-2">删除线</h4>
<pre><code>~~删除线~~
</code></pre>
<h4 id="下划线">下划线</h4>
<pre><code>&lt;u&gt;下划线内容&lt;/u&gt; 或者 Ctrl + U
</code></pre>
<h4 id="表情符号">表情符号</h4>
<pre><code>:smile
</code></pre>
<h4 id="下标">下标</h4>
<pre><code>&lt;sub&gt;内容&lt;/sub&gt;
H&lt;sub&gt;2&lt;/sub&gt;O
</code></pre>
<h4 id="上标">上标</h4>
<pre><code>&lt;sup&gt;内容&lt;/sup&gt;
X&lt;sup&gt;2&lt;/sup&gt;
</code></pre>
<h4 id="高亮">高亮</h4>
<pre><code>==高亮==
</code></pre>
<h4 id="文本居中">文本居中</h4>
<pre><code>&lt;center&gt;重要的内容哦&lt;/center&gt;
</code></pre>
<h4 id="换行符">换行符</h4>
<pre><code>&lt;/br&gt; 或 空格+空格+Enter
</code></pre>
<h3 id="参考链接"><a href="https://www.cnblogs.com/hider/p/11614688.html">参考链接</a></h3>
]]></content>
    </entry>
</feed>