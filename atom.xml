<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://ygytl.github.io/</id>
    <title>Grace</title>
    <updated>2020-06-02T16:13:57.544Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://ygytl.github.io/"/>
    <link rel="self" href="https://ygytl.github.io/atom.xml"/>
    <subtitle>Grace&apos;s blog</subtitle>
    <logo>https://ygytl.github.io/images/avatar.png</logo>
    <icon>https://ygytl.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, Grace</rights>
    <entry>
        <title type="html"><![CDATA[1064 Complete Binary Search Tree (30分)题解]]></title>
        <id>https://ygytl.github.io/post/1064-complete-binary-search-tree-30-fen-ti-jie/</id>
        <link href="https://ygytl.github.io/post/1064-complete-binary-search-tree-30-fen-ti-jie/">
        </link>
        <updated>2020-06-02T16:06:30.000Z</updated>
        <content type="html"><![CDATA[<p>1064 Complete Binary Search Tree (30分)</p>
<p>A Binary Search Tree (BST) is recursively defined as a binary tree which has the following properties:</p>
<ul>
<li>The left subtree of a node contains only nodes with keys less than the node's key.</li>
<li>The right subtree of a node contains only nodes with keys greater than or equal to the node's key.</li>
<li>Both the left and right subtrees must also be binary search trees.</li>
</ul>
<p>A Complete Binary Tree (CBT) is a tree that is completely filled, with the possible exception of the bottom level, which is filled from left to right.</p>
<p>Now given a sequence of distinct non-negative integer keys, a unique BST can be constructed if it is required that the tree must also be a CBT. You are supposed to output the level order traversal sequence of this BST.</p>
<h3 id="input-specification">Input Specification:</h3>
<p>Each input file contains one test case. For each case, the first line contains a positive integer <em>N</em> (≤1000). Then <em>N</em> distinct non-negative integer keys are given in the next line. All the numbers in a line are separated by a space and are no greater than 2000.</p>
<h3 id="output-specification">Output Specification:</h3>
<p>For each test case, print in one line the level order traversal sequence of the corresponding complete binary search tree. All the numbers in a line must be separated by a space, and there must be no extra space at the end of the line.</p>
<h3 id="sample-input">Sample Input:</h3>
<pre><code class="language-in">10
1 2 3 4 5 6 7 8 9 0
</code></pre>
<h3 id="sample-output">Sample Output:</h3>
<pre><code class="language-out">6 3 8 1 5 7 9 0 2 4
</code></pre>
<hr>
<p>题目描述：给一棵完全二叉搜索树（满二叉搜索树），求输出它的层序遍历。</p>
<p>二叉搜索树的性质：</p>
<p>1、左子结点权值小于其父结点的权值</p>
<p>2、右子结点权值大于其父结点的权值</p>
<p>3、每个左右子结点都是二叉搜索树</p>
</br>
<p>输入：第一行n表示结点个数，第二行表示结点的权值。</p>
<p>输出：输出其层序遍历的结果</p>
</br>
<p>解题思路：不需要建树。先将各个结点的权值保存到数组中，接着将数组从小到大排序，以便放入正确的层序遍历数组中。通常将树放入数组中时，都会牺牲0号索引，从索引1开始存储。用递归算法就能获得层序遍历的结果，接下来利用题目给出的例子分析下这个递归算法。</p>
<p>样例构建出来的树长这样：<br>
<img src="file://G:/YGYtl.github.io/Gridea/post-images/1591114410643.jpg" width = "300" height = "200" alt="图片名称" align=center /></p>
<p>根据上图，可得到层序遍历数组：</p>
<table>
<thead>
<tr>
<th>index</th>
<th style="text-align:center">1</th>
<th style="text-align:center">2</th>
<th style="text-align:center">3</th>
<th style="text-align:center">4</th>
<th style="text-align:center">5</th>
<th style="text-align:center">6</th>
<th style="text-align:center">7</th>
<th style="text-align:center">8</th>
<th style="text-align:center">9</th>
<th style="text-align:center">10</th>
</tr>
</thead>
<tbody>
<tr>
<td>num</td>
<td style="text-align:center">6</td>
<td style="text-align:center">3</td>
<td style="text-align:center">8</td>
<td style="text-align:center">1</td>
<td style="text-align:center">5</td>
<td style="text-align:center">7</td>
<td style="text-align:center">9</td>
<td style="text-align:center">0</td>
<td style="text-align:center">2</td>
<td style="text-align:center">4</td>
</tr>
</tbody>
</table>
<p>现在模拟递归算法的过程：</p>
<p>n = 10</p>
<ol>
<li>
<p>root = 1，root&lt;=n为true，进入if语句中---后续还未完成</p>
</li>
<li>
<p>执行get_level(root*2)，即get_level(1*2)，root=2，root&lt;=n为true，进入if语句中---后续还未完成</p>
</li>
<li>
<p>执行get_level(root*2)，即get_level(2*2)，root=4，root&lt;=n为true，进入if语句中---后续还未完成</p>
</li>
<li>
<p>执行get_level(root*2)，即get_level(4*2)，root=8，root&lt;=n为true，进入if语句中---后续还未完成</p>
</li>
<li>
<p>执行get_level(roo*2)，即get_level(8*2)，root=16，root&lt;=n为false！<em>步骤 5)执行完毕</em>。返回上一条语句，即步骤 4)，执行未完成的部分。</p>
</li>
</ol>
<p>这时，步骤5) 返回到 步骤 4) 的后续执行步骤，root=8且c=0，level[root]=v[c++]即level[8]=v[0]，且c=1。</p>
<ol start="6">
<li>
<p>接着往下执行，root = 8， get_level(root*2+1)，即get_level(8*2+1)---步骤6)只是个过渡，已完成。</p>
</li>
<li>
<p>get_level(17)，root = 17，root&lt;=n为false！<em>步骤7) 执行完毕</em>。至此，<em>步骤4才真正执行完毕</em>。返回上一条语句，即步骤 3)，执行未完成的部分。</p>
</li>
</ol>
<p>这时，步骤7) 返回到 步骤3) 的后续执行步骤，root=4且c=1，level[root]=v[c++]即level[4]=v[1]，且c=2。</p>
<ol start="8">
<li>
<p>接着往下执行，root = 4，get_level(root*2+1)，即get_level(4*2+1)---步骤8)只是个过渡，已完成。</p>
</li>
<li>
<p>get_level(9)，root = 9，root&lt;=n为true，进入if语句中---后续还未完成</p>
</li>
<li>
<p>执行get_level(root*2)，即get_level(9*2)，root=18，root&lt;=n为false！<em>步骤10) 执行完毕</em>。返回到上一条语句，即步骤9)，执行未完成部分</p>
</li>
</ol>
<p>这时，步骤10) 返回到 步骤 9)的后续执行步骤，root=9且c=2，level[root]=v[c++]即level[9]=v[2]，且c=3。</p>
<ol start="11">
<li>
<p>接着往下执行，root = 9，get_level(root*2+1)，即get_level(9*2+1)---步骤11)只是个过渡，已完成。</p>
</li>
<li>
<p>get_level(19)，root = 19，root&lt;=n为false！至此，<em>步骤 9)执行完毕</em>，<em>步骤3)也执行完毕</em>。---步骤12)只是个过渡，已完成。</p>
</li>
<li>
<p>步骤12) 执行完比后，会返回上一个为执行完成的步骤，即步骤2)，往后以此类推。。。</p>
</li>
</ol>
</br>
<p>上述过程写的看似复杂，但是自己动手把数据带入进去，模拟一下就也就那么回事，不难不难。</p>
<hr>
<pre><code class="language-c++">#include&lt;bits/stdc++.h&gt;
using namespace std;
int n, c=0;
vector&lt;int&gt; level, v;
void get_level(int root){
	if(root&lt;=n){
		get_level(root*2);
		level[root] = v[c++];
		get_level(root*2+1);
	}
}
int main()
{
	scanf(&quot;%d&quot;, &amp;n);
	v.resize(n);
	level.resize(n+1);
	for(int i=0; i&lt;n; i++){
		scanf(&quot;%d&quot;, &amp;v[i]);
	}
	sort(v.begin() ,v.end());
	get_level(1);
	for(int i=1; i&lt;=n; i++){
		if(i!=1) printf(&quot; &quot;);
		printf(&quot;%d&quot;, level[i]);
	}
	return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[1053 Path of Equal Weight (30分)题解]]></title>
        <id>https://ygytl.github.io/post/1053-path-of-equal-weight-30-fen-ti-jie/</id>
        <link href="https://ygytl.github.io/post/1053-path-of-equal-weight-30-fen-ti-jie/">
        </link>
        <updated>2020-06-02T04:29:04.000Z</updated>
        <content type="html"><![CDATA[<p>1053 Path of Equal Weight (30分)</p>
<p>Given a non-empty tree with root <em>R</em>, and with weight <em>W**i</em> assigned to each tree node <em>T**i</em>. The <strong>weight of a path from *R* to *L*</strong> is defined to be the sum of the weights of all the nodes along the path from <em>R</em> to any leaf node <em>L</em>.</p>
<p>Now given any weighted tree, you are supposed to find all the paths with their weights equal to a given number. For example, let's consider the tree showed in the following figure: for each node, the upper number is the node ID which is a two-digit number, and the lower number is the weight of that node. Suppose that the given number is 24, then there exists 4 different paths which have the same given weight: {10 5 2 7}, {10 4 10}, {10 3 3 6 2} and {10 3 3 6 2}, which correspond to the red edges in the figure.</p>
<figure data-type="image" tabindex="1"><img src="https://images.ptausercontent.com/212" alt="img" loading="lazy"></figure>
<h3 id="input-specification">Input Specification:</h3>
<p>Each input file contains one test case. Each case starts with a line containing 0&lt;<em>N</em>≤100, the number of nodes in a tree, <em>M</em> (&lt;<em>N</em>), the number of non-leaf nodes, and 0&lt;<em>S</em>&lt;230, the given weight number. The next line contains <em>N</em> positive numbers where <em>W**i</em> (&lt;1000) corresponds to the tree node <em>T**i</em>. Then <em>M</em> lines follow, each in the format:</p>
<pre><code>ID K ID[1] ID[2] ... ID[K]
</code></pre>
<p>where <code>ID</code> is a two-digit number representing a given non-leaf node, <code>K</code> is the number of its children, followed by a sequence of two-digit <code>ID</code>'s of its children. For the sake of simplicity, let us fix the root ID to be <code>00</code>.</p>
<h3 id="output-specification">Output Specification:</h3>
<p>For each test case, print all the paths with weight S in <strong>non-increasing</strong> order. Each path occupies a line with printed weights from the root to the leaf in order. All the numbers must be separated by a space with no extra space at the end of the line.</p>
<p>Note: sequence {<em>A</em>1,<em>A</em>2,⋯,<em>A**n</em>} is said to be <strong>greater than</strong> sequence {<em>B</em>1,<em>B</em>2,⋯,<em>B**m</em>} if there exists 1≤<em>k</em>&lt;<em>m<strong>i</strong>n</em>{<em>n</em>,<em>m</em>} such that <em>A**i</em>=<em>B**i</em> for <em>i</em>=1,⋯,<em>k</em>, and <em>A**k</em>+1&gt;<em>B**k</em>+1.</p>
<h3 id="sample-input">Sample Input:</h3>
<pre><code class="language-in">20 9 24
10 2 4 3 5 10 2 18 9 7 2 2 1 3 12 1 8 6 2 2
00 4 01 02 03 04
02 1 05
04 2 06 07
03 3 11 12 13
06 1 09
07 2 08 10
16 1 15
13 3 14 16 17
17 2 18 19
</code></pre>
<h3 id="sample-output">Sample Output:</h3>
<pre><code class="language-out">10 5 2 7
10 4 10
10 3 3 6 2
10 3 3 6 2
</code></pre>
<hr>
<p>题目描述：现在有一棵树，让你找到根结点到叶子结点总权值为给定值的路径。</p>
</br>
<p>输入：n：节点总数，m：非叶子结点个数；s：假定要求的根节点到叶子节点总权值；接下来m行，包括id：结点编号，k：子结点个数，接下来k个子结点编号。</p>
<p>输出：根结点到叶子结点的过程中经过的总权值等于s，输出所经过结点的权值。</p>
</br>
<p>解题思路：这道题不用建树，用有向图保存这棵树就行。可以用BFS算法或DFS算法。</p>
<p>这里列举BFS算法详解：每个结点的权值保存在weight数组中，边的关系保存在G邻接表中。从root结点层层遍历，很简单的就可以得到根节点到各个叶子结点的总权值了。最重要的还是输出顺序的问题，我先将符合条件的路径权值数组存入ans二维数组容器中，最后将二维数组进行排序。排序规则是每个数组中同一位置的权值最大的序列排在前面输出。</p>
<hr>
<pre><code class="language-c++">//BFS 广度优先
#include&lt;bits/stdc++.h&gt;
using namespace std;
struct node{
	int id;
	long long ss;
	vector&lt;int&gt; list;
	node(){
		ss = 0;
	}
};
int n, m;
long long s;
const int maxn = 220;
int weight[maxn];
vector&lt;int&gt; G[maxn];
vector&lt; vector&lt;int&gt; &gt; ans;
bool cmp(vector&lt;int&gt; a, vector&lt;int&gt; b){
	int l=0;
	l = min(a.size(),b.size());
	for(int i=0; i&lt;l; i++){
		if(a[i]==b[i]) continue;
		else return a[i] &gt; b[i];
	}
	return false; //如果没有，最后一个测试点段错误! 
}
void bfs(int root){
	node t, tt;
	queue&lt;node&gt; q;
	t.id = root; t.ss = weight[root];
	t.list.push_back(weight[root]);
	q.push(t);
	
	int u, v;
	while(!q.empty()){
		t = q.front();
		u = t.id;
		q.pop();
		if(t.ss==s&amp;&amp;G[u].size()==0){
			ans.push_back(t.list);
			continue;
		}
		else if(t.ss &gt; s) continue;
		for(int i=0; i&lt;G[u].size(); i++){
			v = G[u][i];
			tt.id = v; tt.ss = t.ss + weight[v]; tt.list = t.list;
			tt.list.push_back(weight[v]);
			q.push(tt);
		}
	}
	sort(ans.begin(),ans.end(),cmp);
	
	for(int i=0; i&lt;ans.size(); i++){
		for(int j=0; j&lt;ans[i].size(); j++){
			if(j) printf(&quot; &quot;);
			printf(&quot;%d&quot;, ans[i][j]);
		}
		printf(&quot;\n&quot;);
	}
}
int main()
{
	scanf(&quot;%d %d %lld&quot;, &amp;n, &amp;m, &amp;s);
	int id, k, g;
	for(int i=0; i&lt;n; i++) scanf(&quot;%d&quot;, &amp;weight[i]);
	for(int i=0; i&lt;m; i++){
		scanf(&quot;%d %d&quot;, &amp;id, &amp;k);
		for(int j=0; j&lt;k; j++){
			scanf(&quot;%d&quot;, &amp;g);
			G[id].push_back(g);
		}
	}
	bfs(0);
	return 0;
}
</code></pre>
<pre><code class="language-c++">//DFS 深度优先
#include&lt;bits/stdc++.h&gt;
using namespace std;
struct node{
	int w;
	vector&lt;int&gt; child;
};
vector&lt;node&gt; v;
vector&lt;int&gt; path;
int target;
void dfs(int index, int nodenum, int sum){
	if(sum&gt;target) return ;
	if(sum==target){
		if(v[index].child.size()!=0) return;
		for(int i=0; i&lt;nodenum; i++){
			printf(&quot;%d%c&quot;, v[path[i]].w, i!=nodenum-1?' ':'\n');
		}
		return;
	}
	for(int i=0; i&lt;v[index].child.size(); i++){
		int nd = v[index].child[i];
		path[nodenum] = nd;
		dfs(nd,nodenum+1,sum+v[nd].w);
	}
}
int cmp(int a, int b){
	return v[a].w &gt; v[b].w;
}
int main()
{
	int n, m, node, k;
	scanf(&quot;%d %d %d&quot;, &amp;n, &amp;m, &amp;target);
	v.resize(n), path.resize(n);
	for(int i=0; i&lt;n; i++){
		scanf(&quot;%d&quot;, &amp;v[i].w);
	}
	for(int i=0; i&lt;m; i++){
		scanf(&quot;%d %d&quot;, &amp;node, &amp;k);
		v[node].child.resize(k);
		for(int j=0; j&lt;k; j++) scanf(&quot;%d&quot;, &amp;v[node].child[j]);
		sort(v[node].child.begin(),v[node].child.end(),cmp);
	}
	dfs(0,1,v[0].w);
	return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[1069 The Black Hole of Numbers (20分)题解]]></title>
        <id>https://ygytl.github.io/post/1069-the-black-hole-of-numbers-20-fen-ti-jie/</id>
        <link href="https://ygytl.github.io/post/1069-the-black-hole-of-numbers-20-fen-ti-jie/">
        </link>
        <updated>2020-06-02T02:55:21.000Z</updated>
        <content type="html"><![CDATA[<p>1069 The Black Hole of Numbers (20分)</p>
<p>For any 4-digit integer except the ones with all the digits being the same, if we sort the digits in non-increasing order first, and then in non-decreasing order, a new number can be obtained by taking the second number from the first one. Repeat in this manner we will soon end up at the number <code>6174</code> -- the <strong>black hole</strong> of 4-digit numbers. This number is named Kaprekar Constant.</p>
<p>For example, start from <code>6767</code>, we'll get:</p>
<pre><code>7766 - 6677 = 1089
9810 - 0189 = 9621
9621 - 1269 = 8352
8532 - 2358 = 6174
7641 - 1467 = 6174
... ...
</code></pre>
<p>Given any 4-digit number, you are supposed to illustrate the way it gets into the black hole.</p>
<h3 id="input-specification">Input Specification:</h3>
<p>Each input file contains one test case which gives a positive integer <em>N</em> in the range (0,10<sup>4</sup>).</p>
<h3 id="output-specification">Output Specification:</h3>
<p>If all the 4 digits of <em>N</em> are the same, print in one line the equation <code>N - N = 0000</code>. Else print each step of calculation in a line until <code>6174</code> comes out as the difference. All the numbers must be printed as 4-digit numbers.</p>
<h3 id="sample-input-1">Sample Input 1:</h3>
<pre><code class="language-in">6767
</code></pre>
<h3 id="sample-output-1">Sample Output 1:</h3>
<pre><code class="language-out">7766 - 6677 = 1089
9810 - 0189 = 9621
9621 - 1269 = 8352
8532 - 2358 = 6174
</code></pre>
<h3 id="sample-input-2">Sample Input 2:</h3>
<pre><code class="language-in">2222
</code></pre>
<h3 id="sample-output-2">Sample Output 2:</h3>
<pre><code class="language-out">2222 - 2222 = 0000
</code></pre>
<hr>
<p>题目描述：有一个小于10000的数n，n中的每一个数字重新排序，可以组成最大数和最小数，例如1001，可以重新排序得到max=1100，min=0011，用max - min得到的值进行循环，最终会得到6174或0000。现在就是要将求得6174或0000的过程模拟出来。</p>
</br>
<p>输入：小于10000的数</p>
<p>输出：输出max - min的计算结果为6174或0000的过程</p>
</br>
<p>解题思路：利用sscanf和sprintf两个函数进行模拟，使用字符的形式进行排序。注意以数字形式输出是，不满4 digits在前面要补0。</p>
<hr>
<pre><code class="language-c++">#include&lt;bits/stdc++.h&gt;
using namespace std;
int main()
{
	int val1, val2;
	int n;
	scanf(&quot;%d&quot;, &amp;n);
	char s[10];
	while(n){
		sprintf(s, &quot;%04d&quot;, n);// 发送格式化输出到 s
		sort(s,s+4);
		sscanf(s, &quot;%d&quot;, &amp;val2);//从字符串读取格式化输入 s -&gt; val2
		reverse(s,s+4);
		sscanf(s, &quot;%d&quot;, &amp;val1);//s -&gt;val1
		int g = val1 - val2;
		printf(&quot;%04d - %04d = %04d\n&quot;, val1, val2, g);
		if(g==0 || g==6174) break;
		n = g;
	}
	return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[1071 Speech Patterns (25分)题解]]></title>
        <id>https://ygytl.github.io/post/1071-speech-patterns-25-fen-ti-jie/</id>
        <link href="https://ygytl.github.io/post/1071-speech-patterns-25-fen-ti-jie/">
        </link>
        <updated>2020-06-01T14:54:10.000Z</updated>
        <content type="html"><![CDATA[<p>1071 Speech Patterns (25分)</p>
<p>People often have a preference among synonyms of the same word. For example, some may prefer &quot;the police&quot;, while others may prefer &quot;the cops&quot;. Analyzing such patterns can help to narrow down a speaker's identity, which is useful when validating, for example, whether it's still the same person behind an online avatar.</p>
<p>Now given a paragraph of text sampled from someone's speech, can you find the person's most commonly used word?</p>
<h3 id="input-specification">Input Specification:</h3>
<p>Each input file contains one test case. For each case, there is one line of text no more than 1048576 characters in length, terminated by a carriage return <code>\n</code>. The input contains at least one alphanumerical character, i.e., one character from the set [<code>0-9 A-Z a-z</code>].</p>
<h3 id="output-specification">Output Specification:</h3>
<p>For each test case, print in one line the most commonly occurring word in the input text, followed by a space and the number of times it has occurred in the input. If there are more than one such words, print the lexicographically smallest one. The word should be printed in all lower case. Here a &quot;word&quot; is defined as a continuous sequence of alphanumerical characters separated by non-alphanumerical characters or the line beginning/end.</p>
<p>Note that words are case <strong>insensitive</strong>.</p>
<h3 id="sample-input">Sample Input:</h3>
<pre><code class="language-in">Can1: &quot;Can a can can a can?  It can!&quot;
</code></pre>
<h3 id="sample-output">Sample Output:</h3>
<pre><code class="language-out">can 5
</code></pre>
<hr>
<p>题目描述：求给定的字符串中，出现次数最多的单词，这些单词由数字、大小写字母组成。</p>
</br>
<p>输入：一串字符串</p>
<p>输出：出现最多的单词及出现次数<br>
</br></p>
<p>解题思路：getline函数读取所有字符，要在读入所有字符后加一个字符'.'，当读入的最后一个字符是数字或者大小写字母时，比较容易将最后一个单词切分出来。接着，根据特殊字符来切分单词，并用map&lt;string,int&gt;来记录每个单词出现的次数。在记录的同时，我们也可以把答案顺便找出来。用ans和count两个量简单比较就行了。</p>
<p>注意：最后一个测试点就是卡在最后一个单词有没有正确切分并计数。</p>
<hr>
<pre><code class="language-c++">#include&lt;bits/stdc++.h&gt;
using namespace std;
map&lt;string,int&gt; p;
int main()
{
	string s, t=&quot;&quot;;
	getline(cin,s);
	s += '.';//不加最后一个测试点会错 
	int l = s.length();
	string ans=&quot;&quot;;
	int count = 0;
	for(int i=0; i&lt;l; i++){
		if(s[i]&gt;='0'&amp;&amp;s[i]&lt;='9'){
			t += s[i];
		}
		else if(s[i]&gt;='A'&amp;&amp;s[i]&lt;='Z'){
			t += s[i]-'A'+'a';
		}
		else if(s[i]&gt;='a'&amp;&amp;s[i]&lt;='z'){
			t += s[i];
		}
		else{
			if(t.length()!=0) p[t]++;
			if(p[t]==count){
				ans = t &lt; ans ? t : ans;
			}
			else if(p[t]&gt;count){
				count = p[t];
				ans = t;
			}
			t = &quot;&quot;;
		}
	}
	cout &lt;&lt; ans &lt;&lt; &quot; &quot; &lt;&lt; count &lt;&lt; endl;
	return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[P2 并发与并行的区别、同步与异步的解析]]></title>
        <id>https://ygytl.github.io/post/p2-bing-fa-yu-bing-xing-de-qu-bie-tong-bu-yu-yi-bu-de-jie-xi/</id>
        <link href="https://ygytl.github.io/post/p2-bing-fa-yu-bing-xing-de-qu-bie-tong-bu-yu-yi-bu-de-jie-xi/">
        </link>
        <updated>2020-06-01T06:23:42.000Z</updated>
        <content type="html"><![CDATA[<h2 id="并发与并行的区别">并发与并行的区别</h2>
<h3 id="并发">并发</h3>
<p>并发：每个时间段只允许处理一个进程<br>
多个进程看似在同步运行，但并非正正的在同一时刻同时运行<br>
例如：一个人一边在煮菜，一边在看书，他不可能在煮菜时同时看书，<br>
只能先把菜放入锅里煮时，抽空走出厨房，回到房里看书，当菜煮好了，<br>
又要放下书，回去把菜翻炒翻炒。炒菜和看书看似同时进行，但实际上，<br>
炒菜和看书，一个时间段只能处理其一。</p>
<h3 id="并行">并行</h3>
<p>并行：多个进程在同一时刻同时运行<br>
例如：类似有多核CPU处理程序，还是炒菜和看书的例子，<br>
就就好像有两个人在处理，一个人在炒菜，同时，另一个人在看书，<br>
这两件事是同一时刻同时进行的。</p>
<p>Python中如何实现并发进程？？？<br>
利用 多进程、多线程、异步编程即可</p>
<p>Multiple Processes<br>
抢占式多任务，操作系统调度，可使用多核CPU</p>
<p>Multiple Threads<br>
抢占式多任务，操作系统调度，不能使用多核CPU</p>
<p>Asynchronous Programming<br>
协作式多任务，单进程、单线程</p>
<h2 id="同步与异步">同步与异步</h2>
<p>先看同步对弈和异步对弈</p>
<p>前提条件：假设A要与B<sub>1</sub> ~ B<sub>12</sub> 对弈，A思考需要5s，B<sub>1</sub> ~ B<sub>12</sub> 中，每个人要思考55s，对局需要30个回合才能分输赢，下棋时常忽略不计。</p>
<p>同步对弈 Synchronous<br>
同步对弈指：A与B<sub>1</sub>对弈完成后，才开始与B<sub>2</sub>对弈，以此类推，所以A走完30个回合的总时间是(5+55)*30*12=21600s</p>
<p>异步对弈 Asychronous<br>
异步对弈指：A与B<sub>1</sub>对弈时，A先下花了5s与B<sub>1</sub>下第一回合，B<sub>1</sub>需要花55s的时间思考，A不等待B<sub>1</sub>，直接与B<sub>2</sub>对弈，一直到与B<sub>12</sub>对弈了后，才返回跟B<sub>1</sub>对弈。而这时，A走完每个棋局的第一步需要花费12*5=60s，60s过去B<sub>1</sub>已经走完第一步，A与B<sub>1</sub>进行第二回合的对弈。A走完30个回合的总时间是60*30=1800s</p>
<p>21600/1800 = 12，异步对弈效率提高了12倍</p>
<h3 id="异步编程">异步编程：</h3>
<p>指在 单线程 中 并发 执行多个任务，当一个任务在等待数据时，它会释放 CPU 资源，</p>
<p>转而执行其它任务，通过程序员自己主动切换任务来最小化空闲时间。<br>
异步实现：异步函数在等待数据时被暂停执行，当数据到达时，又能够在被暂停的位置处恢复执行。</p>
<h3 id="异步-io-操作">异步 I/O 操作</h3>
<p>指当你发起一个 I/O 操作（比如，等待网络图片数据的到来），却不用等它结束，<br>
你可以继续去做其它的事情，当它结束时，你会得到通知，然后再回来接着处理这个 I/O 后续的操作。<br>
而 同步 I/O 操作 则会被阻塞在 I/O 操作上直到它完成，这期间 CPU 做了很多事，只是没有运行你的程序。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[1066 Root of AVL Tree (25分)题解]]></title>
        <id>https://ygytl.github.io/post/1066-root-of-avl-tree-25-fen-ti-jie/</id>
        <link href="https://ygytl.github.io/post/1066-root-of-avl-tree-25-fen-ti-jie/">
        </link>
        <updated>2020-06-01T05:10:53.000Z</updated>
        <content type="html"><![CDATA[<p>1066 Root of AVL Tree (25分)</p>
<p>An AVL tree is a self-balancing binary search tree. In an AVL tree, the heights of the two child subtrees of any node differ by at most one; if at any time they differ by more than one, rebalancing is done to restore this property. Figures 1-4 illustrate the rotation rules.</p>
<p><img src="https://images.ptausercontent.com/31" alt="img" loading="lazy">  <img src="https://images.ptausercontent.com/32" alt="img" loading="lazy"></p>
<p><img src="https://images.ptausercontent.com/33" alt="img" loading="lazy"> <img src="https://images.ptausercontent.com/34" alt="img" loading="lazy"></p>
<p>Now given a sequence of insertions, you are supposed to tell the root of the resulting AVL tree.</p>
<h3 id="input-specification">Input Specification:</h3>
<p>Each input file contains one test case. For each case, the first line contains a positive integer <em>N</em> (≤20) which is the total number of keys to be inserted. Then <em>N</em> distinct integer keys are given in the next line. All the numbers in a line are separated by a space.</p>
<h3 id="output-specification">Output Specification:</h3>
<p>For each test case, print the root of the resulting AVL tree in one line.</p>
<h3 id="sample-input-1">Sample Input 1:</h3>
<pre><code class="language-in">5
88 70 61 96 120
</code></pre>
<h3 id="sample-output-1">Sample Output 1:</h3>
<pre><code class="language-out">70
</code></pre>
<h3 id="sample-input-2">Sample Input 2:</h3>
<pre><code>7
88 70 61 96 120 90 65
</code></pre>
<h3 id="sample-output-2">Sample Output 2:</h3>
<pre><code>88
</code></pre>
<hr>
<p>题目描述：平衡二叉搜索树(AVL Tree)是能够自我调整到平衡的一棵树；何为平衡二叉搜索树？</p>
<p>1、左子树与右子树高度之差的绝对值不超过1<br>
2、树的每个左子树和右子树都是AVL树<br>
3、每一个节点都有一个平衡因子（balance factor），任一节点的平衡因子是-1、0、1（每一个节点的平衡因子 = 右子树高度 - 左子树高度）</p>
<p>现在就是要构建一棵AVL树。</p>
</br>
<p>输入：第一行n为节点数；第二行n个数，为要插入的元素。</p>
<p>输出：将构建的AVL数的根节点输出。</p>
</br>
<p>解题思路：构建一棵树，用结构体记录每个节点的信息，包括节点的值、左右子树的指针；一开始很难理解怎么转，仔细分析下，也就四种旋转（左旋转，右旋转，左右旋转、右左旋转），有点蒙？画个图就清晰了。灵魂画手上线：</p>
<p>1、右旋转：插入的是数据C，C&lt;B&lt;A</p>
<figure data-type="image" tabindex="1"><img src="https://ygytl.github.io//post-images/1590988367275.jpg" alt="img" loading="lazy"></figure>
<p>2、左右旋转：插入的是数据C，B&lt;C&lt;A</p>
<figure data-type="image" tabindex="2"><img src="https://ygytl.github.io//post-images/1590988395061.jpg" alt="img" loading="lazy"></figure>
<p>3、左旋转：插入数据是C，C&gt;B&gt;A</p>
<p><img src="https://ygytl.github.io//post-images/1590988401828.jpg" alt="img" loading="lazy"><br>
4、右左旋转：插入数据是C，B&gt;C&gt;A</p>
<figure data-type="image" tabindex="3"><img src="https://ygytl.github.io//post-images/1590988409815.jpg" alt="img" loading="lazy"></figure>
<hr>
<pre><code class="language-c++">#include&lt;bits/stdc++.h&gt;
using namespace std;
struct node{
	int val;
	node *left, *right;
};

node *routerRight(node *root){
	node *t = NULL;
	t = root-&gt;left;
	root-&gt;left = t-&gt;right;
	t-&gt;right = root;
	return t;
}
node *routerLeft(node *root){
	node *t = NULL;
	t = root-&gt;right;
	root-&gt;right = t-&gt;left;
	t-&gt;left = root;
	return t;
}

node *routerLeftRight(node *root){
	root-&gt;left = routerLeft(root-&gt;left);
	return routerRight(root);
}

node *routerRightLeft(node *root){
	root-&gt;right = routerRight(root-&gt;right);
	return routerLeft(root);
}

int height(node *root){
	if(root==NULL) return 0;
	return max(height(root-&gt;left),height(root-&gt;right))+1;
}
node *insert(node *root, int val){
	if(root==NULL){
		root = new node();
		root-&gt;val = val;
		root-&gt;left = root-&gt;right = NULL;
	}
	else if(val &lt; root-&gt;val){
		root-&gt;left = insert(root-&gt;left,val);
		if(height(root-&gt;left)-height(root-&gt;right)==2){
			root = val &lt; root-&gt;left-&gt;val ? routerRight(root):routerLeftRight(root);
		}
	}
	else{
		root-&gt;right = insert(root-&gt;right,val);
		if(height(root-&gt;right)-height(root-&gt;left)==2){
			root = val &gt; root-&gt;right-&gt;val ? routerLeft(root):routerRightLeft(root); 
		}
	}
	return root;
}
int n;
int main()
{
	int m;
	scanf(&quot;%d&quot;, &amp;n);
	node *root = NULL;
	for(int i=0; i&lt;n; i++){
		scanf(&quot;%d&quot;, &amp;m);
		root = insert(root,m);
	}
	printf(&quot;%d&quot;, root-&gt;val);
	return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[P3 同步阻塞下载]]></title>
        <id>https://ygytl.github.io/post/p3-tong-bu-zu-sai-xia-zai/</id>
        <link href="https://ygytl.github.io/post/p3-tong-bu-zu-sai-xia-zai/">
        </link>
        <updated>2020-05-31T03:18:14.000Z</updated>
        <content type="html"><![CDATA[<h3 id="环境搭建">环境搭建</h3>
<h4 id="安装centos7并配置nginx">安装centos7并配置nginx</h4>
<pre><code>1. 添加repo源
# vi /etc/yum.repos.d/nginx.repo

内容如下:
[nginx]
name=nginx repo
baseurl=http://nginx.org/packages/centos/7/$basearch/
gpgcheck=0
enabled=1

2. 安装
# yum install -y nginx

3. 启动
# systemctl start nginx
# systemctl enable nginx
</code></pre>
<h3 id="同步阻塞">同步阻塞</h3>
<h4 id="11-在windows下创建文件夹test在文件夹下创建日志模块loggerpy后续windows文件都放入同一个文件夹下">1.1 在windows下创建文件夹test，在文件夹下创建日志模块logger.py(后续windows文件都放入同一个文件夹下)</h4>
<pre><code class="language-python">import os
import time
import logging

logger = logging.getLogger('aiotest')
logger.setLevel(logging.DEBUG)
formatter = logging.Formatter(
    '%(asctime)s - %(filename)s[line:%(lineno)d] - &lt;%(threadName)s %(thread)d&gt;' +
    '- &lt;Process %(process)d&gt; - %(levelname)s: %(message)s'
)

basedir = os.path.abspath(os.path.dirname(__file__))
log_dest = os.path.join(basedir, 'logs')  # 日志文件所在目录
if not os.path.isdir(log_dest):
    os.mkdir(log_dest)
filename = time.strftime('%Y-%m-%d-%H-%M-%S', time.localtime(time.time())) + '.log'  file_handler = logging.FileHandler(os.path.join(log_dest, filename))  # 创建日志文件handler
file_handler.setFormatter(formatter)  # 设置Formatter
file_handler.setLevel(logging.INFO)  # 单独设置日志文件的日志级别

stream_handler = logging.StreamHandler()
stream_handler.setFormatter(formatter)
# stream_handler.setLevel(logging.INFO)  # 单独设置控制台日志的日志级别，注释掉则使用总日志级别
logger.addHandler(file_handler)
logger.addHandler(stream_handler)
</code></pre>
<h4 id="12-在centos中放入文件flagstargz">1.2 在centos中放入文件flags.tar.gz</h4>
<pre><code>将flags.tar.gz文件导入到/usr/share/nginx/html中，并解压tar xf flags.tar.gz
#cd /usr/share/nginx/html
#ls flags &gt; flags.txt
将flags文件夹下的文件名写入flags.txt中，以便后续使用
</code></pre>
<h4 id="13-在windows下创建commonpy">1.3 在windows下创建common.py</h4>
<pre><code class="language-python">import os
import time
import requests
from logger import logger

basepath = os.path.abspath(os.path.dirname(__file__))  # 当前模块文件的根目录

def setup_down_path():
    '''设置图片下载后的保存位置，所有图片放在同一个目录下'''
    down_path = os.path.join(basepath, 'downloads')
    if not os.path.isdir(down_path):
        os.mkdir(down_path)
        logger.info('Create download path {}'.format(down_path))
    return down_path

def get_links():
    '''获取所有图片的下载链接'''
    with open(os.path.join(basepath, 'flags.txt')) as f:
        return ['http://192.168.157.134/flags/' + flag.strip() for flag in f.readlines()]


def download_one(image):  #后续多线程时concurrent.futures.ThreadPoolExecutor.map()
    '''
    下载一张图片
    param image: 字典，包括图片的保存目录、图片的序号、图片的URL
    '''
    logger.info('Downloading No.{} [{}]'.format(image['linkno'], image['link']))
    t0 = time.time()

    resp = requests.get(image['link'])
    filename = os.path.split(image['link'])[1]
    with open(os.path.join(image['path'], filename), 'wb') as f:
        f.write(resp.content)  # resp.content是bytes类型，而resp.text是str类型

    t1 = time.time()
    logger.info('Task No.{} [{}] runs {} seconds.'.format(image['linkno'], image['link'], t1 - t0))
</code></pre>
<h4 id="14-在windows下创建sequentialpy">1.4  在windows下创建sequential.py</h4>
<pre><code class="language-python">import time
from common import setup_down_path, get_links, download_one
from logger import logger

def download_many():
    '''依序下载所有图片，同步阻塞'''
    down_path = setup_down_path()
    links = get_links()

    for linkno, link in enumerate(links, 1):
        image = {
            'path': down_path,
            'linkno': linkno,  # 图片序号，方便日志输出时，正在下载哪一张
            'link': link
        }
        download_one(image)

    return len(links)

if __name__ == '__main__':
    t0 = time.time()
    count = download_many()
    msg = '{} flags downloaded in {} seconds.'
    logger.info(msg.format(count, time.time() - t0))
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[1067 Sort with Swap(0, i) (25分)题解]]></title>
        <id>https://ygytl.github.io/post/1067-sort-with-swap0-i-25-fen/</id>
        <link href="https://ygytl.github.io/post/1067-sort-with-swap0-i-25-fen/">
        </link>
        <updated>2020-05-29T07:32:54.000Z</updated>
        <content type="html"><![CDATA[<p>1067 Sort with Swap(0, i) (25分)</p>
<p>Given any permutation of the numbers {0, 1, 2,..., <em>N</em>−1}, it is easy to sort them in increasing order. But what if <code>Swap(0, *)</code> is the ONLY operation that is allowed to use? For example, to sort {4, 0, 2, 1, 3} we may apply the swap operations in the following way:</p>
<pre><code>Swap(0, 1) =&gt; {4, 1, 2, 0, 3}
Swap(0, 3) =&gt; {4, 1, 2, 3, 0}
Swap(0, 4) =&gt; {0, 1, 2, 3, 4}
</code></pre>
<p>Now you are asked to find the minimum number of swaps need to sort the given permutation of the first <em>N</em> nonnegative integers.</p>
<h3 id="input-specification">Input Specification:</h3>
<p>Each input file contains one test case, which gives a positive <em>N</em> (≤105) followed by a permutation sequence of {0, 1, ..., <em>N</em>−1}. All the numbers in a line are separated by a space.</p>
<h3 id="output-specification">Output Specification:</h3>
<p>For each case, simply print in a line the minimum number of swaps need to sort the given permutation.</p>
<h3 id="sample-input">Sample Input:</h3>
<pre><code class="language-in">10
3 5 7 2 6 4 9 0 8 1
</code></pre>
<h3 id="sample-output">Sample Output:</h3>
<pre><code class="language-out">9
</code></pre>
<hr>
<p>题目描述：只能与0交换，求得到正确序列所需最少交换次数。</p>
<p>解题思路：找到序列中值与位置不匹配的元素，进行循环交换，将他们放回正确的位置，当该元素不为0时，交换次数要另外加2。</p>
<hr>
<pre><code class="language-c++">#include&lt;bits/stdc++.h&gt;
using namespace std;
int main()
{
	int n;
	vector&lt;int&gt; v;
	scanf(&quot;%d&quot;, &amp;n);
	v.resize(n);
	for(int i=0; i&lt;n; i++){
		scanf(&quot;%d&quot;, &amp;v[i]);
	}
	int ans = 0;
	for(int i=0; i&lt;n; i++){
		if(v[i]==i) continue;
		while(v[i]!=i){
			swap(v[i],v[v[i]]);
			ans++;
		}
		if(i!=0) ans+=2;
	}
	printf(&quot;%d\n&quot;, ans);
	return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[1065 A+B and C (64bit) (20分)题解]]></title>
        <id>https://ygytl.github.io/post/1065-ab-and-c-64bit-20-fen-ti-jie/</id>
        <link href="https://ygytl.github.io/post/1065-ab-and-c-64bit-20-fen-ti-jie/">
        </link>
        <updated>2020-05-29T02:42:07.000Z</updated>
        <content type="html"><![CDATA[<p>1065 A+B and C (64bit) (20分)</p>
<p>Given three integers <em>A</em>, <em>B</em> and <em>C</em> in [−2<sup>63</sup>,2<sup>63</sup>], you are supposed to tell whether <em>A</em>+<em>B</em>&gt;<em>C</em>.</p>
<h3 id="input-specification">Input Specification:</h3>
<p>The first line of the input gives the positive number of test cases, <em>T</em> (≤10). Then <em>T</em> test cases follow, each consists of a single line containing three integers <em>A</em>, <em>B</em> and <em>C</em>, separated by single spaces.</p>
<h3 id="output-specification">Output Specification:</h3>
<p>For each test case, output in one line <code>Case #X: true</code> if <em>A</em>+<em>B</em>&gt;<em>C</em>, or <code>Case #X: false</code> otherwise, where <em>X</em> is the case number (starting from 1).</p>
<h3 id="sample-input">Sample Input:</h3>
<pre><code class="language-in">3
1 2 3
2 3 4
9223372036854775807 -9223372036854775808 0
</code></pre>
<h3 id="sample-output">Sample Output:</h3>
<pre><code class="language-out">Case #1: false
Case #2: true
Case #3: false
</code></pre>
<hr>
<p>题目描述：A+B&gt;C，真返回true，假返回false</p>
<p>解题思路：一看就是大数据处理，long double类型杠，或者对数据处理一下</p>
<p>注：a&gt;&gt;1 与 a/2有区别，(a&amp;1) 与 a%2有区别，a+b==c 与 (g=a+b),g==c有区别</p>
<hr>
<p>方法一：</p>
<pre><code class="language-C++">#include&lt;bits/stdc++.h&gt;
using namespace std ;
int main()
{
    int n;
    scanf(&quot;%d&quot;, &amp;n);
    for( int i=1; i&lt;=n; i++){
        long double a, b, c;
        scanf(&quot;%Lf %Lf %Lf&quot;, &amp;a, &amp;b, &amp;c);
        printf(&quot;Case #%d: &quot;, i);
        if(a+b&gt;c) printf(&quot;yes\n&quot;);
        else printf(&quot;false\n&quot;);
    }
    return 0 ;
}
</code></pre>
<p>方法二：</p>
<pre><code class="language-c++">#include&lt;bits/stdc++.h&gt;
using namespace std;
int main()
{
	long long a, b, c;
	int n;
	scanf(&quot;%d&quot;, &amp;n);
	for(int i=1; i&lt;=n; i++){
		scanf(&quot;%lld %lld %lld&quot;, &amp;a, &amp;b, &amp;c);
		long long ta, tb, tc;
		ta = a&gt;&gt;1;
		tb = b&gt;&gt;1;
		tc = c&gt;&gt;1;
		printf(&quot;Case #%d: &quot;, i);
		if(ta+tb&gt;tc){
			printf(&quot;true\n&quot;);
		}
		else if(ta+tb==tc&amp;&amp;((a&amp;1)+(b&amp;1)&gt;(c&amp;1))){
			printf(&quot;true\n&quot;);
		}
		else printf(&quot;false\n&quot;);
	}
	return 0;
}
</code></pre>
<p>方法三：</p>
<pre><code class="language-python">n = int(input())
for i in range(1,n+1):
    g = input().split()
    a = int(g[0])
    b = int(g[1])
    c = int(g[2])
    if a+b &gt; c:
        print('Case #{}: true'.format(i))
    else:
        print('Case #{}: false'.format(i))

</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[linux常用命令]]></title>
        <id>https://ygytl.github.io/post/linux-chang-yong-ming-ling/</id>
        <link href="https://ygytl.github.io/post/linux-chang-yong-ming-ling/">
        </link>
        <updated>2020-05-28T13:18:52.000Z</updated>
        <content type="html"><![CDATA[<h5 id="复制文件或文件夹">复制文件或文件夹</h5>
<pre><code>cp dir1/a.doc dir2 //将dir1下的a.doc文件复制到dir2目录下
cp -r dir1 dir2 //将dir1及dir1下的文件复制到dir2
cp -r dir1/. dir2 //将dir1下的文件复制到dir2
</code></pre>
<h5 id="解压缩">解压缩</h5>
<pre><code>tar xf flag.tar.gz
</code></pre>
<h5 id="centos查看ip">CentOS查看ip</h5>
<pre><code>ip addr
</code></pre>
<h5 id="将flags文件夹里的文件名输出到txt文本">将flags文件夹里的文件名输出到txt文本</h5>
<pre><code>#ls flags &gt; flags.txt
</code></pre>
]]></content>
    </entry>
</feed>