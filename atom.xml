<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://ygytl.github.io/</id>
    <title>Grace</title>
    <updated>2020-07-09T14:07:00.238Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://ygytl.github.io/"/>
    <link rel="self" href="https://ygytl.github.io/atom.xml"/>
    <subtitle>Grace&apos;s blog</subtitle>
    <logo>https://ygytl.github.io/images/avatar.png</logo>
    <icon>https://ygytl.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, Grace</rights>
    <entry>
        <title type="html"><![CDATA[1130 Infix Expression (25分)题解]]></title>
        <id>https://ygytl.github.io/post/1130-infix-expression-25-fen-ti-jie/</id>
        <link href="https://ygytl.github.io/post/1130-infix-expression-25-fen-ti-jie/">
        </link>
        <updated>2020-07-09T14:06:17.000Z</updated>
        <content type="html"><![CDATA[<p>1130 Infix Expression (25分)</p>
<p>Given a syntax tree (binary), you are supposed to output the corresponding infix expression, with parentheses reflecting the precedences of the operators.</p>
<h3 id="input-specification">Input Specification:</h3>
<p>Each input file contains one test case. For each case, the first line gives a positive integer N (≤ 20) which is the total number of nodes in the syntax tree. Then N lines follow, each gives the information of a node (the <em>i</em>-th line corresponds to the <em>i</em>-th node) in the format:</p>
<pre><code>data left_child right_child
</code></pre>
<p>where <code>data</code> is a string of no more than 10 characters, <code>left_child</code> and <code>right_child</code> are the indices of this node's left and right children, respectively. The nodes are indexed from 1 to N. The NULL link is represented by −1. The figures 1 and 2 correspond to the samples 1 and 2, respectively.</p>
<table>
<thead>
<tr>
<th style="text-align:center"><img src="https://images.ptausercontent.com/4d1c4a98-33cc-45ff-820f-c548845681ba.JPG" alt="infix1.JPG" loading="lazy"></th>
<th style="text-align:center"><img src="https://images.ptausercontent.com/b5a3c36e-91ad-494a-8853-b46e1e8b60cc.JPG" alt="infix2.JPG" loading="lazy"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Figure 1</td>
<td style="text-align:center">Figure 2</td>
</tr>
</tbody>
</table>
<h3 id="output-specification">Output Specification:</h3>
<p>For each case, print in a line the infix expression, with parentheses reflecting the precedences of the operators. Note that there must be no extra parentheses for the final expression, as is shown by the samples. There must be no space between any symbols.</p>
<h3 id="sample-input-1">Sample Input 1:</h3>
<pre><code class="language-in">8
* 8 7
a -1 -1
* 4 1
+ 2 5
b -1 -1
d -1 -1
- -1 6
c -1 -1
</code></pre>
<h3 id="sample-output-1">Sample Output 1:</h3>
<pre><code class="language-out">(a+b)*(c*(-d))
</code></pre>
<h3 id="sample-input-2">Sample Input 2:</h3>
<pre><code class="language-in">8
2.35 -1 -1
* 6 1
- -1 4
% 7 8
+ 2 3
a -1 -1
str -1 -1
871 -1 -1
</code></pre>
<h3 id="sample-output-2">Sample Output 2:</h3>
<pre><code class="language-out">(a*2.35)+(-(str%871))
</code></pre>
<hr>
<p>题目描述：二叉树，以算式格式输出。</p>
<p>输入：第一行n为节点数，接下来n行，表示第i个结点的值、左右节点编号。</p>
<p>输出：算式格式输出。</p>
</br>
<p>解题方法：题目没有给出根节点的编号，所以需要先求出根节点编号；得到树的中序遍历，之后得到算式还难吗？</p>
<hr>
<p>方法一：</p>
<pre><code class="language-c++">#include&lt;bits/stdc++.h&gt;
using namespace std;
int n;
const int maxn = 100;
string ans=&quot;&quot;;
struct node{
	string ch;
	int l, r;
};
vector&lt;node&gt; tree(maxn);
bool vis[maxn];
void bfs(int index){
	queue&lt;int&gt; q;
	q.push(index);
	while(!q.empty()){
		int u = q.front(); q.pop();
		vis[u] = true;
		node t = tree[u];
		if(t.l!=-1) q.push(t.l);
		if(t.r!=-1) q.push(t.r);
	}
}
void get_inorder(int index, int g){
	if(index==-1) return ;
	node t = tree[index];
	if(tree[index].r!=-1&amp;&amp;g&gt;1) ans += &quot;(&quot;;
	get_inorder(t.l,g+1);
	ans += t.ch;
	get_inorder(t.r,g+1);
	if(tree[index].r!=-1&amp;&amp;g&gt;1) ans += &quot;)&quot;;
}
int main()
{
	scanf(&quot;%d&quot;, &amp;n);
	int root;
	for(int i=1; i&lt;=n; i++){
		getchar();
		node t;
		cin &gt;&gt; t.ch &gt;&gt; t.l &gt;&gt; t.r;
		tree[i] = t;
	}
	for(int i=1; i&lt;=n; i++){
		memset(vis,false,sizeof(vis));
		bfs(i);
		bool flag = true;
		for(int j=1; j&lt;=n; j++){
			if(vis[j]==false){
				flag = false;
				break;
			}
		}
		if(flag){
			root = i;
			break;
		}
	}
	get_inorder(root,1);
	cout &lt;&lt; ans &lt;&lt; endl;
	return 0;
}
</code></pre>
<p>方法二：</p>
<pre><code class="language-c++">#include&lt;bits/stdc++.h&gt;
using namespace std;
int n;
const int maxn = 100;
string ans=&quot;&quot;;
struct node{
	string ch;
	int l, r;
};
vector&lt;node&gt; tree(maxn);
bool vis[maxn];
void get_inorder(int index, int g){
	if(index==-1) return ;
	node t = tree[index];
	if(tree[index].r!=-1&amp;&amp;g&gt;1) ans += &quot;(&quot;;
	get_inorder(t.l,g+1);
	ans += t.ch;
	get_inorder(t.r,g+1);
	if(tree[index].r!=-1&amp;&amp;g&gt;1) ans += &quot;)&quot;;
}
int main()
{
	scanf(&quot;%d&quot;, &amp;n);
	int root;
	memset(vis,false,sizeof(vis));
	for(int i=1; i&lt;=n; i++){
		getchar();
		node t;
		cin &gt;&gt; t.ch &gt;&gt; t.l &gt;&gt; t.r;
		tree[i] = t;
		if(t.l!=-1) vis[t.l] = true;
		if(t.r!=-1) vis[t.r] = true;
	}
	for(int i=1; i&lt;=n; i++){
		if(vis[i]==false){
			root = i;
			break;
		}
	}
	get_inorder(root,1);
	cout &lt;&lt; ans &lt;&lt; endl;
	return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[1129 Recommendation System (25分)题解]]></title>
        <id>https://ygytl.github.io/post/1129-recommendation-system-25-fen-ti-jie/</id>
        <link href="https://ygytl.github.io/post/1129-recommendation-system-25-fen-ti-jie/">
        </link>
        <updated>2020-07-09T12:31:41.000Z</updated>
        <content type="html"><![CDATA[<p>1129 Recommendation System (25分)</p>
<p>Recommendation system predicts the preference that a user would give to an item. Now you are asked to program a very simple recommendation system that rates the user's preference by the number of times that an item has been accessed by this user.</p>
<h3 id="input-specification">Input Specification:</h3>
<p>Each input file contains one test case. For each test case, the first line contains two positive integers: N (≤ 50,000), the total number of queries, and K (≤ 10), the maximum number of recommendations the system must show to the user. Then given in the second line are the indices of items that the user is accessing -- for the sake of simplicity, all the items are indexed from 1 to N. All the numbers in a line are separated by a space.</p>
<h3 id="output-specification">Output Specification:</h3>
<p>For each case, process the queries one by one. Output the recommendations for each query in a line in the format:</p>
<pre><code>query: rec[1] rec[2] ... rec[K]
</code></pre>
<p>where <code>query</code> is the item that the user is accessing, and <code>rec[i]</code> (<code>i</code>=1, ... K) is the <code>i</code>-th item that the system recommends to the user. The first K items that have been accessed most frequently are supposed to be recommended in non-increasing order of their frequencies. If there is a tie, the items will be ordered by their indices in increasing order.</p>
<p>Note: there is no output for the first item since it is impossible to give any recommendation at the time. It is guaranteed to have the output for at least one query.</p>
<h3 id="sample-input">Sample Input:</h3>
<pre><code class="language-in">12 3
3 5 7 5 5 3 2 1 8 3 8 12
</code></pre>
<h3 id="sample-output">Sample Output:</h3>
<pre><code class="language-out">5: 3
7: 3 5
5: 3 5 7
5: 5 3 7
3: 5 3 7
2: 5 3 7
1: 5 3 2
8: 5 3 1
3: 5 3 1
8: 3 5 1
12: 3 5 8
</code></pre>
<hr>
<p>题目描述：更新推荐系统。</p>
<p>输入描述：第一行n为推荐数，m为最多推荐个数。第二行有m个值，为每次推荐的编号。</p>
<p>输出描述：输出此次推荐编号之前的排序，例如样例，第一个推荐编号为3，第二个推荐编号为5，应该从5开始输出它前面最优的推荐。</p>
<p>系统推荐排序规则：推荐次数多的排在前面，若推荐次数相同，则按编号从小到大排序。</p>
</br>
<p>测试点3、4容易超时，要找准遍历目标。</p>
<hr>
<pre><code class="language-c++">#include&lt;bits/stdc++.h&gt;
using namespace std;
int n, m, k;
map&lt;int,int&gt; p, pid;
struct node{
	int num, cnt = 0;
};
vector&lt;node&gt; G;
bool cmp(node a, node b){
	if(a.cnt!=b.cnt) return a.cnt &gt; b.cnt;//降序 
	else return a.num &lt; b.num;//升序 
}
int main()
{
	map&lt;int,int&gt;::iterator it;
	scanf(&quot;%d %d&quot;, &amp;n, &amp;m);
	for(int i=0; i&lt;n; i++){
		scanf(&quot;%d&quot;, &amp;k);
		pid[k] = i;
		node t;
		if(i){
			printf(&quot;%d:&quot;, k);
			for(int j=0; j&lt;m&amp;&amp;j&lt;G.size(); j++){
				printf(&quot; %d&quot;, G[j].num);
			}
			printf(&quot;\n&quot;);
		}
		p[k]++;
		t.num = k; t.cnt = p[k];
		bool flag = true;
		for(int j=0; j&lt;G.size(); j++){
			if(G[j].num==k){
				G[j].cnt = t.cnt;
				flag = false;
				break;
			}
		}
		if(flag) G.push_back(t);
		sort(G.begin(),G.end(),cmp);
		if(G.size()&gt;m) G.pop_back();
	}
	return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[1127 ZigZagging on a Tree (30分)题解]]></title>
        <id>https://ygytl.github.io/post/1127-zigzagging-on-a-tree-30-fen-ti-jie/</id>
        <link href="https://ygytl.github.io/post/1127-zigzagging-on-a-tree-30-fen-ti-jie/">
        </link>
        <updated>2020-07-08T14:14:46.000Z</updated>
        <content type="html"><![CDATA[<p>1127 ZigZagging on a Tree (30分)</p>
<p>Suppose that all the keys in a binary tree are distinct positive integers. A unique binary tree can be determined by a given pair of postorder and inorder traversal sequences. And it is a simple standard routine to print the numbers in level-order. However, if you think the problem is too simple, then you are too naive. This time you are supposed to print the numbers in &quot;zigzagging order&quot; -- that is, starting from the root, print the numbers level-by-level, alternating between left to right and right to left. For example, for the following tree you must output: 1 11 5 8 17 12 20 15.</p>
<figure data-type="image" tabindex="1"><img src="https://images.ptausercontent.com/337cbfb0-a7b2-4500-9664-318e9ffc870e.jpg" alt="zigzag.jpg" loading="lazy"></figure>
<h3 id="input-specification">Input Specification:</h3>
<p>Each input file contains one test case. For each case, the first line gives a positive integer N (≤30), the total number of nodes in the binary tree. The second line gives the inorder sequence and the third line gives the postorder sequence. All the numbers in a line are separated by a space.</p>
<h3 id="output-specification">Output Specification:</h3>
<p>For each test case, print the zigzagging sequence of the tree in a line. All the numbers in a line must be separated by exactly one space, and there must be no extra space at the end of the line.</p>
<h3 id="sample-input">Sample Input:</h3>
<pre><code class="language-in">8
12 11 20 17 1 15 8 5
12 20 17 11 15 8 5 1
</code></pre>
<h3 id="sample-output">Sample Output:</h3>
<pre><code class="language-out">1 11 5 8 17 12 20 15
</code></pre>
<hr>
<p>题目描述：已知中序遍历和后序遍历可以得到唯一的二叉树；已知中序遍历和先序遍历，可以得到唯一的二叉树。现在题目给出中序和后序遍历，需要求出层序遍历的结果。但是这个层序遍历需要按照Z字行输出。</p>
</br>
<p>解题思路：不需要建树，递归就能得到层序遍历的结果。1086题解解释了已知先序遍历和中序遍历，求后序遍历的结果，思路与这题差不多，可以参考。</p>
<hr>
<pre><code class="language-c++">#include&lt;bits/stdc++.h&gt;
using namespace std;
int n, cnt;
const int maxn = 1e4+5;
vector&lt;int&gt; inorder, post;
vector&lt;int&gt; level[maxn];
void get_level(int root, int inl, int inr, int index){
	if(inl&gt;inr) return ;
	int i = inl;
	cnt = index;
	level[index].push_back(post[root]);
	while(i&lt;=inr&amp;&amp;inorder[i]!=post[root]) i++;
	get_level(root-(inr-i+1),inl,i-1,index+1);
	get_level(root-1,i+1,inr,index+1);
}
int main()
{
	scanf(&quot;%d&quot;, &amp;n);
	inorder.resize(n);
	post.resize(n);
	for(int i=0; i&lt;n; i++) scanf(&quot;%d&quot;, &amp;inorder[i]);
	for(int i=0; i&lt;n; i++) scanf(&quot;%d&quot;, &amp;post[i]);
	get_level(n-1,0,n-1,1);
	for(int i=1; i&lt;=cnt; i++){
		if(i%2==0){
			for(int j=0; j&lt;level[i].size(); j++){
				if(i!=1) printf(&quot; &quot;);
				printf(&quot;%d&quot;, level[i][j]);
			}
		}
		else{
			for(int j=level[i].size()-1; j&gt;=0; j--){
				if(i!=1) printf(&quot; &quot;);
				printf(&quot;%d&quot;, level[i][j]);
			}
		}
	}
	return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[1123 Is It a Complete AVL Tree (30分)题解]]></title>
        <id>https://ygytl.github.io/post/1123-is-it-a-complete-avl-tree-30-fen-ti-jie/</id>
        <link href="https://ygytl.github.io/post/1123-is-it-a-complete-avl-tree-30-fen-ti-jie/">
        </link>
        <updated>2020-07-07T14:24:07.000Z</updated>
        <content type="html"><![CDATA[<p>1123 Is It a Complete AVL Tree (30分)</p>
<p>An AVL tree is a self-balancing binary search tree. In an AVL tree, the heights of the two child subtrees of any node differ by at most one; if at any time they differ by more than one, rebalancing is done to restore this property. Figures 1-4 illustrate the rotation rules.</p>
<figure data-type="image" tabindex="1"><img src="https://ygytl.github.io//post-images/1594132084359.JPG" alt="" loading="lazy"></figure>
<p>Now given a sequence of insertions, you are supposed to output the level-order traversal sequence of the resulting AVL tree, and to tell if it is a complete binary tree.</p>
<h3 id="input-specification">Input Specification:</h3>
<p>Each input file contains one test case. For each case, the first line contains a positive integer N (≤ 20). Then N distinct integer keys are given in the next line. All the numbers in a line are separated by a space.</p>
<h3 id="output-specification">Output Specification:</h3>
<p>For each test case, insert the keys one by one into an initially empty AVL tree. Then first print in a line the level-order traversal sequence of the resulting AVL tree. All the numbers in a line must be separated by a space, and there must be no extra space at the end of the line. Then in the next line, print <code>YES</code> if the tree is complete, or <code>NO</code> if not.</p>
<h3 id="sample-input-1">Sample Input 1:</h3>
<pre><code class="language-in">5
88 70 61 63 65
</code></pre>
<h3 id="sample-output-1">Sample Output 1:</h3>
<pre><code class="language-out">70 63 88 61 65
YES
</code></pre>
<h3 id="sample-input-2">Sample Input 2:</h3>
<pre><code class="language-in">8
88 70 61 96 120 90 65 68
</code></pre>
<h3 id="sample-output-2">Sample Output 2:</h3>
<pre><code class="language-out">88 65 96 61 70 90 120 68
NO
</code></pre>
<hr>
<p>题目描述：完全平衡二叉树。具体参考1066的题解</p>
<p>该题需要建树，判断是否能形成完全平衡二叉树，是输出YES，否输出NO。还要输出树的层序遍历。</p>
</br>
<p>解题思路：建树，完成左转、右转、左右转、右左转的操作、求结点的高度等，最后利用BFS得到层序遍历。</p>
<hr>
<pre><code class="language-c++">#include&lt;bits/stdc++.h&gt;
using namespace std;
int n, k;
vector&lt;int&gt; level;
struct node{
	int num;
	node *l, *r;
	node(){
		l = r = NULL;
	}
};
node *LeftRoute(node *root){
	node *t;
	t = root-&gt;r;
	root-&gt;r = t-&gt;l;
	t-&gt;l = root;
	return t;
}
node *RightRoute(node *root){
	node *t;
	t = root-&gt;l;
	root-&gt;l = t-&gt;r;
	t-&gt;r = root;
	return t;
}
node *LeftRightRoute(node *root){
	root-&gt;l = LeftRoute(root-&gt;l);
	root = RightRoute(root);
	return root;
}
node *RightLeftRoute(node *root){
	root-&gt;r = RightRoute(root-&gt;r);
	root = LeftRoute(root);
	return root;
}
int height(node *root){
	if(root==NULL) return 1;
	return max(height(root-&gt;l),height(root-&gt;r))+1;
}
node *Insert(node *root, int k){
	if(root==NULL){
		root = new node();
		root-&gt;num = k;
		root-&gt;l = root-&gt;r = NULL;
	}
	else if(k&gt;=root-&gt;num){
		root-&gt;r = Insert(root-&gt;r,k);
		if(abs(height(root-&gt;r)-height(root-&gt;l))&gt;=2){
			root = k&gt;=root-&gt;r-&gt;num ? LeftRoute(root) : RightLeftRoute(root);
		}
	}
	else{
		root-&gt;l = Insert(root-&gt;l,k);
		if(abs(height(root-&gt;l)-height(root-&gt;r))&gt;=2){
			root = k&lt;=root-&gt;l-&gt;num ? RightRoute(root) : LeftRightRoute(root);
		}
	}
	return root;
}
void bfs(node *root){
	pair&lt;node *, int&gt; t, tt;
	queue&lt;pair&lt;node *, int&gt; &gt; q;
	t.first = root; t.second = 1;
	q.push(t);
	bool flag = true;
	int cnt = 1;
	while(!q.empty()){
		t = q.front(); q.pop();
		if(cnt!=t.second) flag = false;
		cnt++;
		level.push_back(t.first-&gt;num);
		if(t.first-&gt;l!=NULL){
			tt.first = t.first-&gt;l;
			tt.second = t.second*2;
			q.push(tt);
		}
		if(t.first-&gt;r!=NULL){
			tt.first = t.first-&gt;r;
			tt.second = t.second*2+1;
			q.push(tt);
		} 
	}
	for(int i=0; i&lt;level.size(); i++){
		if(i) printf(&quot; &quot;);
		printf(&quot;%d&quot;, level[i]);
	}
	printf(&quot;\n&quot;);
	if(flag) printf(&quot;YES\n&quot;);
	else printf(&quot;NO\n&quot;);
}
int main()
{
	node *tree = NULL;
	scanf(&quot;%d&quot;, &amp;n);
	for(int i=0; i&lt;n; i++){
		scanf(&quot;%d&quot;, &amp;k);
		tree = Insert(tree,k);
	}
	bfs(tree);
	return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[1119 Pre- and Post-order Traversals (30分)题解]]></title>
        <id>https://ygytl.github.io/post/1119-pre-and-post-order-traversals-30-fen-ti-jie/</id>
        <link href="https://ygytl.github.io/post/1119-pre-and-post-order-traversals-30-fen-ti-jie/">
        </link>
        <updated>2020-07-06T08:31:34.000Z</updated>
        <content type="html"><![CDATA[<p>1119 Pre- and Post-order Traversals (30分)</p>
<p>Suppose that all the keys in a binary tree are distinct positive integers. A unique binary tree can be determined by a given pair of postorder and inorder traversal sequences, or preorder and inorder traversal sequences. However, if only the postorder and preorder traversal sequences are given, the corresponding tree may no longer be unique.</p>
<p>Now given a pair of postorder and preorder traversal sequences, you are supposed to output the corresponding inorder traversal sequence of the tree. If the tree is not unique, simply output any one of them.</p>
<h3 id="input-specification">Input Specification:</h3>
<p>Each input file contains one test case. For each case, the first line gives a positive integer N (≤ 30), the total number of nodes in the binary tree. The second line gives the preorder sequence and the third line gives the postorder sequence. All the numbers in a line are separated by a space.</p>
<h3 id="output-specification">Output Specification:</h3>
<p>For each test case, first printf in a line <code>Yes</code> if the tree is unique, or <code>No</code> if not. Then print in the next line the inorder traversal sequence of the corresponding binary tree. If the solution is not unique, any answer would do. It is guaranteed that at least one solution exists. All the numbers in a line must be separated by exactly one space, and there must be no extra space at the end of the line.</p>
<h3 id="sample-input-1">Sample Input 1:</h3>
<pre><code class="language-in">7
1 2 3 4 6 7 5
2 6 7 4 5 3 1
</code></pre>
<h3 id="sample-output-1">Sample Output 1:</h3>
<pre><code class="language-out">Yes
2 1 6 4 7 3 5
</code></pre>
<h3 id="sample-input-2">Sample Input 2:</h3>
<pre><code class="language-in">4
1 2 3 4
2 4 3 1
</code></pre>
<h3 id="sample-output-2">Sample Output 2:</h3>
<pre><code class="language-out">No
2 1 3 4
</code></pre>
<hr>
<p>题目描述：提供一个二叉树的所有节点值(值为正整数)。唯一的二叉树可以由后序遍历和中序遍历得到，也可以由先序遍历和中序遍历得到。但是，如果只给出先序遍历和后序遍历，得到的二叉树有可能是不唯一的，则他的中序遍历也有可能不唯一。题目给出一对先序遍历和后序遍历数组，求出是否能得到唯一的二叉树，可以则输出Yes，否则输出No。最后一行输出中序遍历，若有多个，输出一个即可。</p>
</br>
<p>解题思路：设置一个flag标志，判断这个二叉树是否唯一。</p>
<p>用样例分析一下：</p>
<table>
<thead>
<tr>
<th>index</th>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
</tr>
</thead>
<tbody>
<tr>
<td>pre</td>
<td>1</td>
<td>2</td>
<td>3</td>
<td>4</td>
<td>6</td>
<td>7</td>
<td>5</td>
</tr>
<tr>
<td>post</td>
<td>2</td>
<td>6</td>
<td>7</td>
<td>4</td>
<td>5</td>
<td>3</td>
<td>1</td>
</tr>
</tbody>
</table>
<p>prel、prer分别是pre数组的左右索引边界值；postl、postr分别是post数组的左右索引边界值。</p>
<p>一开始prel=0，prer=6，postl=0，postr=6</p>
<p>当pre[prel]等于post[postr]，==&gt;pre[0]=1，post[6]=1，一开始就相等了，可以知道，这个值就是根节点的值。题目要求输出中序遍历，输出顺序是左、中(根)、右。当得到中(根)时，不能直接输出，要先求出左，才能将中(根)输出。后续的过程看代码，已加上注释。</p>
<hr>
<pre><code class="language-c++">#include&lt;bits/stdc++.h&gt;
using namespace std;
int n;
vector&lt;int&gt; pre, post, inorder;
bool flag = true;
void get_inorder(int prel, int prer, int postl, int postr){
	if(prel==prer){
		inorder.push_back(pre[prel]);
		return ;
	}
	int i=prel, j=postr-1, k;
	if(pre[prel]==post[postr]){//发现中间结点 
		while(i&lt;=prer&amp;&amp;j&gt;=0&amp;&amp;pre[i]!=post[j]) i++;//求出右子节点在pre数组的位置
		k = i-prel-1;//得到左子树的结点个数
		if(k&gt;0){
			get_inorder(prel+1,i-1,postl,postl+k-1);//左子树进入递归，相应的数组范围会改变
		}
		else flag = false;
	}
	inorder.push_back(post[postr]);
	get_inorder(i,prer,postl+k,postr-1);//右子树进入递归
}
int main()
{
	scanf(&quot;%d&quot;, &amp;n);
	pre.resize(n);
	post.resize(n);
	for(int i=0; i&lt;n; i++) scanf(&quot;%d&quot;, &amp;pre[i]);
	for(int i=0; i&lt;n; i++) scanf(&quot;%d&quot;, &amp;post[i]);
	get_inorder(0,n-1,0,n-1);
	if(flag) printf(&quot;Yes\n&quot;);
	else printf(&quot;No\n&quot;);
	for(int i=0; i&lt;inorder.size(); i++){
		if(i) printf(&quot; &quot;);
		printf(&quot;%d&quot;, inorder[i]);
	}
	printf(&quot;\n&quot;);//没有这个就格式错误，0分bug
	return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[1115 Counting Nodes in a BST (30分)题解]]></title>
        <id>https://ygytl.github.io/post/1115-counting-nodes-in-a-bst-30-fen-ti-jie/</id>
        <link href="https://ygytl.github.io/post/1115-counting-nodes-in-a-bst-30-fen-ti-jie/">
        </link>
        <updated>2020-07-05T06:06:15.000Z</updated>
        <content type="html"><![CDATA[<p>1115 Counting Nodes in a BST (30分)</p>
<p>A Binary Search Tree (BST) is recursively defined as a binary tree which has the following properties:</p>
<ul>
<li>The left subtree of a node contains only nodes with keys less than or equal to the node's key.</li>
<li>The right subtree of a node contains only nodes with keys greater than the node's key.</li>
<li>Both the left and right subtrees must also be binary search trees.</li>
</ul>
<p>Insert a sequence of numbers into an initially empty binary search tree. Then you are supposed to count the total number of nodes in the lowest 2 levels of the resulting tree.</p>
<h3 id="input-specification">Input Specification:</h3>
<p>Each input file contains one test case. For each case, the first line gives a positive integer <em>N</em> (≤1000) which is the size of the input sequence. Then given in the next line are the <em>N</em> integers in [−1000,1000] which are supposed to be inserted into an initially empty binary search tree.</p>
<h3 id="output-specification">Output Specification:</h3>
<p>For each case, print in one line the numbers of nodes in the lowest 2 levels of the resulting tree in the format:</p>
<pre><code>n1 + n2 = n
</code></pre>
<p>where <code>n1</code> is the number of nodes in the lowest level, <code>n2</code> is that of the level above, and <code>n</code> is the sum.</p>
<h3 id="sample-input">Sample Input:</h3>
<pre><code class="language-in">9
25 30 42 16 20 20 35 -5 28
</code></pre>
<h3 id="sample-output">Sample Output:</h3>
<pre><code class="language-out">2 + 4 = 6
</code></pre>
<hr>
<p>题目描述：二叉搜索树的特点有：</p>
<p>1）左子结点的值小于或等于根节点的值</p>
<p>2）右子结点的值大于根节点的值</p>
<p>3）所有左子树和右子树都是一个二叉搜索树</p>
<p>现在给出一组数，插入二叉搜索树中，求倒数第一层、倒数第二层的结点数，n1和n2，最后输出n1+n2。</p>
</br>
<p>解题思路：利用结构体建一棵二叉搜索树，再利用bfs将树的每一层结点分别存入vector数组中，很快就能得到结果了。写程序要有意识的将程序分块，不能将所有代码都写在主程序。</p>
<hr>
<pre><code class="language-c++">#include&lt;bits/stdc++.h&gt;
using namespace std;
int n, k;
const int maxn = 1e4+5;
vector&lt;int&gt; v[maxn];
struct node{
	int num;
	node *l, *r;
	node(){
		l = r = NULL;
	}
};
node* build(node *tree, int x){
	if(tree==NULL){
		tree = new node();
		tree-&gt;num = x;
		tree-&gt;l = tree-&gt;r = NULL;
	}
	else if(tree-&gt;num&lt;x){
		tree-&gt;r = build(tree-&gt;r,x);
	}
	else tree-&gt;l = build(tree-&gt;l,x);
	return tree;
}

void bfs(node *tree){
	int cnt = 0;
	queue&lt;pair&lt;node*,int&gt; &gt; q;
	pair&lt;node*,int&gt; t, tt;
	t.first = tree;
	t.second = 0;
	q.push(t);
	while(!q.empty()){
		t = q.front(); q.pop();
		cnt = t.second;
		v[t.second].push_back(t.first-&gt;num);
		if(t.first-&gt;l!=NULL){
			tt.first = t.first-&gt;l;
			tt.second = t.second+1;
			q.push(tt);
		}
		if(t.first-&gt;r!=NULL){
			tt.first = t.first-&gt;r;
			tt.second = t.second+1;
			q.push(tt);
		}
	}
	int n1 = v[cnt].size(), n2 = v[cnt-1].size();
	printf(&quot;%d + %d = %d\n&quot;, n1, n2, n1+n2);
}

int main()
{
	node *tree = NULL;
	scanf(&quot;%d&quot;, &amp;n);
	for(int i=0; i&lt;n; i++){
		scanf(&quot;%d&quot;, &amp;k);
		tree = build(tree,k);
	}
	bfs(tree);
	return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[1111 Online Map (30分)题解]]></title>
        <id>https://ygytl.github.io/post/1111-online-map-30-fen-ti-jie/</id>
        <link href="https://ygytl.github.io/post/1111-online-map-30-fen-ti-jie/">
        </link>
        <updated>2020-07-04T08:42:46.000Z</updated>
        <content type="html"><![CDATA[<p>1111 Online Map (30分)</p>
<p>Input our current position and a destination, an online map can recommend several paths. Now your job is to recommend two paths to your user: one is the shortest, and the other is the fastest. It is guaranteed that a path exists for any request.</p>
<h3 id="input-specification">Input Specification:</h3>
<p>Each input file contains one test case. For each case, the first line gives two positive integers <em>N</em> (2≤<em>N</em>≤500), and <em>M</em>, being the total number of streets intersections on a map, and the number of streets, respectively. Then <em>M</em> lines follow, each describes a street in the format:</p>
<pre><code>V1 V2 one-way length time
</code></pre>
<p>where <code>V1</code> and <code>V2</code> are the indices (from 0 to <em>N</em>−1) of the two ends of the street; <code>one-way</code> is 1 if the street is one-way from <code>V1</code> to <code>V2</code>, or 0 if not; <code>length</code> is the length of the street; and <code>time</code> is the time taken to pass the street.</p>
<p>Finally a pair of source and destination is given.</p>
<h3 id="output-specification">Output Specification:</h3>
<p>For each case, first print the shortest path from the source to the destination with distance <code>D</code> in the format:</p>
<pre><code>Distance = D: source -&gt; v1 -&gt; ... -&gt; destination
</code></pre>
<p>Then in the next line print the fastest path with total time <code>T</code>:</p>
<pre><code>Time = T: source -&gt; w1 -&gt; ... -&gt; destination
</code></pre>
<p>In case the shortest path is not unique, output the fastest one among the shortest paths, which is guaranteed to be unique. In case the fastest path is not unique, output the one that passes through the fewest intersections, which is guaranteed to be unique.</p>
<p>In case the shortest and the fastest paths are identical, print them in one line in the format:</p>
<pre><code>Distance = D; Time = T: source -&gt; u1 -&gt; ... -&gt; destination
</code></pre>
<h3 id="sample-input-1">Sample Input 1:</h3>
<pre><code class="language-in">10 15
0 1 0 1 1
8 0 0 1 1
4 8 1 1 1
3 4 0 3 2
3 9 1 4 1
0 6 0 1 1
7 5 1 2 1
8 5 1 2 1
2 3 0 2 2
2 1 1 1 1
1 3 0 3 1
1 4 0 1 1
9 7 1 3 1
5 1 0 5 2
6 5 1 1 2
3 5
</code></pre>
<h3 id="sample-output-1">Sample Output 1:</h3>
<pre><code class="language-out">Distance = 6: 3 -&gt; 4 -&gt; 8 -&gt; 5
Time = 3: 3 -&gt; 1 -&gt; 5
</code></pre>
<h3 id="sample-input-2">Sample Input 2:</h3>
<pre><code class="language-in">7 9
0 4 1 1 1
1 6 1 1 3
2 6 1 1 1
2 5 1 2 2
3 0 0 1 1
3 1 1 1 3
3 2 1 1 2
4 5 0 2 2
6 5 1 1 2
3 5
</code></pre>
<h3 id="sample-output-2">Sample Output 2:</h3>
<pre><code class="language-out">Distance = 3; Time = 4: 3 -&gt; 2 -&gt; 5
</code></pre>
<hr>
<p>题目描述：分别求出发地点到目的地的最短距离，最短时间路径；当最短路程路线不唯一时，找到当中花费时间最短的路径；当最短时间路径不唯一时，找分岔口最少的路径；</p>
<p>输出规则提示：当最短距离路径与最短时间路径相同时，按照Distance = D; Time = T: source -&gt; u1 -&gt; ... -&gt; destination 格式输出</p>
<p>解题思路：Dij</p>
<hr>
<pre><code class="language-c++">#include&lt;bits/stdc++.h&gt;
using namespace std;
int n, m, st, et;
const int maxn = 1000 + 5;
const int inf = 0x3f3f3f3f;
vector&lt;int&gt; G[maxn];
int G2[maxn][maxn], G3[maxn][maxn];
bool vis[maxn];
int dist1[maxn], T1[maxn], f1[maxn], f2[maxn], dist2[maxn], T2[maxn];
stack&lt;int&gt; s1, s2;
void Dij1(){
	int sst = st, eet = et;
	memset(vis,false,sizeof(vis));
	memset(dist1,inf,sizeof(dist1));
	memset(T1,inf,sizeof(T1));
	dist1[st] = 0; T1[st] = 0;
	f1[st] = st;
	while(1){
		int index=-1, mx = inf;
		for(int i=0; i&lt;n; i++){
			if(!vis[i]&amp;&amp;dist1[i]&lt;mx){
				mx = dist1[i];
				index = i;
			}
		}
		if(index==-1) break;
		vis[index] = true;
		int u = index, v;
		for(int i=0; i&lt;G[u].size(); i++){
			v = G[u][i];
			if(!vis[v]){
				if(dist1[v]&gt;dist1[u]+G2[u][v]){
					dist1[v] = dist1[u] + G2[u][v];
					T1[v] = T1[u] + G3[u][v];
					f1[v] = u;
				}
				else if(dist1[v]==dist1[u]+G2[u][v]){
					if(T1[v]&gt;T1[u] + G3[u][v]){
						T1[v] = T1[u] + G3[u][v];
						f1[v] = u;
					}
				}
			}
		}
	}
	while(f1[eet]!=eet){
		s1.push(eet);
		eet = f1[eet];
	}
	s1.push(sst);
}
void Dij2(){
	int sst = st, eet = et;
	memset(vis,false,sizeof(vis));
	memset(dist2,0,sizeof(dist2));
	memset(T2,inf,sizeof(T2));
	T2[st] = 0; dist2[st] = 1;
	f2[st] = st;
	while(1){
		int index=-1, mx = inf;
		for(int i=0; i&lt;n; i++){
			if(!vis[i]&amp;&amp;T2[i]&lt;mx){
				mx = T2[i];
				index = i;
			}
		}
		if(index==-1) break;
		vis[index] = true;
		int u = index, v;
		for(int i=0; i&lt;G[u].size(); i++){
			v = G[u][i];
			if(!vis[v]){
				if(T2[v]&gt;T2[u]+G3[u][v]){
					T2[v] = T2[u] + G3[u][v];
					f2[v] = u;
					dist2[v] = dist2[u] + 1;
				}
				else if(T2[v]==T2[u]+G3[u][v]){
					if(dist2[v]&gt;dist2[u]+1){
						dist2[v] = dist2[u] + 1;
						f2[v] = u;
					}
				}
			}
		}
	}
	while(f2[eet]!=eet){
		s2.push(eet);
		eet = f2[eet];
	}
	s2.push(sst);
}

int main()
{
	int v1, v2, way, length, time;
	scanf(&quot;%d %d&quot;, &amp;n, &amp;m);
	for(int i=0; i&lt;m; i++){
		scanf(&quot;%d %d %d %d %d&quot;, &amp;v1, &amp;v2, &amp;way, &amp;length, &amp;time);
		
		if(way==1) G[v1].push_back(v2);//v1 -&gt; v2
		else{
			G[v1].push_back(v2);
			G[v2].push_back(v1);
		}
		G2[v1][v2] = G2[v2][v1] = length;
		G3[v1][v2] = G3[v2][v1] = time;
	}
	scanf(&quot;%d %d&quot;, &amp;st, &amp;et);
	Dij1();
	Dij2();
	if(s1==s2){
		printf(&quot;Distance = %d; Time = %d:&quot;, dist1[et], T2[et]);
		int c = 0;
		while(!s1.empty()){
			if(c==0) printf(&quot; &quot;);
			else printf(&quot; -&gt; &quot;);
			printf(&quot;%d&quot;, s1.top());
			s1.pop(); c++;
		}
	}
	else{
		printf(&quot;Distance = %d:&quot;, dist1[et]);
		int c = 0;
		while(!s1.empty()){
			if(c==0) printf(&quot; &quot;);
			else printf(&quot; -&gt; &quot;);
			printf(&quot;%d&quot;, s1.top());
			s1.pop(); c++;
		}
		printf(&quot;\nTime = %d:&quot;, T2[et]);
		c = 0;
		while(!s2.empty()){
			if(c==0) printf(&quot; &quot;);
			else printf(&quot; -&gt; &quot;);
			printf(&quot;%d&quot;, s2.top());
			s2.pop(); c++;
		} 
	}
	return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[1107 Social Clusters (30分)题解]]></title>
        <id>https://ygytl.github.io/post/1107-social-clusters-30-fen-ti-jie/</id>
        <link href="https://ygytl.github.io/post/1107-social-clusters-30-fen-ti-jie/">
        </link>
        <updated>2020-07-03T10:05:36.000Z</updated>
        <content type="html"><![CDATA[<p>1107 Social Clusters (30分)</p>
<p>When register on a social network, you are always asked to specify your hobbies in order to find some potential friends with the same hobbies. A <strong>social cluster</strong> is a set of people who have some of their hobbies in common. You are supposed to find all the clusters.</p>
<h3 id="input-specification">Input Specification:</h3>
<p>Each input file contains one test case. For each test case, the first line contains a positive integer <em>N</em> (≤1000), the total number of people in a social network. Hence the people are numbered from 1 to <em>N</em>. Then <em>N</em> lines follow, each gives the hobby list of a person in the format:</p>
<p><em>K**i</em>: <em>h**i</em>[1] <em>h**i</em>[2] ... <em>h**i</em>[<em>K**i</em>]</p>
<p>where <em>K**i</em> (&gt;0) is the number of hobbies, and <em>h**i</em>[<em>j</em>] is the index of the <em>j</em>-th hobby, which is an integer in [1, 1000].</p>
<h3 id="output-specification">Output Specification:</h3>
<p>For each case, print in one line the total number of clusters in the network. Then in the second line, print the numbers of people in the clusters in non-increasing order. The numbers must be separated by exactly one space, and there must be no extra space at the end of the line.</p>
<h3 id="sample-input">Sample Input:</h3>
<pre><code class="language-in">8
3: 2 7 10
1: 4
2: 5 3
1: 4
1: 3
1: 4
4: 6 8 1 5
1: 4
</code></pre>
<h3 id="sample-output">Sample Output:</h3>
<pre><code class="language-out">3
4 3 1
</code></pre>
<hr>
<p>题目描述：潜在的朋友圈</p>
<p>输入：第一行n，表示人数；接着n行，每行是第i个人选择的课程数及课程id号。</p>
<p>输出：第一行输出多少个圈，接着输出按照圈里人数的大小递减输出。</p>
<p>解题思路：并查集，求出有多少个朋友圈，按照朋友圈的人数从大到小输出每个圈的人数就行了。</p>
<hr>
<pre><code class="language-c++">#include&lt;bits/stdc++.h&gt;
using namespace std;
int n, m;
const int maxn = 2000;
vector&lt;int&gt; v[maxn];
int f[maxn], g[maxn];
set&lt;int&gt; s;
int find(int x){
	while(f[x]!=x){
		x = f[x];
	}
	return x;
}
void Union(int x, int y){
	x = find(x);
	y = find(y);
	f[x] = y;
}
bool cmp(int a, int b){
	return a &gt; b;
}
int main()
{
	int k;
	scanf(&quot;%d&quot;, &amp;n);
	for(int i=1; i&lt;=n; i++) f[i] = i;
	for(int i=1; i&lt;=n; i++){
		scanf(&quot;%d:&quot;, &amp;m);
		for(int j=0; j&lt;m; j++){
			scanf(&quot;%d&quot;, &amp;k);
			v[k].push_back(i);
			s.insert(k);
		}
	}
	set&lt;int&gt;::iterator it;
	for(it=s.begin(); it!=s.end(); it++){//课程id 
		sort(v[*it].begin(),v[*it].end());
		int x, y;
		for(int i=0; i&lt;v[*it].size(); i++){
			if(i==0) x = find(v[*it][i]);
			else{
				y = find(v[*it][i]);
				Union(x,y);
			}
		}
	}
	map&lt;int,int&gt; p;
	for(int i=1; i&lt;=n; i++) p[find(i)]++;
	map&lt;int,int&gt;::iterator it1;
	int cnt=0; 
	for(it1=p.begin(); it1!=p.end(); it1++){
		g[cnt++] = it1-&gt;second;
	}
	sort(g,g+cnt,cmp);
	printf(&quot;%d\n&quot;, cnt);
	for(int i=0; i&lt;cnt; i++){
		if(i) printf(&quot; &quot;);
		printf(&quot;%d&quot;, g[i]);
	}
	return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[1155 Heap Paths (30分)题解]]></title>
        <id>https://ygytl.github.io/post/1155-heap-paths-30-fen-ti-jie/</id>
        <link href="https://ygytl.github.io/post/1155-heap-paths-30-fen-ti-jie/">
        </link>
        <updated>2020-07-01T14:31:35.000Z</updated>
        <content type="html"><![CDATA[<p>1155 Heap Paths (30分)</p>
<p>In computer science, a <strong>heap</strong> is a specialized tree-based data structure that satisfies the heap property: if P is a parent node of C, then the key (the value) of P is either greater than or equal to (in a max heap) or less than or equal to (in a min heap) the key of C. A common implementation of a heap is the binary heap, in which the tree is a complete binary tree. (Quoted from Wikipedia at https://en.wikipedia.org/wiki/Heap_(data_structure))</p>
<p>One thing for sure is that all the keys along any path from the root to a leaf in a max/min heap must be in non-increasing/non-decreasing order.</p>
<p>Your job is to check every path in a given complete binary tree, in order to tell if it is a heap or not.</p>
<h3 id="input-specification">Input Specification:</h3>
<p>Each input file contains one test case. For each case, the first line gives a positive integer <em>N</em> (1&lt;<em>N</em>≤1,000), the number of keys in the tree. Then the next line contains <em>N</em> distinct integer keys (all in the range of <strong>int</strong>), which gives the level order traversal sequence of a complete binary tree.</p>
<h3 id="output-specification">Output Specification:</h3>
<p>For each given tree, first print all the paths from the root to the leaves. Each path occupies a line, with all the numbers separated by a space, and no extra space at the beginning or the end of the line. The paths must be printed in the following order: for each node in the tree, all the paths in its right subtree must be printed before those in its left subtree.</p>
<p>Finally print in a line <code>Max Heap</code> if it is a max heap, or <code>Min Heap</code> for a min heap, or <code>Not Heap</code> if it is not a heap at all.</p>
<h3 id="sample-input-1">Sample Input 1:</h3>
<pre><code class="language-in">8
98 72 86 60 65 12 23 50
</code></pre>
<h3 id="sample-output-1">Sample Output 1:</h3>
<pre><code class="language-out">98 86 23
98 86 12
98 72 65
98 72 60 50
Max Heap
</code></pre>
<h3 id="sample-input-2">Sample Input 2:</h3>
<pre><code class="language-in">8
8 38 25 58 52 82 70 60
</code></pre>
<h3 id="sample-output-2">Sample Output 2:</h3>
<pre><code class="language-out">8 25 70
8 25 82
8 38 52
8 38 58 60
Min Heap
</code></pre>
<h3 id="sample-input-3">Sample Input 3:</h3>
<pre><code class="language-in">8
10 28 15 12 34 9 8 56
</code></pre>
<h3 id="sample-output-3">Sample Output 3:</h3>
<pre><code class="language-out">10 15 8
10 15 9
10 28 34
10 28 12 56
Not Heap
</code></pre>
<hr>
<p>题目描述：先理解堆的定义，堆分为最大堆，最小堆。题目给出一组数，有可能是堆或不是。如果是堆，则表示树的层次序列值。堆的构建是在满二叉树的基础上的，所以比较容易判断是最大堆还是最小堆。</p>
<p>最大堆：root结点的值大于其左右子结点的值。</p>
<p>最小堆：root结点的值小于其左右子结点的值。</p>
</br>
<p>解题思路：用数组存题目给出的树，一般舍去索引0，从1开始存值，当root索引为index时，左节点索引为index*2，右节点索引为index*2+1。判断v[index]的值是否都大于v[index*2]、v[index*2+1]，如果是就是最大堆；判断v[index]的值是否都小于v[index*2]、v[index*2+1]，如果是则为最小堆。如果都不是最大堆、最小堆，输出Not Heap。</p>
<p>并且题目要求输出根节点到叶子结点的路径，输出顺序是右大于左。</p>
<hr>
<pre><code class="language-c++">#include&lt;bits/stdc++.h&gt;
using namespace std;
int n;
vector&lt;int&gt; v, tv, ttv;
vector&lt; vector&lt;int&gt; &gt; ans;
int judge(){
	int f1=true, f2=true, l, r;
	for(int i=1; i&lt;=n; i++){
		l = i*2; r = i*2+1;
		if(l&lt;=n){
			if(f1&amp;&amp;v[i]&lt;v[l]) f1 = false;
			if(f2&amp;&amp;v[i]&gt;v[l]) f2 = false;
		}
		if(r&lt;=n){
			if(f1&amp;&amp;v[i]&lt;v[r]) f1 = false;
			if(f2&amp;&amp;v[i]&gt;v[r]) f2 = false;
		}
	}
	if(f1==true&amp;&amp;f2==false) return 1;
	if(f2==true&amp;&amp;f1==false) return -1;
	return 0;
}
void dfs(int index){
	int l=index*2, r=index*2+1;
	tv.push_back(v[index]);
	if(l&gt;n&amp;&amp;r&gt;n){
		ans.push_back(tv);
		return ;
	}
	if(r&lt;=n){
		dfs(r);
		tv.pop_back();
	}
	if(l&lt;=n){
		dfs(l);
		tv.pop_back();
	}
}
int main()
{
	scanf(&quot;%d&quot;, &amp;n);
	v.resize(n+1);
	for(int i=1; i&lt;=n; i++) scanf(&quot;%d&quot;, &amp;v[i]);
	int flag = judge();
	dfs(1);
	for(int i=0; i&lt;ans.size(); i++){
		for(int j=0; j&lt;ans[i].size(); j++){
			if(j) printf(&quot; &quot;);
			printf(&quot;%d&quot;, ans[i][j]);
		}
		printf(&quot;\n&quot;);
	}
	if(flag==0) printf(&quot;Not Heap\n&quot;);
	else if(flag==1) printf(&quot;Max Heap\n&quot;);
	else if(flag==-1) printf(&quot;Min Heap\n&quot;);
	return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[1105 Spiral Matrix (25分)题解]]></title>
        <id>https://ygytl.github.io/post/1105-spiral-matrix-25-fen-ti-jie/</id>
        <link href="https://ygytl.github.io/post/1105-spiral-matrix-25-fen-ti-jie/">
        </link>
        <updated>2020-07-01T08:24:12.000Z</updated>
        <content type="html"><![CDATA[<p>1105 Spiral Matrix (25分)</p>
<p>This time your job is to fill a sequence of <em>N</em> positive integers into a <strong>spiral matrix</strong> in non-increasing order. A spiral matrix is filled in from the first element at the upper-left corner, then move in a clockwise spiral. The matrix has <em>m</em> rows and <em>n</em> columns, where <em>m</em> and <em>n</em> satisfy the following: <em>m</em>×<em>n</em> must be equal to <em>N</em>; <em>m</em>≥<em>n</em>; and <em>m</em>−<em>n</em> is the minimum of all the possible values.</p>
<h3 id="input-specification">Input Specification:</h3>
<p>Each input file contains one test case. For each case, the first line gives a positive integer <em>N</em>. Then the next line contains <em>N</em> positive integers to be filled into the spiral matrix. All the numbers are no more than 104. The numbers in a line are separated by spaces.</p>
<h3 id="output-specification">Output Specification:</h3>
<p>For each test case, output the resulting matrix in <em>m</em> lines, each contains <em>n</em> numbers. There must be exactly 1 space between two adjacent numbers, and no extra space at the end of each line.</p>
<h3 id="sample-input">Sample Input:</h3>
<pre><code class="language-in">12
37 76 20 98 76 42 53 95 60 81 58 93
</code></pre>
<h3 id="sample-output">Sample Output:</h3>
<pre><code class="language-out">98 95 93
42 37 81
53 20 76
58 60 76
</code></pre>
<hr>
<p>题目描述：将一组数用二维数组的形式输出(类似漩涡)，m-行，n-列，要求m&gt;=n。</p>
<p>解题思路：将题目给的数组从大到小排序，然后求出二维数组的行和列，再往里面填值就行了。可以用一个二维数组vis记录哪个空是填了值的，比较方便。(在ccf真题中有一道题与这题类似，难度在第二道题)</p>
<hr>
<pre><code class="language-c++">#include&lt;bits/stdc++.h&gt;
using namespace std;
const int maxn = 1e4 + 5;
int v[maxn];
vector&lt;vector&lt;int&gt; &gt; G;
vector&lt;vector&lt;bool&gt; &gt; vis;
bool cmp(int a, int b){
	return a &gt; b;
}
int main()
{
	int n, k, x, y;
	scanf(&quot;%d&quot;, &amp;n);
	for(int i=0; i&lt;n; i++) scanf(&quot;%d&quot;, &amp;v[i]);
	sort(v, v+n, cmp);
	x = sqrt(n)+1;
	for(int i=x; i&gt;=1; i--){
		if(n%i==0){
			x = i;
			break;
		}
	}
	y = min(x,n/x); x = max(x,n/x);
	if(y==1){
		for(int i=0; i&lt;n; i++) printf(&quot;%d\n&quot;, v[i]);
		return 0;
	}
	G.resize(x+1); vis.resize(x+1);
	for(int i=1; i&lt;=x; i++){
		G[i].resize(y+2);
		vis[i].resize(y+2);
		vis[i][0] = false; vis[i][y+1] = false;
		for(int j=1; j&lt;=y; j++) vis[i][j] = true;
	}
	int i = 1, j = 1, c=0;
	while(vis[i][j]&amp;&amp;c&lt;n){//圈 
		while(j&lt;=y&amp;&amp;vis[i][j]){
			G[i][j] = v[c];
			vis[i][j] = false;
			c++; j++;
		}
		i++; j--;
		while(i&lt;=x&amp;&amp;vis[i][j]){
			G[i][j] = v[c];
			vis[i][j] = false;
			c++; i++;
		}
		i--; j--;
		while(j&gt;=1&amp;&amp;vis[i][j]){
			G[i][j] = v[c];
			vis[i][j] = false;
			c++; j--;
		}
		j++; i--;
		while(i&gt;=1&amp;&amp;vis[i][j]){
			G[i][j] = v[c];
			vis[i][j] = false;
			c++; i--;
		}
		i++; j++;
	}
	for(i=1; i&lt;=x; i++){
		for(j=1; j&lt;=y; j++){
			if(j!=1) printf(&quot; &quot;);
			printf(&quot;%d&quot;, G[i][j]);
		}
		printf(&quot;\n&quot;);
	}
	return 0;
}
</code></pre>
]]></content>
    </entry>
</feed>