<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://ygytl.github.io/</id>
    <title>Grace</title>
    <updated>2020-07-01T08:24:40.561Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://ygytl.github.io/"/>
    <link rel="self" href="https://ygytl.github.io/atom.xml"/>
    <subtitle>Grace&apos;s blog</subtitle>
    <logo>https://ygytl.github.io/images/avatar.png</logo>
    <icon>https://ygytl.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, Grace</rights>
    <entry>
        <title type="html"><![CDATA[1105 Spiral Matrix (25分)题解]]></title>
        <id>https://ygytl.github.io/post/1105-spiral-matrix-25-fen-ti-jie/</id>
        <link href="https://ygytl.github.io/post/1105-spiral-matrix-25-fen-ti-jie/">
        </link>
        <updated>2020-07-01T08:24:12.000Z</updated>
        <content type="html"><![CDATA[<p>1105 Spiral Matrix (25分)</p>
<p>This time your job is to fill a sequence of <em>N</em> positive integers into a <strong>spiral matrix</strong> in non-increasing order. A spiral matrix is filled in from the first element at the upper-left corner, then move in a clockwise spiral. The matrix has <em>m</em> rows and <em>n</em> columns, where <em>m</em> and <em>n</em> satisfy the following: <em>m</em>×<em>n</em> must be equal to <em>N</em>; <em>m</em>≥<em>n</em>; and <em>m</em>−<em>n</em> is the minimum of all the possible values.</p>
<h3 id="input-specification">Input Specification:</h3>
<p>Each input file contains one test case. For each case, the first line gives a positive integer <em>N</em>. Then the next line contains <em>N</em> positive integers to be filled into the spiral matrix. All the numbers are no more than 104. The numbers in a line are separated by spaces.</p>
<h3 id="output-specification">Output Specification:</h3>
<p>For each test case, output the resulting matrix in <em>m</em> lines, each contains <em>n</em> numbers. There must be exactly 1 space between two adjacent numbers, and no extra space at the end of each line.</p>
<h3 id="sample-input">Sample Input:</h3>
<pre><code class="language-in">12
37 76 20 98 76 42 53 95 60 81 58 93
</code></pre>
<h3 id="sample-output">Sample Output:</h3>
<pre><code class="language-out">98 95 93
42 37 81
53 20 76
58 60 76
</code></pre>
<hr>
<p>题目描述：将一组数用二维数组的形式输出(类似漩涡)，m-行，n-列，要求m&gt;=n。</p>
<p>解题思路：将题目给的数组从大到小排序，然后求出二维数组的行和列，再往里面填值就行了。可以用一个二维数组vis记录哪个空是填了值的，比较方便。(在ccf真题中有一道题与这题类似，难度在第二道题)</p>
<hr>
<pre><code class="language-c++">#include&lt;bits/stdc++.h&gt;
using namespace std;
const int maxn = 1e4 + 5;
int v[maxn];
vector&lt;vector&lt;int&gt; &gt; G;
vector&lt;vector&lt;bool&gt; &gt; vis;
bool cmp(int a, int b){
	return a &gt; b;
}
int main()
{
	int n, k, x, y;
	scanf(&quot;%d&quot;, &amp;n);
	for(int i=0; i&lt;n; i++) scanf(&quot;%d&quot;, &amp;v[i]);
	sort(v, v+n, cmp);
	x = sqrt(n)+1;
	for(int i=x; i&gt;=1; i--){
		if(n%i==0){
			x = i;
			break;
		}
	}
	y = min(x,n/x); x = max(x,n/x);
	if(y==1){
		for(int i=0; i&lt;n; i++) printf(&quot;%d\n&quot;, v[i]);
		return 0;
	}
	G.resize(x+1); vis.resize(x+1);
	for(int i=1; i&lt;=x; i++){
		G[i].resize(y+2);
		vis[i].resize(y+2);
		vis[i][0] = false; vis[i][y+1] = false;
		for(int j=1; j&lt;=y; j++) vis[i][j] = true;
	}
	int i = 1, j = 1, c=0;
	while(vis[i][j]&amp;&amp;c&lt;n){//圈 
		while(j&lt;=y&amp;&amp;vis[i][j]){
			G[i][j] = v[c];
			vis[i][j] = false;
			c++; j++;
		}
		i++; j--;
		while(i&lt;=x&amp;&amp;vis[i][j]){
			G[i][j] = v[c];
			vis[i][j] = false;
			c++; i++;
		}
		i--; j--;
		while(j&gt;=1&amp;&amp;vis[i][j]){
			G[i][j] = v[c];
			vis[i][j] = false;
			c++; j--;
		}
		j++; i--;
		while(i&gt;=1&amp;&amp;vis[i][j]){
			G[i][j] = v[c];
			vis[i][j] = false;
			c++; i--;
		}
		i++; j++;
	}
	for(i=1; i&lt;=x; i++){
		for(j=1; j&lt;=y; j++){
			if(j!=1) printf(&quot; &quot;);
			printf(&quot;%d&quot;, G[i][j]);
		}
		printf(&quot;\n&quot;);
	}
	return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[1093 Count PAT's (25分)题解]]></title>
        <id>https://ygytl.github.io/post/1093-count-pats-25-fen-ti-jie/</id>
        <link href="https://ygytl.github.io/post/1093-count-pats-25-fen-ti-jie/">
        </link>
        <updated>2020-06-23T06:31:10.000Z</updated>
        <content type="html"><![CDATA[<p>1093 Count PAT's (25分)</p>
<p>The string <code>APPAPT</code> contains two <code>PAT</code>'s as substrings. The first one is formed by the 2nd, the 4th, and the 6th characters, and the second one is formed by the 3rd, the 4th, and the 6th characters.</p>
<p>Now given any string, you are supposed to tell the number of <code>PAT</code>'s contained in the string.</p>
<h3 id="input-specification">Input Specification:</h3>
<p>Each input file contains one test case. For each case, there is only one line giving a string of no more than 105 characters containing only <code>P</code>, <code>A</code>, or <code>T</code>.</p>
<h3 id="output-specification">Output Specification:</h3>
<p>For each test case, print in one line the number of <code>PAT</code>'s contained in the string. Since the result may be a huge number, you only have to output the result moded by 1000000007.</p>
<h3 id="sample-input">Sample Input:</h3>
<pre><code class="language-in">APPAPT
</code></pre>
<h3 id="sample-output">Sample Output:</h3>
<pre><code class="language-out">2
</code></pre>
<hr>
<p>题目描述：计算字符串PAT的个数</p>
<p>解题思路：动态规划的思想。</p>
<p>分析一个测试用例：APPAPAAT，输出8</p>
<table>
<thead>
<tr>
<th></th>
<th>A</th>
<th>P</th>
<th>P</th>
<th>A</th>
<th>P</th>
<th>A</th>
<th>A</th>
<th>T</th>
</tr>
</thead>
<tbody>
<tr>
<td>P数组</td>
<td>0</td>
<td>1</td>
<td>2</td>
<td><strong>2</strong></td>
<td>3</td>
<td><strong>3</strong></td>
<td><strong>3</strong></td>
<td>3</td>
</tr>
<tr>
<td>PA数组</td>
<td>0</td>
<td>0</td>
<td><strong>0</strong></td>
<td><strong>0+2=2</strong></td>
<td><strong>2</strong></td>
<td><strong>2+3=5</strong></td>
<td><strong>5+3=8</strong></td>
<td><strong>8</strong></td>
</tr>
<tr>
<td>PAT个数</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td><strong>0</strong></td>
<td><strong>0+8=8</strong></td>
</tr>
</tbody>
</table>
<hr>
<pre><code class="language-c++">#include&lt;bits/stdc++.h&gt;
using namespace std;
const int maxn = 1e5+5;
int p[maxn], pa[maxn];
int main()
{
	int c = 0, tp = 0, tpa = 0, ans = 0;
	string s;
	cin &gt;&gt; s;
	int l = s.length();
	for(int i=0; i&lt;l; i++){
		if(s[i]=='P') p[i] = tp++;
		p[i] = tp;
		
		if(s[i]=='A') tpa += p[i];
		pa[i] = tpa;
		
		if(s[i]=='T'){
			ans += pa[i];
			ans %= 1000000007;
		}
	}
	printf(&quot;%d&quot;, ans);
	return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[1089 Insert or Merge (25分)题解]]></title>
        <id>https://ygytl.github.io/post/1089-insert-or-merge-25-fen-ti-jie/</id>
        <link href="https://ygytl.github.io/post/1089-insert-or-merge-25-fen-ti-jie/">
        </link>
        <updated>2020-06-22T14:56:10.000Z</updated>
        <content type="html"><![CDATA[<p>1089 Insert or Merge (25分)</p>
<p>According to Wikipedia:</p>
<p><strong>Insertion sort</strong> iterates, consuming one input element each repetition, and growing a sorted output list. Each iteration, insertion sort removes one element from the input data, finds the location it belongs within the sorted list, and inserts it there. It repeats until no input elements remain.</p>
<p><strong>Merge sort</strong> works as follows: Divide the unsorted list into N sublists, each containing 1 element (a list of 1 element is considered sorted). Then repeatedly merge two adjacent sublists to produce new sorted sublists until there is only 1 sublist remaining.</p>
<p>Now given the initial sequence of integers, together with a sequence which is a result of several iterations of some sorting method, can you tell which sorting method we are using?</p>
<h3 id="input-specification">Input Specification:</h3>
<p>Each input file contains one test case. For each case, the first line gives a positive integer <em>N</em> (≤100). Then in the next line, <em>N</em> integers are given as the initial sequence. The last line contains the partially sorted sequence of the <em>N</em> numbers. It is assumed that the target sequence is always ascending. All the numbers in a line are separated by a space.</p>
<h3 id="output-specification">Output Specification:</h3>
<p>For each test case, print in the first line either &quot;Insertion Sort&quot; or &quot;Merge Sort&quot; to indicate the method used to obtain the partial result. Then run this method for one more iteration and output in the second line the resuling sequence. It is guaranteed that the answer is unique for each test case. All the numbers in a line must be separated by a space, and there must be no extra space at the end of the line.</p>
<h3 id="sample-input-1">Sample Input 1:</h3>
<pre><code class="language-in">10
3 1 2 8 7 5 9 4 6 0
1 2 3 7 8 5 9 4 6 0
</code></pre>
<h3 id="sample-output-1">Sample Output 1:</h3>
<pre><code class="language-out">Insertion Sort
1 2 3 5 7 8 9 4 6 0
</code></pre>
<h3 id="sample-input-2">Sample Input 2:</h3>
<pre><code class="language-in">10
3 1 2 8 7 5 9 4 0 6
1 3 2 8 5 7 4 9 0 6
</code></pre>
<h3 id="sample-output-2">Sample Output 2:</h3>
<pre><code class="language-out">Merge Sort
1 2 3 8 4 5 7 9 0 6
</code></pre>
<hr>
<p>考察插入排序和归并排序</p>
<p>输入：第一行数组有n个数，第二行为需要排序的数组，第三行为已部分排好序的数组。</p>
<p>输出：判断输入的第三行数列是依照哪种排序规则进行排序的，并输出下一步排好序的数列</p>
<p>注意：测试点4，给出的数组序列可能存在相等元素。</p>
</br>
<p>解题思路：首先要知道插入排序和归并排序的排序方法、步骤。</p>
<p>插入排序：从需要排序的数组索引0开始进行排序。以样例1为例：</p>
<p>原始数组：3 1 2 8 7 5 9 4 6 0</p>
<p>1)<strong>3</strong> 1 2 8 7 5 9 4 6 0---对 (索引0) 的元素进行排序</p>
<p>2)<strong>1</strong> 3 2 8 7 5 9 4 6 0---对 (索引0~1) 的元素进行排序</p>
<p>3)1 <strong>2</strong> 3 8 7 5 9 4 6 0---对 (索引0~2) 的元素进行排序</p>
<p>...</p>
<p>归并排序的思想：</p>
<p>1)将数组元素两两进行排序</p>
<p>2)将数组元素44进行排序</p>
<p>3)将数组元素88进行排序</p>
<p>若最后一组不够元素，也要将他们进行排序</p>
<hr>
<pre><code class="language-c++">#include&lt;bits/stdc++.h&gt;
using namespace std;
vector&lt;int&gt; a, b;
int n, g;
int judge(){
	int t;
	t = b[0];
	for(int i=1; i&lt;n; i++){
		if(b[i]&gt;=t){
			g = i;
			t = b[i];
		}
		else break;
	}
	for(int i=g+1; i&lt;n; i++){
		if(a[i]!=b[i]) return 1;//Merge
	}
	return 2;//Insert
}

void solve1(){
	printf(&quot;Merge Sort\n&quot;);
	bool f = true;
	int t = 1;
	while(f){
		f = false;
		for(int i=0; i&lt;n; i++){
			if(a[i]!=b[i]){
				f = true;
				break;
			}
		}
		t*=2;
		for(int i=0; i&lt;n; i+=t){
			if(i+t&lt;n) sort(a.begin()+i,a.begin()+i+t);
			else sort(a.begin()+i,a.begin()+n);
		}
	}
	for(int i=0; i&lt;n; i++){
		if(i) printf(&quot; &quot;);
		printf(&quot;%d&quot;, a[i]);
	}
}

void solve2(){
	printf(&quot;Insertion Sort\n&quot;);
	sort(b.begin(),b.begin()+g+2);
	for(int i=0; i&lt;n; i++){
		if(i) printf(&quot; &quot;);
		printf(&quot;%d&quot;, b[i]);
	}
}

int main()
{
	int k;
	scanf(&quot;%d&quot;, &amp;n);
	for(int i=0; i&lt;n; i++){
		scanf(&quot;%d&quot;, &amp;k);
		a.push_back(k);
	}
	for(int i=0; i&lt;n; i++){
		scanf(&quot;%d&quot;, &amp;k);
		b.push_back(k);
	}
	g = 0;
	int flag = judge();
	if(flag==2) solve2();
	else solve1();
	return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Crackme.exe脱壳与破解]]></title>
        <id>https://ygytl.github.io/post/crackmeexe-tuo-ke-yu-po-jie/</id>
        <link href="https://ygytl.github.io/post/crackmeexe-tuo-ke-yu-po-jie/">
        </link>
        <updated>2020-06-12T15:37:49.000Z</updated>
        <content type="html"><![CDATA[<h4 id="1-首先使用peid工具对软件进行分析查看是否有壳">1.** <em><strong>*首先使用PEid工具对软件进行分析，查看是否有壳*</strong></em></h4>
<p>答：.pediy区块是外壳程序所加载的部分，所以改程序有壳。</p>
<p><img src="https://ygytl.github.io//post-images/1592064469029.JPG" alt="img" loading="lazy"><br>
<img src="https://ygytl.github.io//post-images/1592064480279.JPG" alt="img" loading="lazy"></p>
 </br>
</br>
<h4 id="2-若有壳按照所学的脱壳方式进行脱壳"><strong>2.</strong> <em><strong>*若有壳，按照所学的脱壳方式进行脱壳*</strong></em></h4>
<h5 id="1查找程序的原始入口oep根据跨段指令寻找oep"><em><strong>*(1)查找程序的原始入口OEP，根据跨段指令寻找OEP*</strong></em></h5>
<ol>
<li>运行OllyDbg，调试选项中“Event”将暂停点设置在主模块的入口点。打开CRACKME.EXE，程序会停在00408000h处。</li>
</ol>
<figure data-type="image" tabindex="1"><img src="https://ygytl.github.io//post-images/1592064507296.JPG" alt="img" loading="lazy"></figure>
 </br>
<p>2)按F8执行到00408001h处，再按F7跳转到004080C8h处。</p>
<figure data-type="image" tabindex="2"><img src="https://ygytl.github.io//post-images/1592064514406.JPG" alt="img" loading="lazy"></figure>
 </br>
<p>3)004080C8h一直运行到00408135h处，会跳转到00020000h处。</p>
<figure data-type="image" tabindex="3"><img src="https://ygytl.github.io//post-images/1592064528201.JPG" alt="img" loading="lazy"></figure>
<figure data-type="image" tabindex="4"><img src="https://ygytl.github.io//post-images/1592064538968.JPG" alt="img" loading="lazy"></figure>
<p>跳转后：</p>
<figure data-type="image" tabindex="5"><img src="https://ygytl.github.io//post-images/1592064549310.JPG" alt="img" loading="lazy"></figure>
 </br>
<p>4)从00020000h执行到000200A5h处，000200A5h到000200F0h处是一个循环,右键选中000200F2h处，按F4跳出循环到000200F2h处。</p>
<figure data-type="image" tabindex="6"><img src="https://ygytl.github.io//post-images/1592064559504.JPG" alt="img" loading="lazy"></figure>
 </br>
<p>5)从000200F2h处执行到00020147h处，jmp short 00020147指令表示00020147h处到00020178h处是一个循环；jmp short 0002010C指令表示0002010Ch处到0002017Dh处是一个循环；跳出这两个循环，到0002017Fh处。</p>
<figure data-type="image" tabindex="7"><img src="https://ygytl.github.io//post-images/1592064568427.JPG" alt="img" loading="lazy"></figure>
 </br>
<p>6)0002017Fh处会跳转到000201F6h处。</p>
<figure data-type="image" tabindex="8"><img src="https://ygytl.github.io//post-images/1592064578621.JPG" alt="img" loading="lazy"></figure>
<figure data-type="image" tabindex="9"><img src="https://ygytl.github.io//post-images/1592064611770.JPG" alt="img" loading="lazy"></figure>
 </br>
<ol start="7">
<li>从0000201F6h处执行到00020282h处、00020283h处、00020283h处，分别可以看到popad、push 401000、retn。至此，OEP就找到了，是401000。</li>
</ol>
<figure data-type="image" tabindex="10"><img src="https://ygytl.github.io//post-images/1592064623616.JPG" alt="img" loading="lazy"></figure>
 </br>
<figure data-type="image" tabindex="11"><img src="https://ygytl.github.io//post-images/1592064634601.JPG" alt="img" loading="lazy"></figure>
 </br>
<h5 id="2抓取内存映像文件"><em><strong>*(2)抓取内存映像文件*</strong></em></h5>
<p>1)运行CRACKME.EXE程序，运行LordPE，在LordPE的选项中勾选“Full dump header from disk”，在窗口选择CRACKME，点击右键，执行“修正镜像大小”，接着执行“dump full(完整转存)”命令，即可转去内存数据并保存在文件里。命名为dumped.exe。</p>
<figure data-type="image" tabindex="12"><img src="https://ygytl.github.io//post-images/1592064647371.JPG" alt="img" loading="lazy"></figure>
<figure data-type="image" tabindex="13"><img src="https://ygytl.github.io//post-images/1592064654957.JPG" alt="img" loading="lazy"></figure>
 </br>
2) dumped.exe文件是不可运行的
<figure data-type="image" tabindex="14"><img src="https://ygytl.github.io//post-images/1592064667914.JPG" alt="img" loading="lazy"></figure>
 </br>
<h5 id="3重建输入表"><em><strong>*(3)重建输入表*</strong></em></h5>
<p>1)使用ImportREC工具进行修复。先运行CRACKME.EXE，接着运行ImportREC。<br>
<img src="https://ygytl.github.io//post-images/1592064676429.JPG" alt="img" loading="lazy"></p>
</br>
<p>2)在下列表框中选择CRACKME.EXE进程，在OEP处填入OEP的RVA值1000，单击“IAT AutoSearch”按钮，让其自动检查IAT的偏移和大小。弹出如下对话框：</p>
<figure data-type="image" tabindex="15"><img src="https://ygytl.github.io//post-images/1592064686437.JPG" alt="img" loading="lazy"></figure>
<p>表示输入的OEP发挥作用了。</p>
<p>3)单击“Get Imports”按钮，让其分析IAT结构得到基本信息</p>
<figure data-type="image" tabindex="16"><img src="https://ygytl.github.io//post-images/1592064696874.JPG" alt="img" loading="lazy"></figure>
 </br>
<p>4)单击“Fix Dump”，选择刚才抓取的dumped.exe映像文件，将自动创建一个dumped_.exe文件。这个就是脱壳后的文件了，该文件可以正常运行。接着使用PEiD.exe查看脱壳前后的区段表。</p>
<p>脱壳前：</p>
<figure data-type="image" tabindex="17"><img src="https://ygytl.github.io//post-images/1592064705124.JPG" alt="img" loading="lazy"></figure>
<p>脱壳后：</p>
<figure data-type="image" tabindex="18"><img src="https://ygytl.github.io//post-images/1592064713911.JPG" alt="img" loading="lazy"></figure>
 </br>
<h4 id="3脱壳后再对软件代码进行分析分析出自己姓名所对应的正确的序列号"><em><strong>*3.脱壳后再对软件代码进行分析，分析出自己姓名所对应的正确的序列号*</strong></em></h4>
<p>1)打开OllyDbg，选择dumped_.exe进行分析。</p>
<figure data-type="image" tabindex="19"><img src="https://ygytl.github.io//post-images/1592064722160.JPG" alt="img" loading="lazy"></figure>
 </br>
<p>2)先在00401226h处设置断点,在注册表填入自定义姓名和序列号。</p>
<figure data-type="image" tabindex="20"><img src="https://ygytl.github.io//post-images/1592064730216.JPG" alt="img" loading="lazy"></figure>
 </br>
<p>3)按F9后，得到下图所示；在00401228h处显示了Name框的内容，在00401233h处显示了序列号Serial框的内容。</p>
<p><img src="https://ygytl.github.io//post-images/1592064737550.JPG" alt="img" loading="lazy"><br>
</br><br>
4)接下来分析下图语句，首先是一个用户名的计算函数，然后是一个序列号的计算函数，接着比较两个函数计算的结果是否相等，相等则提示正确。</p>
<figure data-type="image" tabindex="21"><img src="https://ygytl.github.io//post-images/1592064744857.JPG" alt="img" loading="lazy"></figure>
<pre><code>00401228h call dumped_.0040137E  //用户名的计算函数

00401238h call dumped_.004013D8  //序列号的计算函数

00401241h cmp eax,ebx  //比较用户名字和序列号计算的结果

00401243h je short dumped_.0040124C  //相等则提示正确

00401245h call dumped_.00401362  //错误提示

0040124Ch call dumped_.0040134D  //正确提示
</code></pre>
 </br>
 5)用户名算法分析
<figure data-type="image" tabindex="22"><img src="https://ygytl.github.io//post-images/1592064753430.JPG" alt="img" loading="lazy"></figure>
<p>0040137Eh先取出用户名，依次去出名字字符串的单字符，将用户名中的英文单词全部转换为大写。</p>
<p>0040137Eh mov esi, dword ptr ss:[esp+0x4]  //esi=username</p>
<p>00401389h cmp a1, 0x41  //比较是否小于A</p>
<p>0040138Dh cmp a1, 0x5A  //比较是否大于Z</p>
<p>00401391h Inc esi  //username&gt;&gt;1</p>
<p>00401394h call dumped_.004013D2  //将小写字母转成大写</p>
<figure data-type="image" tabindex="23"><img src="https://ygytl.github.io//post-images/1592064763096.JPG" alt="img" loading="lazy"></figure>
<p>接着进入4013C2这个函数，将用户名每一位的ASCII值相加。</p>
<figure data-type="image" tabindex="24"><img src="https://ygytl.github.io//post-images/1592064770608.JPG" alt="img" loading="lazy"></figure>
 </br>
<p>6)序列号算法分析</p>
<figure data-type="image" tabindex="25"><img src="https://ygytl.github.io//post-images/1592064778269.JPG" alt="img" loading="lazy"></figure>
<p>取出每一位的ASCII值，然后减去0x30，即将字母转化为数字然后用edi乘0xA(0x10)，接着用edi再加上序列号。（edi与0x1234进行异或）</p>
 </br>
<p>序列号edi校验：</p>
<figure data-type="image" tabindex="26"><img src="https://ygytl.github.io//post-images/1592064802509.JPG" alt="img" loading="lazy"></figure>
 </br>
<p>比较edi与ebx是否相等：</p>
<figure data-type="image" tabindex="27"><img src="https://ygytl.github.io//post-images/1592064811680.JPG" alt="img" loading="lazy"></figure>
<h4 id="4写出注册机代码如下"><em><strong>*4.********写出注册机********代码如下：*</strong></em></h4>
<pre><code class="language-c++">#include&lt;bits/stdc++.h&gt;

using namespace std;

int main()

{

	string username;

	printf(&quot;请输入用户名: &quot;);

	cin &gt;&gt; username;

	int result = 0, l = username.length();

	for(int i=0; i&lt;l; i++){

		if(username[i]&gt;='a'&amp;&amp;username[i]&lt;='z'){

			username[i] = username[i]-'a' + 'A';

		}

		result += username[i];

	}

	result ^= 0x5678;

	result ^= 0x1234;

	printf(&quot;%d\n&quot;, result);

	return 0;

}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[1088 Rational Arithmetic (20分)题解]]></title>
        <id>https://ygytl.github.io/post/1088-rational-arithmetic-20-fen-ti-jie/</id>
        <link href="https://ygytl.github.io/post/1088-rational-arithmetic-20-fen-ti-jie/">
        </link>
        <updated>2020-06-11T15:33:26.000Z</updated>
        <content type="html"><![CDATA[<p>1088 Rational Arithmetic (20分)</p>
<p>For two rational numbers, your task is to implement the basic arithmetics, that is, to calculate their sum, difference, product and quotient.</p>
<h3 id="input-specification">Input Specification:</h3>
<p>Each input file contains one test case, which gives in one line the two rational numbers in the format <code>a1/b1 a2/b2</code>. The numerators and the denominators are all in the range of long int. If there is a negative sign, it must appear only in front of the numerator. The denominators are guaranteed to be non-zero numbers.</p>
<h3 id="output-specification">Output Specification:</h3>
<p>For each test case, print in 4 lines the sum, difference, product and quotient of the two rational numbers, respectively. The format of each line is <code>number1 operator number2 = result</code>. Notice that all the rational numbers must be in their simplest form <code>k a/b</code>, where <code>k</code> is the integer part, and <code>a/b</code> is the simplest fraction part. If the number is negative, it must be included in a pair of parentheses. If the denominator in the division is zero, output <code>Inf</code> as the result. It is guaranteed that all the output integers are in the range of <strong>long int</strong>.</p>
<h3 id="sample-input-1">Sample Input 1:</h3>
<pre><code class="language-in">2/3 -4/2
</code></pre>
<h3 id="sample-output-1">Sample Output 1:</h3>
<pre><code class="language-out">2/3 + (-2) = (-1 1/3)
2/3 - (-2) = 2 2/3
2/3 * (-2) = (-1 1/3)
2/3 / (-2) = (-1/3)
</code></pre>
<h3 id="sample-input-2">Sample Input 2:</h3>
<pre><code class="language-in">5/3 0/6
</code></pre>
<h3 id="sample-output-2">Sample Output 2:</h3>
<pre><code class="language-out">1 2/3 + 0 = 1 2/3
1 2/3 - 0 = 1 2/3
1 2/3 * 0 = 0
1 2/3 / 0 = Inf
</code></pre>
<hr>
<p>题目意思：求分数的加减乘除</p>
<p>输出规则：负数需要带括号输出。假分数要以标准格式输出。</p>
</br>
<p>解题思路：每个分数的输出格式都是同意的规则，将这个输出搞定就行了。</p>
<p>注意：数据类型要是long long类型，否则测试点2会报错。</p>
<hr>
<pre><code class="language-c++">#include&lt;bits/stdc++.h&gt;
using namespace std;
long long gcd(long long a, long long b){
	if(a==0) return b;
	gcd(b%a,a);
}
void com(long long x, long long y){
	long long g, c;
	bool f = false;
	g = gcd(abs(x),abs(y));
	x/=g; y/=g;
	c = x/y;
	if(c&lt;0) x *= -1;
	x %= y;
	if(c!=0){
		if(c&lt;0){
			printf(&quot;(%lld&quot;, c);
			f = true;
		}
		else printf(&quot;%lld&quot;, c);
	}
	if(x&lt;0){
		printf(&quot;(%lld&quot;, x);
		f = true;
	}
	else{
		if(c==0) printf(&quot;%lld&quot;, x);
		else if(c!=0&amp;&amp;x!=0) printf(&quot; %lld&quot;, x);
	}
	if(x!=0&amp;&amp;y!=1){
		printf(&quot;/%lld&quot;, y);
	}
	if(f) printf(&quot;)&quot;);
}
void solve1(long long a1, long long b1, long long a2, long long b2){
	com(a1,b1); printf(&quot; + &quot;);
	com(a2,b2); printf(&quot; = &quot;);
	long long a, b;
	b = b1*b2;
	a = a1*b2 + a2*b1;
	com(a,b);
}
void solve2(long long a1, long long b1, long long a2, long long b2){
	com(a1,b1); printf(&quot; - &quot;);
	com(a2,b2); printf(&quot; = &quot;);
	long long a, b;
	b = b1*b2;
	a = a1*b2 - a2*b1;
	com(a,b);
}
void solve3(long long a1, long long b1, long long a2, long long b2){
	com(a1,b1); printf(&quot; * &quot;);
	com(a2,b2); printf(&quot; = &quot;);
	if(a1==0||a2==0){
		printf(&quot;0&quot;);
		return ;
	}
	long long a, b;
	a = a1*a2; b = b1*b2;
	if(b&lt;0){
		b*=-1;
		a*=-1;
	}
	com(a,b);
}
void solve4(long long a1, long long b1, long long a2, long long b2){
	com(a1,b1); printf(&quot; / &quot;);
	com(a2,b2); printf(&quot; = &quot;);
	if(a2==0){
		printf(&quot;Inf&quot;);
		return ;
	}
	long long a, b;
	a = a1*b2; b = b1*a2;
	if(b&lt;0){
		b*=-1;
		a*=-1;
	}
	com(a,b);
}

int main()
{
	long long a1, b1, a2, b2;
	scanf(&quot;%lld/%lld %lld/%lld&quot;, &amp;a1, &amp;b1, &amp;a2, &amp;b2);
	solve1(a1,b1,a2,b2); printf(&quot;\n&quot;);
	solve2(a1,b1,a2,b2); printf(&quot;\n&quot;);
	solve3(a1,b1,a2,b2); printf(&quot;\n&quot;);
	solve4(a1,b1,a2,b2); printf(&quot;\n&quot;);
	return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[1086 Tree Traversals Again (25分)题解]]></title>
        <id>https://ygytl.github.io/post/1086-tree-traversals-again-25-fen-ti-jie/</id>
        <link href="https://ygytl.github.io/post/1086-tree-traversals-again-25-fen-ti-jie/">
        </link>
        <updated>2020-06-08T13:08:50.000Z</updated>
        <content type="html"><![CDATA[<p>1086 Tree Traversals Again (25分)</p>
<p>An inorder binary tree traversal can be implemented in a non-recursive way with a stack. For example, suppose that when a 6-node binary tree (with the keys numbered from 1 to 6) is traversed, the stack operations are: push(1); push(2); push(3); pop(); pop(); push(4); pop(); pop(); push(5); push(6); pop(); pop(). Then a unique binary tree (shown in Figure 1) can be generated from this sequence of operations. Your task is to give the postorder traversal sequence of this tree.</p>
<p><img src="https://images.ptausercontent.com/30" alt="img" loading="lazy"><br>
Figure 1</p>
<h3 id="input-specification">Input Specification:</h3>
<p>Each input file contains one test case. For each case, the first line contains a positive integer <em>N</em> (≤30) which is the total number of nodes in a tree (and hence the nodes are numbered from 1 to <em>N</em>). Then 2<em>N</em> lines follow, each describes a stack operation in the format: &quot;Push X&quot; where X is the index of the node being pushed onto the stack; or &quot;Pop&quot; meaning to pop one node from the stack.</p>
<h3 id="output-specification">Output Specification:</h3>
<p>For each test case, print the postorder traversal sequence of the corresponding tree in one line. A solution is guaranteed to exist. All the numbers must be separated by exactly one space, and there must be no extra space at the end of the line.</p>
<h3 id="sample-input">Sample Input:</h3>
<pre><code class="language-in">6
Push 1
Push 2
Push 3
Pop
Pop
Push 4
Pop
Pop
Push 5
Push 6
Pop
Pop
</code></pre>
<h3 id="sample-output">Sample Output:</h3>
<pre><code class="language-out">3 4 2 6 5 1
</code></pre>
<hr>
<p>题目描述：题目给定一个二叉树的中序遍历，不过，这个中序遍历要用过出栈入栈的方法得到，出栈的顺序就是这棵二叉树的中序遍历，而入栈的顺序就是先序遍历(这个有一丢丢难看出来哈，画画图就知道了)。给出先序和中序遍历，求后序遍历。</p>
</br>
<p>输入：第一行n为二叉树的节点数，接下来2*n行出栈入栈操作。</p>
<p>输出：输出这棵树的后序遍历。每个值间有个空格隔开。</p>
</br>
<p>解题思路：分别将先序遍历和中序遍历用数组存放。然后通过递归得到后序遍历结果。怎么实现已知先序和中序遍历，就能得到后序遍历呢？主要找根节点，从先序遍历的第一个值，就是树的根结点开始递归。我们用样例来分析。</p>
<table>
<thead>
<tr>
<th>index</th>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
</tr>
</thead>
<tbody>
<tr>
<td>Pre</td>
<td>1</td>
<td>2</td>
<td>3</td>
<td>4</td>
<td>5</td>
<td>6</td>
</tr>
<tr>
<td>In</td>
<td>3</td>
<td>2</td>
<td>4</td>
<td>1</td>
<td>6</td>
<td>5</td>
</tr>
</tbody>
</table>
<p>后序遍历结果：3 4 2 6 5 1</p>
<p>1）递归一开始，root=0，inl=0，inr=n-1=5，这些传入函数的值分别是根节点在先序遍历Pre中的索引位置，中序遍历的左右索引边界。</p>
<p>2）递归的退出口是非常重要的，要想好放在哪。这里就是当inl大于inr时，递归结束。</p>
<p>3）while循环得到的是根节点在中序遍历中的位置，用i来标记。</p>
<p>4）接着分别找到先序遍历中，当前根节点的左右子结点索引，充当递归的根节点索引。为什么找索引，知道索引，那么值也就很容易得到啦</p>
<p>5）左子结点直接root+1就行；右子节点需要计算一下，式子为root+(i-inl)+1，i-inl是左子树值的个数，这里需要把他们排除了，再加一，就得到右子节点的索引了。</p>
<p>6）为什么post_back写在最后面，题目求的是后序遍历嘛。放在while循环后面得到先序遍历，放在两个get_post之间得到中序遍历。</p>
<hr>
<pre><code class="language-c++">#include&lt;bits/stdc++.h&gt;
using namespace std;
int n;
const int maxn = 100;
int in[maxn], pre[maxn];
vector&lt;int&gt; post;
void get_post(int root, int l, int r){
	if(l&gt;r) return ;
	int i = l;
	while(i&lt;=r&amp;&amp;pre[root]!=in[i]) i++;
	get_post(root+1,l,i-1);
	get_post(root+i-l+1,i+1,r);
	post.push_back(pre[root]);
}
int main()
{
	string str;
	int c1=0, c2=0, c3=0, k;
	stack&lt;int&gt; s; 
	cin &gt;&gt; n;
	for(int i=0; i&lt;2*n; i++){
		cin &gt;&gt; str;
		if(str==&quot;Push&quot;){
			cin &gt;&gt; k;
			pre[c1++] = k;
			s.push(k);
		}
		else{
			in[c2++] = s.top();
			s.pop();
		}
	}
	get_post(0, 0, n-1);
	for(int i=0; i&lt;post.size(); i++){
		if(i) printf(&quot; &quot;);
		printf(&quot;%d&quot;, post[i]);
	}
	return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[1085 Perfect Sequence (25分)题解]]></title>
        <id>https://ygytl.github.io/post/1085-perfect-sequence-25-fen-ti-jie/</id>
        <link href="https://ygytl.github.io/post/1085-perfect-sequence-25-fen-ti-jie/">
        </link>
        <updated>2020-06-07T16:12:19.000Z</updated>
        <content type="html"><![CDATA[<p>1085 Perfect Sequence (25分)</p>
<p>Given a sequence of positive integers and another positive integer <em>p</em>. The sequence is said to be a <strong>perfect sequence</strong> if <em>M</em>≤<em>m</em>×<em>p</em> where <em>M</em> and <em>m</em> are the maximum and minimum numbers in the sequence, respectively.</p>
<p>Now given a sequence and a parameter <em>p</em>, you are supposed to find from the sequence as many numbers as possible to form a perfect subsequence.</p>
<h3 id="input-specification">Input Specification:</h3>
<p>Each input file contains one test case. For each case, the first line contains two positive integers <em>N</em> and <em>p</em>, where <em>N</em> (≤105) is the number of integers in the sequence, and <em>p</em> (≤109) is the parameter. In the second line there are <em>N</em> positive integers, each is no greater than 109.</p>
<h3 id="output-specification">Output Specification:</h3>
<p>For each test case, print in one line the maximum number of integers that can be chosen to form a perfect subsequence.</p>
<h3 id="sample-input">Sample Input:</h3>
<pre><code class="language-in">10 8
2 3 20 4 5 1 6 7 8 9
</code></pre>
<h3 id="sample-output">Sample Output:</h3>
<pre><code class="language-out">8
</code></pre>
<hr>
<p>题目描述：求完美数列，要求数列元素尽可能多。完美数列公式：M&lt;=m*p，M为数列中最大值，m为数列中最小值，p是给定的值。</p>
</br>
<p>输入：第一行两个值n，p，分别为数列元素个数，p是给定的值；第二行n个值给出无序的数列。</p>
<p>输出：完美数列元素的个数。</p>
</br>
<p>解题思路：要用long long类型存值，不然测试点5报错。将给定的数列从小到大排序，接着从索引0开始遍历，用二分查找找到每个元素能组成的最大完美子序列长度，进行比较后得出结果。</p>
<hr>
<pre><code class="language-c++">#include&lt;bits/stdc++.h&gt;
using namespace std;
const int maxn = 200000+5;
long long v[maxn];
int n, p;
int search(int g){
	int l=g, r=n-1, mid;
	int tx = 0;
	while(l&lt;=r){
		mid = (l+r)/2;
		if(v[mid]&lt;=v[g]*p){
			tx = max(tx,mid-g+1);
			l = mid + 1;
		}
		else r = mid-1;
	}
	return tx;
}
int main()
{
	int ans=0;
	scanf(&quot;%d %d&quot;, &amp;n, &amp;p);
	for(int i=0; i&lt;n; i++) scanf(&quot;%lld&quot;, &amp;v[i]);
	sort(v,v+n);//小到大 
	for(int i=0; i&lt;n; i++){
		ans = max(ans,search(i));
	}
	printf(&quot;%d&quot;, ans);
	return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[1084 Broken Keyboard (20分)题解]]></title>
        <id>https://ygytl.github.io/post/1084-broken-keyboard-20-fen-ti-jie/</id>
        <link href="https://ygytl.github.io/post/1084-broken-keyboard-20-fen-ti-jie/">
        </link>
        <updated>2020-06-07T14:47:11.000Z</updated>
        <content type="html"><![CDATA[<p>1084 Broken Keyboard (20分)</p>
<p>On a broken keyboard, some of the keys are worn out. So when you type some sentences, the characters corresponding to those keys will not appear on screen.</p>
<p>Now given a string that you are supposed to type, and the string that you actually type out, please list those keys which are for sure worn out.</p>
<h3 id="input-specification">Input Specification:</h3>
<p>Each input file contains one test case. For each case, the 1st line contains the original string, and the 2nd line contains the typed-out string. Each string contains no more than 80 characters which are either English letters [A-Z] (case insensitive), digital numbers [0-9], or <code>_</code> (representing the space). It is guaranteed that both strings are non-empty.</p>
<h3 id="output-specification">Output Specification:</h3>
<p>For each test case, print in one line the keys that are worn out, in the order of being detected. The English letters must be capitalized. Each worn out key must be printed once only. It is guaranteed that there is at least one worn out key.</p>
<h3 id="sample-input">Sample Input:</h3>
<pre><code class="language-in">7_This_is_a_test
_hs_s_a_es
</code></pre>
<h3 id="sample-output">Sample Output:</h3>
<pre><code class="language-out">7TI
</code></pre>
<hr>
<p>题目描述：在一个坏掉的键盘上，有些键是损坏的，我们通过输入一串字符串，来找到那些坏掉的键。</p>
</br>
<p>输入：第一行一串字符串，若键盘没有坏，他应该像第一行的字符串这样完整的显示在电脑屏幕上。第二行也是字符串，他是坏掉的键盘输入后，显示在电脑上的效果。</p>
<p>输出：坏掉的键值，若是拼音，则输出他的大写形式。</p>
</br>
<p>解题思路：两个字符串同时从索引0开始扫描，对比一下两个字符串，结果就出来了。哦，因为题目要求输出字母大写的形式，若字符串中出现小写字母，要转换处理一下再输出。</p>
<hr>
<pre><code class="language-c++">#include&lt;bits/stdc++.h&gt;
using namespace std;
int main()
{
	string s1, s2;
	getline(cin,s1);
	getline(cin,s2);
	int c = 0;
	map&lt;char,bool&gt; p;
	for(int i=0; i&lt;s1.length(); i++){
		char ch1=s1[i], ch2=s2[c];
		if(s1[i]&gt;='a'&amp;&amp;s1[i]&lt;='z') ch1 = s1[i]-'a'+'A';
		if(s2[c]&gt;='a'&amp;&amp;s2[c]&lt;='z') ch2 = s2[c]-'a'+'A'; 
		if(ch1!=ch2&amp;&amp;p[ch1]==false){
			cout &lt;&lt; ch1;
			p[ch1] = true;
		}
		else if(ch1==ch2) c++;
	}
    cout &lt;&lt; endl;
	return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[1083 List Grades (25分)题解]]></title>
        <id>https://ygytl.github.io/post/1083-list-grades-25-fen-ti-jie/</id>
        <link href="https://ygytl.github.io/post/1083-list-grades-25-fen-ti-jie/">
        </link>
        <updated>2020-06-07T14:19:56.000Z</updated>
        <content type="html"><![CDATA[<p>1083 List Grades (25分)</p>
<p>Given a list of <em>N</em> student records with name, ID and grade. You are supposed to sort the records with respect to the grade in non-increasing order, and output those student records of which the grades are in a given interval.</p>
<h3 id="input-specification">Input Specification:</h3>
<p>Each input file contains one test case. Each case is given in the following format:</p>
<pre><code>N
name[1] ID[1] grade[1]
name[2] ID[2] grade[2]
... ...
name[N] ID[N] grade[N]
grade1 grade2
</code></pre>
<p>where <code>name[i]</code> and <code>ID[i]</code> are strings of no more than 10 characters with no space, <code>grade[i]</code> is an integer in [0, 100], <code>grade1</code> and <code>grade2</code> are the boundaries of the grade's interval. It is guaranteed that all the grades are <strong>distinct</strong>.</p>
<h3 id="output-specification">Output Specification:</h3>
<p>For each test case you should output the student records of which the grades are in the given interval [<code>grade1</code>, <code>grade2</code>] and are in non-increasing order. Each student record occupies a line with the student's name and ID, separated by one space. If there is no student's grade in that interval, output <code>NONE</code> instead.</p>
<h3 id="sample-input-1">Sample Input 1:</h3>
<pre><code class="language-in">4
Tom CS000001 59
Joe Math990112 89
Mike CS991301 100
Mary EE990830 95
60 100
</code></pre>
<h3 id="sample-output-1">Sample Output 1:</h3>
<pre><code class="language-out">Mike CS991301
Mary EE990830
Joe Math990112
</code></pre>
<h3 id="sample-input-2">Sample Input 2:</h3>
<pre><code class="language-in">2
Jean AA980920 60
Ann CS01 80
90 95
</code></pre>
<h3 id="sample-output-2">Sample Output 2:</h3>
<pre><code class="language-out">NONE
</code></pre>
<hr>
<p>题目描述：题目给定某些学生的信息，包括姓名、课程号、课程得分，现在给定一个区间的分数，若有学生分数在给定区间内，则输出该学生的姓名及性别。没有则输出NONE。</p>
</br>
<p>输入：第一行n表示学生信息个数。接下来n行提供学生信息。</p>
<p>输出：输出分数在给定区间分数的学生信息，输出时按成绩递减输出，若没有符合的学生，输出NONE。</p>
</br>
<p>解题思路：写个cmp函数比较排序一下就行了。</p>
<hr>
<pre><code class="language-c++">#include&lt;bits/stdc++.h&gt;
using namespace std;
struct node{
	string name, class_name;
	int score;
};
vector&lt;node&gt; v, List;
bool cmp(node a, node b){
	return a.score &gt; b.score;
}
int main()
{
	int n, l, r;
	node t;
	scanf(&quot;%d&quot;, &amp;n);
	for(int i=0; i&lt;n; i++){
		cin &gt;&gt; t.name &gt;&gt; t.class_name &gt;&gt; t.score;
		v.push_back(t);
	}
	scanf(&quot;%d %d&quot;, &amp;l, &amp;r);
	for(int i=0; i&lt;n; i++){
		t = v[i];
		if(t.score &gt;= l &amp;&amp; t.score &lt;= r){
			List.push_back(t);
		}
	}
	sort(List.begin(),List.end(),cmp);
	if(List.size()==0) printf(&quot;NONE&quot;);
	for(int i=0; i&lt;List.size(); i++){
		cout &lt;&lt; List[i].name &lt;&lt; &quot; &quot; &lt;&lt; List[i].class_name &lt;&lt; endl;
	}
	return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[1082 Read Number in Chinese (25分)题解]]></title>
        <id>https://ygytl.github.io/post/1082-read-number-in-chinese-25-fen-ti-jie/</id>
        <link href="https://ygytl.github.io/post/1082-read-number-in-chinese-25-fen-ti-jie/">
        </link>
        <updated>2020-06-07T13:17:11.000Z</updated>
        <content type="html"><![CDATA[<p>1082 Read Number in Chinese (25分)</p>
<p>Given an integer with no more than 9 digits, you are supposed to read it in the traditional Chinese way. Output <code>Fu</code> first if it is negative. For example, -123456789 is read as <code>Fu yi Yi er Qian san Bai si Shi wu Wan liu Qian qi Bai ba Shi jiu</code>. Note: zero (<code>ling</code>) must be handled correctly according to the Chinese tradition. For example, 100800 is <code>yi Shi Wan ling ba Bai</code>.</p>
<h3 id="input-specification">Input Specification:</h3>
<p>Each input file contains one test case, which gives an integer with no more than 9 digits.</p>
<h3 id="output-specification">Output Specification:</h3>
<p>For each test case, print in a line the Chinese way of reading the number. The characters are separated by a space and there must be no extra space at the end of the line.</p>
<h3 id="sample-input-1">Sample Input 1:</h3>
<pre><code class="language-in">-123456789
</code></pre>
<h3 id="sample-output-1">Sample Output 1:</h3>
<pre><code class="language-out">Fu yi Yi er Qian san Bai si Shi wu Wan liu Qian qi Bai ba Shi jiu
</code></pre>
<h3 id="sample-input-2">Sample Input 2:</h3>
<pre><code class="language-in">100800
</code></pre>
<h3 id="sample-output-2">Sample Output 2:</h3>
<pre><code class="language-out">yi Shi Wan ling ba Bai
</code></pre>
<hr>
<p>题目描述：将数字转化为字母拼音的格式</p>
</br>
<p>输入：不超过9 digits的数</p>
<p>输出：汉字拼音格式</p>
</br>
<p>解题思路：把几个坑说下，测试点3是输入0的时候是否输出'ling'。难点是对零的处理，给几个测试数据吧，测试通过基本就行了；这里提供两个写法，细节处理有些许不同。</p>
<pre><code>9090909
jiu Bai ling jiu Wan ling jiu Bai ling jiu

100000009
yi Yi Wan ling jiu

0
ling

10086
yi Wan ling ba Shi liu

110110
yi Shi yi Wan ling yi Bai yi Shi
</code></pre>
<hr>
<pre><code class="language-c++">#include&lt;bits/stdc++.h&gt;
using namespace std;
//方法一
int main()
{
	string s;
	cin &gt;&gt; s;
	map&lt;int,string&gt; p;
	p[0]=&quot;ling&quot;; p[1]=&quot;yi&quot;; p[2]=&quot;er&quot;; p[3]=&quot;san&quot;; p[4]=&quot;si&quot;; p[5]=&quot;wu&quot;;
	p[6]=&quot;liu&quot;; p[7]=&quot;qi&quot;; p[8]=&quot;ba&quot;; p[9]=&quot;jiu&quot;;
	if(s[0]=='-'){
		printf(&quot;Fu &quot;);
	}
	else s = &quot;+&quot;+s;
	string ans=&quot;&quot;;
	bool flag = false;
	int l = s.size();
	for(int i=1; i&lt;l; i++){
		if(s[i]=='0'){
			if(l-i==5) ans += &quot; Wan&quot;; 
			flag = true;
			continue;
		}
		else{
			if(i!=1) ans += &quot; &quot;;
			if(flag){
				ans+= p[0] + &quot; &quot;;
			}
			flag = false;
			if(l-i==1) ans += p[s[i]-'0'];
			if(l-i==2||l-i==6) ans += p[s[i]-'0'] + &quot; Shi&quot;;
			if(l-i==3||l-i==7) ans += p[s[i]-'0'] + &quot; Bai&quot;;
			if(l-i==4||l-i==8) ans += p[s[i]-'0'] + &quot; Qian&quot;;
			if(l-i==5) ans += p[s[i]-'0'] + &quot; Wan&quot;;
			if(l-i==9) ans += p[s[i]-'0'] + &quot; Yi&quot;;
		}
	}
	if(s==&quot;+0&quot;||s==&quot;-0&quot;) ans = &quot;ling&quot;;
	cout &lt;&lt; ans &lt;&lt; endl;
	return 0;
}
</code></pre>
<pre><code class="language-c++">#include&lt;bits/stdc++.h&gt;
using namespace std;
//方法二
int main()
{
	map&lt;int,string&gt; p;
	p[0] = &quot;ling&quot;; p[1] = &quot;yi&quot;; p[2] = &quot;er&quot;; p[3] = &quot;san&quot;;
	p[4] = &quot;si&quot;; p[5] = &quot;wu&quot;; p[6] = &quot;liu&quot;; p[7] = &quot;qi&quot;;
	p[8] = &quot;ba&quot;; p[9] = &quot;jiu&quot;;
	string str, ans=&quot;&quot;;
	cin &gt;&gt; str;
	int l, s=0;
	bool flag = false;
	l = str.length();
	if(str[0]=='-'){
		ans += &quot;Fu&quot;;
		s++; l--; flag = true;
	}
	bool f1=false, f2=false, f3=false;
	for(int i=s; i&lt;str.length(); i++,l--){
		f1 = false;
		if(l&gt;=5&amp;&amp;l&lt;=8) f2 = true;
		if(str[i]=='0') f3 = true;
		else{
			f1 = true;
			if(flag) ans += &quot; &quot;;
			if(f3) ans += &quot;ling &quot;;
			ans += p[str[i]-'0'];
			flag = true;
			f3 = false;
		}
		if(f1){
			if(l==2||l==6) ans += &quot; Shi&quot;;
			if(l==3||l==7) ans += &quot; Bai&quot;;
			if(l==4||l==8) ans += &quot; Qian&quot;;
			if(l==9) ans += &quot; Yi&quot;;
		}
		if(f2&amp;&amp;l==5){
			ans += &quot; Wan&quot;; f2 = false;
		}
	}
	if(str==&quot;0&quot;) ans = &quot;ling&quot;;
	cout &lt;&lt; ans &lt;&lt; endl;
	return 0;
}
</code></pre>
]]></content>
    </entry>
</feed>