<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://ygytl.github.io/</id>
    <title>Grace</title>
    <updated>2020-07-06T08:32:00.044Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://ygytl.github.io/"/>
    <link rel="self" href="https://ygytl.github.io/atom.xml"/>
    <subtitle>Grace&apos;s blog</subtitle>
    <logo>https://ygytl.github.io/images/avatar.png</logo>
    <icon>https://ygytl.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, Grace</rights>
    <entry>
        <title type="html"><![CDATA[1119 Pre- and Post-order Traversals (30分)题解]]></title>
        <id>https://ygytl.github.io/post/1119-pre-and-post-order-traversals-30-fen-ti-jie/</id>
        <link href="https://ygytl.github.io/post/1119-pre-and-post-order-traversals-30-fen-ti-jie/">
        </link>
        <updated>2020-07-06T08:31:34.000Z</updated>
        <content type="html"><![CDATA[<p>1119 Pre- and Post-order Traversals (30分)</p>
<p>Suppose that all the keys in a binary tree are distinct positive integers. A unique binary tree can be determined by a given pair of postorder and inorder traversal sequences, or preorder and inorder traversal sequences. However, if only the postorder and preorder traversal sequences are given, the corresponding tree may no longer be unique.</p>
<p>Now given a pair of postorder and preorder traversal sequences, you are supposed to output the corresponding inorder traversal sequence of the tree. If the tree is not unique, simply output any one of them.</p>
<h3 id="input-specification">Input Specification:</h3>
<p>Each input file contains one test case. For each case, the first line gives a positive integer N (≤ 30), the total number of nodes in the binary tree. The second line gives the preorder sequence and the third line gives the postorder sequence. All the numbers in a line are separated by a space.</p>
<h3 id="output-specification">Output Specification:</h3>
<p>For each test case, first printf in a line <code>Yes</code> if the tree is unique, or <code>No</code> if not. Then print in the next line the inorder traversal sequence of the corresponding binary tree. If the solution is not unique, any answer would do. It is guaranteed that at least one solution exists. All the numbers in a line must be separated by exactly one space, and there must be no extra space at the end of the line.</p>
<h3 id="sample-input-1">Sample Input 1:</h3>
<pre><code class="language-in">7
1 2 3 4 6 7 5
2 6 7 4 5 3 1
</code></pre>
<h3 id="sample-output-1">Sample Output 1:</h3>
<pre><code class="language-out">Yes
2 1 6 4 7 3 5
</code></pre>
<h3 id="sample-input-2">Sample Input 2:</h3>
<pre><code class="language-in">4
1 2 3 4
2 4 3 1
</code></pre>
<h3 id="sample-output-2">Sample Output 2:</h3>
<pre><code class="language-out">No
2 1 3 4
</code></pre>
<hr>
<p>题目描述：提供一个二叉树的所有节点值(值为正整数)。唯一的二叉树可以由后序遍历和中序遍历得到，也可以由先序遍历和中序遍历得到。但是，如果只给出先序遍历和后序遍历，得到的二叉树有可能是不唯一的，则他的中序遍历也有可能不唯一。题目给出一对先序遍历和后序遍历数组，求出是否能得到唯一的二叉树，可以则输出Yes，否则输出No。最后一行输出中序遍历，若有多个，输出一个即可。</p>
</br>
<p>解题思路：设置一个flag标志，判断这个二叉树是否唯一。</p>
<p>用样例分析一下：</p>
<table>
<thead>
<tr>
<th>index</th>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
</tr>
</thead>
<tbody>
<tr>
<td>pre</td>
<td>1</td>
<td>2</td>
<td>3</td>
<td>4</td>
<td>6</td>
<td>7</td>
<td>5</td>
</tr>
<tr>
<td>post</td>
<td>2</td>
<td>6</td>
<td>7</td>
<td>4</td>
<td>5</td>
<td>3</td>
<td>1</td>
</tr>
</tbody>
</table>
<p>prel、prer分别是pre数组的左右索引边界值；postl、postr分别是post数组的左右索引边界值。</p>
<p>一开始prel=0，prer=6，postl=0，postr=6</p>
<p>当pre[prel]等于post[postr]，==&gt;pre[0]=1，post[6]=1，一开始就相等了，可以知道，这个值就是根节点的值。题目要求输出中序遍历，输出顺序是左、中(根)、右。当得到中(根)时，不能直接输出，要先求出左，才能将中(根)输出。后续的过程看代码，已加上注释。</p>
<hr>
<pre><code class="language-c++">#include&lt;bits/stdc++.h&gt;
using namespace std;
int n;
vector&lt;int&gt; pre, post, inorder;
bool flag = true;
void get_inorder(int prel, int prer, int postl, int postr){
	if(prel==prer){
		inorder.push_back(pre[prel]);
		return ;
	}
	int i=prel, j=postr-1, k;
	if(pre[prel]==post[postr]){//发现中间结点 
		while(i&lt;=prer&amp;&amp;j&gt;=0&amp;&amp;pre[i]!=post[j]) i++;//求出右子节点在pre数组的位置
		k = i-prel-1;//得到左子树的结点个数
		if(k&gt;0){
			get_inorder(prel+1,i-1,postl,postl+k-1);//左子树进入递归，相应的数组范围会改变
		}
		else flag = false;
	}
	inorder.push_back(post[postr]);
	get_inorder(i,prer,postl+k,postr-1);//右子树进入递归
}
int main()
{
	scanf(&quot;%d&quot;, &amp;n);
	pre.resize(n);
	post.resize(n);
	for(int i=0; i&lt;n; i++) scanf(&quot;%d&quot;, &amp;pre[i]);
	for(int i=0; i&lt;n; i++) scanf(&quot;%d&quot;, &amp;post[i]);
	get_inorder(0,n-1,0,n-1);
	if(flag) printf(&quot;Yes\n&quot;);
	else printf(&quot;No\n&quot;);
	for(int i=0; i&lt;inorder.size(); i++){
		if(i) printf(&quot; &quot;);
		printf(&quot;%d&quot;, inorder[i]);
	}
	printf(&quot;\n&quot;);//没有这个就格式错误，0分bug
	return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[1115 Counting Nodes in a BST (30分)题解]]></title>
        <id>https://ygytl.github.io/post/1115-counting-nodes-in-a-bst-30-fen-ti-jie/</id>
        <link href="https://ygytl.github.io/post/1115-counting-nodes-in-a-bst-30-fen-ti-jie/">
        </link>
        <updated>2020-07-05T06:06:15.000Z</updated>
        <content type="html"><![CDATA[<p>1115 Counting Nodes in a BST (30分)</p>
<p>A Binary Search Tree (BST) is recursively defined as a binary tree which has the following properties:</p>
<ul>
<li>The left subtree of a node contains only nodes with keys less than or equal to the node's key.</li>
<li>The right subtree of a node contains only nodes with keys greater than the node's key.</li>
<li>Both the left and right subtrees must also be binary search trees.</li>
</ul>
<p>Insert a sequence of numbers into an initially empty binary search tree. Then you are supposed to count the total number of nodes in the lowest 2 levels of the resulting tree.</p>
<h3 id="input-specification">Input Specification:</h3>
<p>Each input file contains one test case. For each case, the first line gives a positive integer <em>N</em> (≤1000) which is the size of the input sequence. Then given in the next line are the <em>N</em> integers in [−1000,1000] which are supposed to be inserted into an initially empty binary search tree.</p>
<h3 id="output-specification">Output Specification:</h3>
<p>For each case, print in one line the numbers of nodes in the lowest 2 levels of the resulting tree in the format:</p>
<pre><code>n1 + n2 = n
</code></pre>
<p>where <code>n1</code> is the number of nodes in the lowest level, <code>n2</code> is that of the level above, and <code>n</code> is the sum.</p>
<h3 id="sample-input">Sample Input:</h3>
<pre><code class="language-in">9
25 30 42 16 20 20 35 -5 28
</code></pre>
<h3 id="sample-output">Sample Output:</h3>
<pre><code class="language-out">2 + 4 = 6
</code></pre>
<hr>
<p>题目描述：二叉搜索树的特点有：</p>
<p>1）左子结点的值小于或等于根节点的值</p>
<p>2）右子结点的值大于根节点的值</p>
<p>3）所有左子树和右子树都是一个二叉搜索树</p>
<p>现在给出一组数，插入二叉搜索树中，求倒数第一层、倒数第二层的结点数，n1和n2，最后输出n1+n2。</p>
</br>
<p>解题思路：利用结构体建一棵二叉搜索树，再利用bfs将树的每一层结点分别存入vector数组中，很快就能得到结果了。写程序要有意识的将程序分块，不能将所有代码都写在主程序。</p>
<hr>
<pre><code class="language-c++">#include&lt;bits/stdc++.h&gt;
using namespace std;
int n, k;
const int maxn = 1e4+5;
vector&lt;int&gt; v[maxn];
struct node{
	int num;
	node *l, *r;
	node(){
		l = r = NULL;
	}
};
node* build(node *tree, int x){
	if(tree==NULL){
		tree = new node();
		tree-&gt;num = x;
		tree-&gt;l = tree-&gt;r = NULL;
	}
	else if(tree-&gt;num&lt;x){
		tree-&gt;r = build(tree-&gt;r,x);
	}
	else tree-&gt;l = build(tree-&gt;l,x);
	return tree;
}

void bfs(node *tree){
	int cnt = 0;
	queue&lt;pair&lt;node*,int&gt; &gt; q;
	pair&lt;node*,int&gt; t, tt;
	t.first = tree;
	t.second = 0;
	q.push(t);
	while(!q.empty()){
		t = q.front(); q.pop();
		cnt = t.second;
		v[t.second].push_back(t.first-&gt;num);
		if(t.first-&gt;l!=NULL){
			tt.first = t.first-&gt;l;
			tt.second = t.second+1;
			q.push(tt);
		}
		if(t.first-&gt;r!=NULL){
			tt.first = t.first-&gt;r;
			tt.second = t.second+1;
			q.push(tt);
		}
	}
	int n1 = v[cnt].size(), n2 = v[cnt-1].size();
	printf(&quot;%d + %d = %d\n&quot;, n1, n2, n1+n2);
}

int main()
{
	node *tree = NULL;
	scanf(&quot;%d&quot;, &amp;n);
	for(int i=0; i&lt;n; i++){
		scanf(&quot;%d&quot;, &amp;k);
		tree = build(tree,k);
	}
	bfs(tree);
	return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[1111 Online Map (30分)题解]]></title>
        <id>https://ygytl.github.io/post/1111-online-map-30-fen-ti-jie/</id>
        <link href="https://ygytl.github.io/post/1111-online-map-30-fen-ti-jie/">
        </link>
        <updated>2020-07-04T08:42:46.000Z</updated>
        <content type="html"><![CDATA[<p>1111 Online Map (30分)</p>
<p>Input our current position and a destination, an online map can recommend several paths. Now your job is to recommend two paths to your user: one is the shortest, and the other is the fastest. It is guaranteed that a path exists for any request.</p>
<h3 id="input-specification">Input Specification:</h3>
<p>Each input file contains one test case. For each case, the first line gives two positive integers <em>N</em> (2≤<em>N</em>≤500), and <em>M</em>, being the total number of streets intersections on a map, and the number of streets, respectively. Then <em>M</em> lines follow, each describes a street in the format:</p>
<pre><code>V1 V2 one-way length time
</code></pre>
<p>where <code>V1</code> and <code>V2</code> are the indices (from 0 to <em>N</em>−1) of the two ends of the street; <code>one-way</code> is 1 if the street is one-way from <code>V1</code> to <code>V2</code>, or 0 if not; <code>length</code> is the length of the street; and <code>time</code> is the time taken to pass the street.</p>
<p>Finally a pair of source and destination is given.</p>
<h3 id="output-specification">Output Specification:</h3>
<p>For each case, first print the shortest path from the source to the destination with distance <code>D</code> in the format:</p>
<pre><code>Distance = D: source -&gt; v1 -&gt; ... -&gt; destination
</code></pre>
<p>Then in the next line print the fastest path with total time <code>T</code>:</p>
<pre><code>Time = T: source -&gt; w1 -&gt; ... -&gt; destination
</code></pre>
<p>In case the shortest path is not unique, output the fastest one among the shortest paths, which is guaranteed to be unique. In case the fastest path is not unique, output the one that passes through the fewest intersections, which is guaranteed to be unique.</p>
<p>In case the shortest and the fastest paths are identical, print them in one line in the format:</p>
<pre><code>Distance = D; Time = T: source -&gt; u1 -&gt; ... -&gt; destination
</code></pre>
<h3 id="sample-input-1">Sample Input 1:</h3>
<pre><code class="language-in">10 15
0 1 0 1 1
8 0 0 1 1
4 8 1 1 1
3 4 0 3 2
3 9 1 4 1
0 6 0 1 1
7 5 1 2 1
8 5 1 2 1
2 3 0 2 2
2 1 1 1 1
1 3 0 3 1
1 4 0 1 1
9 7 1 3 1
5 1 0 5 2
6 5 1 1 2
3 5
</code></pre>
<h3 id="sample-output-1">Sample Output 1:</h3>
<pre><code class="language-out">Distance = 6: 3 -&gt; 4 -&gt; 8 -&gt; 5
Time = 3: 3 -&gt; 1 -&gt; 5
</code></pre>
<h3 id="sample-input-2">Sample Input 2:</h3>
<pre><code class="language-in">7 9
0 4 1 1 1
1 6 1 1 3
2 6 1 1 1
2 5 1 2 2
3 0 0 1 1
3 1 1 1 3
3 2 1 1 2
4 5 0 2 2
6 5 1 1 2
3 5
</code></pre>
<h3 id="sample-output-2">Sample Output 2:</h3>
<pre><code class="language-out">Distance = 3; Time = 4: 3 -&gt; 2 -&gt; 5
</code></pre>
<hr>
<p>题目描述：分别求出发地点到目的地的最短距离，最短时间路径；当最短路程路线不唯一时，找到当中花费时间最短的路径；当最短时间路径不唯一时，找分岔口最少的路径；</p>
<p>输出规则提示：当最短距离路径与最短时间路径相同时，按照Distance = D; Time = T: source -&gt; u1 -&gt; ... -&gt; destination 格式输出</p>
<p>解题思路：Dij</p>
<hr>
<pre><code class="language-c++">#include&lt;bits/stdc++.h&gt;
using namespace std;
int n, m, st, et;
const int maxn = 1000 + 5;
const int inf = 0x3f3f3f3f;
vector&lt;int&gt; G[maxn];
int G2[maxn][maxn], G3[maxn][maxn];
bool vis[maxn];
int dist1[maxn], T1[maxn], f1[maxn], f2[maxn], dist2[maxn], T2[maxn];
stack&lt;int&gt; s1, s2;
void Dij1(){
	int sst = st, eet = et;
	memset(vis,false,sizeof(vis));
	memset(dist1,inf,sizeof(dist1));
	memset(T1,inf,sizeof(T1));
	dist1[st] = 0; T1[st] = 0;
	f1[st] = st;
	while(1){
		int index=-1, mx = inf;
		for(int i=0; i&lt;n; i++){
			if(!vis[i]&amp;&amp;dist1[i]&lt;mx){
				mx = dist1[i];
				index = i;
			}
		}
		if(index==-1) break;
		vis[index] = true;
		int u = index, v;
		for(int i=0; i&lt;G[u].size(); i++){
			v = G[u][i];
			if(!vis[v]){
				if(dist1[v]&gt;dist1[u]+G2[u][v]){
					dist1[v] = dist1[u] + G2[u][v];
					T1[v] = T1[u] + G3[u][v];
					f1[v] = u;
				}
				else if(dist1[v]==dist1[u]+G2[u][v]){
					if(T1[v]&gt;T1[u] + G3[u][v]){
						T1[v] = T1[u] + G3[u][v];
						f1[v] = u;
					}
				}
			}
		}
	}
	while(f1[eet]!=eet){
		s1.push(eet);
		eet = f1[eet];
	}
	s1.push(sst);
}
void Dij2(){
	int sst = st, eet = et;
	memset(vis,false,sizeof(vis));
	memset(dist2,0,sizeof(dist2));
	memset(T2,inf,sizeof(T2));
	T2[st] = 0; dist2[st] = 1;
	f2[st] = st;
	while(1){
		int index=-1, mx = inf;
		for(int i=0; i&lt;n; i++){
			if(!vis[i]&amp;&amp;T2[i]&lt;mx){
				mx = T2[i];
				index = i;
			}
		}
		if(index==-1) break;
		vis[index] = true;
		int u = index, v;
		for(int i=0; i&lt;G[u].size(); i++){
			v = G[u][i];
			if(!vis[v]){
				if(T2[v]&gt;T2[u]+G3[u][v]){
					T2[v] = T2[u] + G3[u][v];
					f2[v] = u;
					dist2[v] = dist2[u] + 1;
				}
				else if(T2[v]==T2[u]+G3[u][v]){
					if(dist2[v]&gt;dist2[u]+1){
						dist2[v] = dist2[u] + 1;
						f2[v] = u;
					}
				}
			}
		}
	}
	while(f2[eet]!=eet){
		s2.push(eet);
		eet = f2[eet];
	}
	s2.push(sst);
}

int main()
{
	int v1, v2, way, length, time;
	scanf(&quot;%d %d&quot;, &amp;n, &amp;m);
	for(int i=0; i&lt;m; i++){
		scanf(&quot;%d %d %d %d %d&quot;, &amp;v1, &amp;v2, &amp;way, &amp;length, &amp;time);
		
		if(way==1) G[v1].push_back(v2);//v1 -&gt; v2
		else{
			G[v1].push_back(v2);
			G[v2].push_back(v1);
		}
		G2[v1][v2] = G2[v2][v1] = length;
		G3[v1][v2] = G3[v2][v1] = time;
	}
	scanf(&quot;%d %d&quot;, &amp;st, &amp;et);
	Dij1();
	Dij2();
	if(s1==s2){
		printf(&quot;Distance = %d; Time = %d:&quot;, dist1[et], T2[et]);
		int c = 0;
		while(!s1.empty()){
			if(c==0) printf(&quot; &quot;);
			else printf(&quot; -&gt; &quot;);
			printf(&quot;%d&quot;, s1.top());
			s1.pop(); c++;
		}
	}
	else{
		printf(&quot;Distance = %d:&quot;, dist1[et]);
		int c = 0;
		while(!s1.empty()){
			if(c==0) printf(&quot; &quot;);
			else printf(&quot; -&gt; &quot;);
			printf(&quot;%d&quot;, s1.top());
			s1.pop(); c++;
		}
		printf(&quot;\nTime = %d:&quot;, T2[et]);
		c = 0;
		while(!s2.empty()){
			if(c==0) printf(&quot; &quot;);
			else printf(&quot; -&gt; &quot;);
			printf(&quot;%d&quot;, s2.top());
			s2.pop(); c++;
		} 
	}
	return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[1107 Social Clusters (30分)题解]]></title>
        <id>https://ygytl.github.io/post/1107-social-clusters-30-fen-ti-jie/</id>
        <link href="https://ygytl.github.io/post/1107-social-clusters-30-fen-ti-jie/">
        </link>
        <updated>2020-07-03T10:05:36.000Z</updated>
        <content type="html"><![CDATA[<p>1107 Social Clusters (30分)</p>
<p>When register on a social network, you are always asked to specify your hobbies in order to find some potential friends with the same hobbies. A <strong>social cluster</strong> is a set of people who have some of their hobbies in common. You are supposed to find all the clusters.</p>
<h3 id="input-specification">Input Specification:</h3>
<p>Each input file contains one test case. For each test case, the first line contains a positive integer <em>N</em> (≤1000), the total number of people in a social network. Hence the people are numbered from 1 to <em>N</em>. Then <em>N</em> lines follow, each gives the hobby list of a person in the format:</p>
<p><em>K**i</em>: <em>h**i</em>[1] <em>h**i</em>[2] ... <em>h**i</em>[<em>K**i</em>]</p>
<p>where <em>K**i</em> (&gt;0) is the number of hobbies, and <em>h**i</em>[<em>j</em>] is the index of the <em>j</em>-th hobby, which is an integer in [1, 1000].</p>
<h3 id="output-specification">Output Specification:</h3>
<p>For each case, print in one line the total number of clusters in the network. Then in the second line, print the numbers of people in the clusters in non-increasing order. The numbers must be separated by exactly one space, and there must be no extra space at the end of the line.</p>
<h3 id="sample-input">Sample Input:</h3>
<pre><code class="language-in">8
3: 2 7 10
1: 4
2: 5 3
1: 4
1: 3
1: 4
4: 6 8 1 5
1: 4
</code></pre>
<h3 id="sample-output">Sample Output:</h3>
<pre><code class="language-out">3
4 3 1
</code></pre>
<hr>
<p>题目描述：潜在的朋友圈</p>
<p>输入：第一行n，表示人数；接着n行，每行是第i个人选择的课程数及课程id号。</p>
<p>输出：第一行输出多少个圈，接着输出按照圈里人数的大小递减输出。</p>
<p>解题思路：并查集，求出有多少个朋友圈，按照朋友圈的人数从大到小输出每个圈的人数就行了。</p>
<hr>
<pre><code class="language-c++">#include&lt;bits/stdc++.h&gt;
using namespace std;
int n, m;
const int maxn = 2000;
vector&lt;int&gt; v[maxn];
int f[maxn], g[maxn];
set&lt;int&gt; s;
int find(int x){
	while(f[x]!=x){
		x = f[x];
	}
	return x;
}
void Union(int x, int y){
	x = find(x);
	y = find(y);
	f[x] = y;
}
bool cmp(int a, int b){
	return a &gt; b;
}
int main()
{
	int k;
	scanf(&quot;%d&quot;, &amp;n);
	for(int i=1; i&lt;=n; i++) f[i] = i;
	for(int i=1; i&lt;=n; i++){
		scanf(&quot;%d:&quot;, &amp;m);
		for(int j=0; j&lt;m; j++){
			scanf(&quot;%d&quot;, &amp;k);
			v[k].push_back(i);
			s.insert(k);
		}
	}
	set&lt;int&gt;::iterator it;
	for(it=s.begin(); it!=s.end(); it++){//课程id 
		sort(v[*it].begin(),v[*it].end());
		int x, y;
		for(int i=0; i&lt;v[*it].size(); i++){
			if(i==0) x = find(v[*it][i]);
			else{
				y = find(v[*it][i]);
				Union(x,y);
			}
		}
	}
	map&lt;int,int&gt; p;
	for(int i=1; i&lt;=n; i++) p[find(i)]++;
	map&lt;int,int&gt;::iterator it1;
	int cnt=0; 
	for(it1=p.begin(); it1!=p.end(); it1++){
		g[cnt++] = it1-&gt;second;
	}
	sort(g,g+cnt,cmp);
	printf(&quot;%d\n&quot;, cnt);
	for(int i=0; i&lt;cnt; i++){
		if(i) printf(&quot; &quot;);
		printf(&quot;%d&quot;, g[i]);
	}
	return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[1155 Heap Paths (30分)题解]]></title>
        <id>https://ygytl.github.io/post/1155-heap-paths-30-fen-ti-jie/</id>
        <link href="https://ygytl.github.io/post/1155-heap-paths-30-fen-ti-jie/">
        </link>
        <updated>2020-07-01T14:31:35.000Z</updated>
        <content type="html"><![CDATA[<p>1155 Heap Paths (30分)</p>
<p>In computer science, a <strong>heap</strong> is a specialized tree-based data structure that satisfies the heap property: if P is a parent node of C, then the key (the value) of P is either greater than or equal to (in a max heap) or less than or equal to (in a min heap) the key of C. A common implementation of a heap is the binary heap, in which the tree is a complete binary tree. (Quoted from Wikipedia at https://en.wikipedia.org/wiki/Heap_(data_structure))</p>
<p>One thing for sure is that all the keys along any path from the root to a leaf in a max/min heap must be in non-increasing/non-decreasing order.</p>
<p>Your job is to check every path in a given complete binary tree, in order to tell if it is a heap or not.</p>
<h3 id="input-specification">Input Specification:</h3>
<p>Each input file contains one test case. For each case, the first line gives a positive integer <em>N</em> (1&lt;<em>N</em>≤1,000), the number of keys in the tree. Then the next line contains <em>N</em> distinct integer keys (all in the range of <strong>int</strong>), which gives the level order traversal sequence of a complete binary tree.</p>
<h3 id="output-specification">Output Specification:</h3>
<p>For each given tree, first print all the paths from the root to the leaves. Each path occupies a line, with all the numbers separated by a space, and no extra space at the beginning or the end of the line. The paths must be printed in the following order: for each node in the tree, all the paths in its right subtree must be printed before those in its left subtree.</p>
<p>Finally print in a line <code>Max Heap</code> if it is a max heap, or <code>Min Heap</code> for a min heap, or <code>Not Heap</code> if it is not a heap at all.</p>
<h3 id="sample-input-1">Sample Input 1:</h3>
<pre><code class="language-in">8
98 72 86 60 65 12 23 50
</code></pre>
<h3 id="sample-output-1">Sample Output 1:</h3>
<pre><code class="language-out">98 86 23
98 86 12
98 72 65
98 72 60 50
Max Heap
</code></pre>
<h3 id="sample-input-2">Sample Input 2:</h3>
<pre><code class="language-in">8
8 38 25 58 52 82 70 60
</code></pre>
<h3 id="sample-output-2">Sample Output 2:</h3>
<pre><code class="language-out">8 25 70
8 25 82
8 38 52
8 38 58 60
Min Heap
</code></pre>
<h3 id="sample-input-3">Sample Input 3:</h3>
<pre><code class="language-in">8
10 28 15 12 34 9 8 56
</code></pre>
<h3 id="sample-output-3">Sample Output 3:</h3>
<pre><code class="language-out">10 15 8
10 15 9
10 28 34
10 28 12 56
Not Heap
</code></pre>
<hr>
<p>题目描述：先理解堆的定义，堆分为最大堆，最小堆。题目给出一组数，有可能是堆或不是。如果是堆，则表示树的层次序列值。堆的构建是在满二叉树的基础上的，所以比较容易判断是最大堆还是最小堆。</p>
<p>最大堆：root结点的值大于其左右子结点的值。</p>
<p>最小堆：root结点的值小于其左右子结点的值。</p>
</br>
<p>解题思路：用数组存题目给出的树，一般舍去索引0，从1开始存值，当root索引为index时，左节点索引为index*2，右节点索引为index*2+1。判断v[index]的值是否都大于v[index*2]、v[index*2+1]，如果是就是最大堆；判断v[index]的值是否都小于v[index*2]、v[index*2+1]，如果是则为最小堆。如果都不是最大堆、最小堆，输出Not Heap。</p>
<p>并且题目要求输出根节点到叶子结点的路径，输出顺序是右大于左。</p>
<hr>
<pre><code class="language-c++">#include&lt;bits/stdc++.h&gt;
using namespace std;
int n;
vector&lt;int&gt; v, tv, ttv;
vector&lt; vector&lt;int&gt; &gt; ans;
int judge(){
	int f1=true, f2=true, l, r;
	for(int i=1; i&lt;=n; i++){
		l = i*2; r = i*2+1;
		if(l&lt;=n){
			if(f1&amp;&amp;v[i]&lt;v[l]) f1 = false;
			if(f2&amp;&amp;v[i]&gt;v[l]) f2 = false;
		}
		if(r&lt;=n){
			if(f1&amp;&amp;v[i]&lt;v[r]) f1 = false;
			if(f2&amp;&amp;v[i]&gt;v[r]) f2 = false;
		}
	}
	if(f1==true&amp;&amp;f2==false) return 1;
	if(f2==true&amp;&amp;f1==false) return -1;
	return 0;
}
void dfs(int index){
	int l=index*2, r=index*2+1;
	tv.push_back(v[index]);
	if(l&gt;n&amp;&amp;r&gt;n){
		ans.push_back(tv);
		return ;
	}
	if(r&lt;=n){
		dfs(r);
		tv.pop_back();
	}
	if(l&lt;=n){
		dfs(l);
		tv.pop_back();
	}
}
int main()
{
	scanf(&quot;%d&quot;, &amp;n);
	v.resize(n+1);
	for(int i=1; i&lt;=n; i++) scanf(&quot;%d&quot;, &amp;v[i]);
	int flag = judge();
	dfs(1);
	for(int i=0; i&lt;ans.size(); i++){
		for(int j=0; j&lt;ans[i].size(); j++){
			if(j) printf(&quot; &quot;);
			printf(&quot;%d&quot;, ans[i][j]);
		}
		printf(&quot;\n&quot;);
	}
	if(flag==0) printf(&quot;Not Heap\n&quot;);
	else if(flag==1) printf(&quot;Max Heap\n&quot;);
	else if(flag==-1) printf(&quot;Min Heap\n&quot;);
	return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[1105 Spiral Matrix (25分)题解]]></title>
        <id>https://ygytl.github.io/post/1105-spiral-matrix-25-fen-ti-jie/</id>
        <link href="https://ygytl.github.io/post/1105-spiral-matrix-25-fen-ti-jie/">
        </link>
        <updated>2020-07-01T08:24:12.000Z</updated>
        <content type="html"><![CDATA[<p>1105 Spiral Matrix (25分)</p>
<p>This time your job is to fill a sequence of <em>N</em> positive integers into a <strong>spiral matrix</strong> in non-increasing order. A spiral matrix is filled in from the first element at the upper-left corner, then move in a clockwise spiral. The matrix has <em>m</em> rows and <em>n</em> columns, where <em>m</em> and <em>n</em> satisfy the following: <em>m</em>×<em>n</em> must be equal to <em>N</em>; <em>m</em>≥<em>n</em>; and <em>m</em>−<em>n</em> is the minimum of all the possible values.</p>
<h3 id="input-specification">Input Specification:</h3>
<p>Each input file contains one test case. For each case, the first line gives a positive integer <em>N</em>. Then the next line contains <em>N</em> positive integers to be filled into the spiral matrix. All the numbers are no more than 104. The numbers in a line are separated by spaces.</p>
<h3 id="output-specification">Output Specification:</h3>
<p>For each test case, output the resulting matrix in <em>m</em> lines, each contains <em>n</em> numbers. There must be exactly 1 space between two adjacent numbers, and no extra space at the end of each line.</p>
<h3 id="sample-input">Sample Input:</h3>
<pre><code class="language-in">12
37 76 20 98 76 42 53 95 60 81 58 93
</code></pre>
<h3 id="sample-output">Sample Output:</h3>
<pre><code class="language-out">98 95 93
42 37 81
53 20 76
58 60 76
</code></pre>
<hr>
<p>题目描述：将一组数用二维数组的形式输出(类似漩涡)，m-行，n-列，要求m&gt;=n。</p>
<p>解题思路：将题目给的数组从大到小排序，然后求出二维数组的行和列，再往里面填值就行了。可以用一个二维数组vis记录哪个空是填了值的，比较方便。(在ccf真题中有一道题与这题类似，难度在第二道题)</p>
<hr>
<pre><code class="language-c++">#include&lt;bits/stdc++.h&gt;
using namespace std;
const int maxn = 1e4 + 5;
int v[maxn];
vector&lt;vector&lt;int&gt; &gt; G;
vector&lt;vector&lt;bool&gt; &gt; vis;
bool cmp(int a, int b){
	return a &gt; b;
}
int main()
{
	int n, k, x, y;
	scanf(&quot;%d&quot;, &amp;n);
	for(int i=0; i&lt;n; i++) scanf(&quot;%d&quot;, &amp;v[i]);
	sort(v, v+n, cmp);
	x = sqrt(n)+1;
	for(int i=x; i&gt;=1; i--){
		if(n%i==0){
			x = i;
			break;
		}
	}
	y = min(x,n/x); x = max(x,n/x);
	if(y==1){
		for(int i=0; i&lt;n; i++) printf(&quot;%d\n&quot;, v[i]);
		return 0;
	}
	G.resize(x+1); vis.resize(x+1);
	for(int i=1; i&lt;=x; i++){
		G[i].resize(y+2);
		vis[i].resize(y+2);
		vis[i][0] = false; vis[i][y+1] = false;
		for(int j=1; j&lt;=y; j++) vis[i][j] = true;
	}
	int i = 1, j = 1, c=0;
	while(vis[i][j]&amp;&amp;c&lt;n){//圈 
		while(j&lt;=y&amp;&amp;vis[i][j]){
			G[i][j] = v[c];
			vis[i][j] = false;
			c++; j++;
		}
		i++; j--;
		while(i&lt;=x&amp;&amp;vis[i][j]){
			G[i][j] = v[c];
			vis[i][j] = false;
			c++; i++;
		}
		i--; j--;
		while(j&gt;=1&amp;&amp;vis[i][j]){
			G[i][j] = v[c];
			vis[i][j] = false;
			c++; j--;
		}
		j++; i--;
		while(i&gt;=1&amp;&amp;vis[i][j]){
			G[i][j] = v[c];
			vis[i][j] = false;
			c++; i--;
		}
		i++; j++;
	}
	for(i=1; i&lt;=x; i++){
		for(j=1; j&lt;=y; j++){
			if(j!=1) printf(&quot; &quot;);
			printf(&quot;%d&quot;, G[i][j]);
		}
		printf(&quot;\n&quot;);
	}
	return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[1093 Count PAT's (25分)题解]]></title>
        <id>https://ygytl.github.io/post/1093-count-pats-25-fen-ti-jie/</id>
        <link href="https://ygytl.github.io/post/1093-count-pats-25-fen-ti-jie/">
        </link>
        <updated>2020-06-23T06:31:10.000Z</updated>
        <content type="html"><![CDATA[<p>1093 Count PAT's (25分)</p>
<p>The string <code>APPAPT</code> contains two <code>PAT</code>'s as substrings. The first one is formed by the 2nd, the 4th, and the 6th characters, and the second one is formed by the 3rd, the 4th, and the 6th characters.</p>
<p>Now given any string, you are supposed to tell the number of <code>PAT</code>'s contained in the string.</p>
<h3 id="input-specification">Input Specification:</h3>
<p>Each input file contains one test case. For each case, there is only one line giving a string of no more than 105 characters containing only <code>P</code>, <code>A</code>, or <code>T</code>.</p>
<h3 id="output-specification">Output Specification:</h3>
<p>For each test case, print in one line the number of <code>PAT</code>'s contained in the string. Since the result may be a huge number, you only have to output the result moded by 1000000007.</p>
<h3 id="sample-input">Sample Input:</h3>
<pre><code class="language-in">APPAPT
</code></pre>
<h3 id="sample-output">Sample Output:</h3>
<pre><code class="language-out">2
</code></pre>
<hr>
<p>题目描述：计算字符串PAT的个数</p>
<p>解题思路：动态规划的思想。</p>
<p>分析一个测试用例：APPAPAAT，输出8</p>
<table>
<thead>
<tr>
<th></th>
<th>A</th>
<th>P</th>
<th>P</th>
<th>A</th>
<th>P</th>
<th>A</th>
<th>A</th>
<th>T</th>
</tr>
</thead>
<tbody>
<tr>
<td>P数组</td>
<td>0</td>
<td>1</td>
<td>2</td>
<td><strong>2</strong></td>
<td>3</td>
<td><strong>3</strong></td>
<td><strong>3</strong></td>
<td>3</td>
</tr>
<tr>
<td>PA数组</td>
<td>0</td>
<td>0</td>
<td><strong>0</strong></td>
<td><strong>0+2=2</strong></td>
<td><strong>2</strong></td>
<td><strong>2+3=5</strong></td>
<td><strong>5+3=8</strong></td>
<td><strong>8</strong></td>
</tr>
<tr>
<td>PAT个数</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td><strong>0</strong></td>
<td><strong>0+8=8</strong></td>
</tr>
</tbody>
</table>
<hr>
<pre><code class="language-c++">#include&lt;bits/stdc++.h&gt;
using namespace std;
const int maxn = 1e5+5;
int p[maxn], pa[maxn];
int main()
{
	int c = 0, tp = 0, tpa = 0, ans = 0;
	string s;
	cin &gt;&gt; s;
	int l = s.length();
	for(int i=0; i&lt;l; i++){
		if(s[i]=='P') p[i] = tp++;
		p[i] = tp;
		
		if(s[i]=='A') tpa += p[i];
		pa[i] = tpa;
		
		if(s[i]=='T'){
			ans += pa[i];
			ans %= 1000000007;
		}
	}
	printf(&quot;%d&quot;, ans);
	return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[1089 Insert or Merge (25分)题解]]></title>
        <id>https://ygytl.github.io/post/1089-insert-or-merge-25-fen-ti-jie/</id>
        <link href="https://ygytl.github.io/post/1089-insert-or-merge-25-fen-ti-jie/">
        </link>
        <updated>2020-06-22T14:56:10.000Z</updated>
        <content type="html"><![CDATA[<p>1089 Insert or Merge (25分)</p>
<p>According to Wikipedia:</p>
<p><strong>Insertion sort</strong> iterates, consuming one input element each repetition, and growing a sorted output list. Each iteration, insertion sort removes one element from the input data, finds the location it belongs within the sorted list, and inserts it there. It repeats until no input elements remain.</p>
<p><strong>Merge sort</strong> works as follows: Divide the unsorted list into N sublists, each containing 1 element (a list of 1 element is considered sorted). Then repeatedly merge two adjacent sublists to produce new sorted sublists until there is only 1 sublist remaining.</p>
<p>Now given the initial sequence of integers, together with a sequence which is a result of several iterations of some sorting method, can you tell which sorting method we are using?</p>
<h3 id="input-specification">Input Specification:</h3>
<p>Each input file contains one test case. For each case, the first line gives a positive integer <em>N</em> (≤100). Then in the next line, <em>N</em> integers are given as the initial sequence. The last line contains the partially sorted sequence of the <em>N</em> numbers. It is assumed that the target sequence is always ascending. All the numbers in a line are separated by a space.</p>
<h3 id="output-specification">Output Specification:</h3>
<p>For each test case, print in the first line either &quot;Insertion Sort&quot; or &quot;Merge Sort&quot; to indicate the method used to obtain the partial result. Then run this method for one more iteration and output in the second line the resuling sequence. It is guaranteed that the answer is unique for each test case. All the numbers in a line must be separated by a space, and there must be no extra space at the end of the line.</p>
<h3 id="sample-input-1">Sample Input 1:</h3>
<pre><code class="language-in">10
3 1 2 8 7 5 9 4 6 0
1 2 3 7 8 5 9 4 6 0
</code></pre>
<h3 id="sample-output-1">Sample Output 1:</h3>
<pre><code class="language-out">Insertion Sort
1 2 3 5 7 8 9 4 6 0
</code></pre>
<h3 id="sample-input-2">Sample Input 2:</h3>
<pre><code class="language-in">10
3 1 2 8 7 5 9 4 0 6
1 3 2 8 5 7 4 9 0 6
</code></pre>
<h3 id="sample-output-2">Sample Output 2:</h3>
<pre><code class="language-out">Merge Sort
1 2 3 8 4 5 7 9 0 6
</code></pre>
<hr>
<p>考察插入排序和归并排序</p>
<p>输入：第一行数组有n个数，第二行为需要排序的数组，第三行为已部分排好序的数组。</p>
<p>输出：判断输入的第三行数列是依照哪种排序规则进行排序的，并输出下一步排好序的数列</p>
<p>注意：测试点4，给出的数组序列可能存在相等元素。</p>
</br>
<p>解题思路：首先要知道插入排序和归并排序的排序方法、步骤。</p>
<p>插入排序：从需要排序的数组索引0开始进行排序。以样例1为例：</p>
<p>原始数组：3 1 2 8 7 5 9 4 6 0</p>
<p>1)<strong>3</strong> 1 2 8 7 5 9 4 6 0---对 (索引0) 的元素进行排序</p>
<p>2)<strong>1</strong> 3 2 8 7 5 9 4 6 0---对 (索引0~1) 的元素进行排序</p>
<p>3)1 <strong>2</strong> 3 8 7 5 9 4 6 0---对 (索引0~2) 的元素进行排序</p>
<p>...</p>
<p>归并排序的思想：</p>
<p>1)将数组元素两两进行排序</p>
<p>2)将数组元素44进行排序</p>
<p>3)将数组元素88进行排序</p>
<p>若最后一组不够元素，也要将他们进行排序</p>
<hr>
<pre><code class="language-c++">#include&lt;bits/stdc++.h&gt;
using namespace std;
vector&lt;int&gt; a, b;
int n, g;
int judge(){
	int t;
	t = b[0];
	for(int i=1; i&lt;n; i++){
		if(b[i]&gt;=t){
			g = i;
			t = b[i];
		}
		else break;
	}
	for(int i=g+1; i&lt;n; i++){
		if(a[i]!=b[i]) return 1;//Merge
	}
	return 2;//Insert
}

void solve1(){
	printf(&quot;Merge Sort\n&quot;);
	bool f = true;
	int t = 1;
	while(f){
		f = false;
		for(int i=0; i&lt;n; i++){
			if(a[i]!=b[i]){
				f = true;
				break;
			}
		}
		t*=2;
		for(int i=0; i&lt;n; i+=t){
			if(i+t&lt;n) sort(a.begin()+i,a.begin()+i+t);
			else sort(a.begin()+i,a.begin()+n);
		}
	}
	for(int i=0; i&lt;n; i++){
		if(i) printf(&quot; &quot;);
		printf(&quot;%d&quot;, a[i]);
	}
}

void solve2(){
	printf(&quot;Insertion Sort\n&quot;);
	sort(b.begin(),b.begin()+g+2);
	for(int i=0; i&lt;n; i++){
		if(i) printf(&quot; &quot;);
		printf(&quot;%d&quot;, b[i]);
	}
}

int main()
{
	int k;
	scanf(&quot;%d&quot;, &amp;n);
	for(int i=0; i&lt;n; i++){
		scanf(&quot;%d&quot;, &amp;k);
		a.push_back(k);
	}
	for(int i=0; i&lt;n; i++){
		scanf(&quot;%d&quot;, &amp;k);
		b.push_back(k);
	}
	g = 0;
	int flag = judge();
	if(flag==2) solve2();
	else solve1();
	return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Crackme.exe脱壳与破解]]></title>
        <id>https://ygytl.github.io/post/crackmeexe-tuo-ke-yu-po-jie/</id>
        <link href="https://ygytl.github.io/post/crackmeexe-tuo-ke-yu-po-jie/">
        </link>
        <updated>2020-06-12T15:37:49.000Z</updated>
        <content type="html"><![CDATA[<h4 id="1-首先使用peid工具对软件进行分析查看是否有壳">1.** <em><strong>*首先使用PEid工具对软件进行分析，查看是否有壳*</strong></em></h4>
<p>答：.pediy区块是外壳程序所加载的部分，所以改程序有壳。</p>
<p><img src="https://ygytl.github.io//post-images/1592064469029.JPG" alt="img" loading="lazy"><br>
<img src="https://ygytl.github.io//post-images/1592064480279.JPG" alt="img" loading="lazy"></p>
 </br>
</br>
<h4 id="2-若有壳按照所学的脱壳方式进行脱壳"><strong>2.</strong> <em><strong>*若有壳，按照所学的脱壳方式进行脱壳*</strong></em></h4>
<h5 id="1查找程序的原始入口oep根据跨段指令寻找oep"><em><strong>*(1)查找程序的原始入口OEP，根据跨段指令寻找OEP*</strong></em></h5>
<ol>
<li>运行OllyDbg，调试选项中“Event”将暂停点设置在主模块的入口点。打开CRACKME.EXE，程序会停在00408000h处。</li>
</ol>
<figure data-type="image" tabindex="1"><img src="https://ygytl.github.io//post-images/1592064507296.JPG" alt="img" loading="lazy"></figure>
 </br>
<p>2)按F8执行到00408001h处，再按F7跳转到004080C8h处。</p>
<figure data-type="image" tabindex="2"><img src="https://ygytl.github.io//post-images/1592064514406.JPG" alt="img" loading="lazy"></figure>
 </br>
<p>3)004080C8h一直运行到00408135h处，会跳转到00020000h处。</p>
<figure data-type="image" tabindex="3"><img src="https://ygytl.github.io//post-images/1592064528201.JPG" alt="img" loading="lazy"></figure>
<figure data-type="image" tabindex="4"><img src="https://ygytl.github.io//post-images/1592064538968.JPG" alt="img" loading="lazy"></figure>
<p>跳转后：</p>
<figure data-type="image" tabindex="5"><img src="https://ygytl.github.io//post-images/1592064549310.JPG" alt="img" loading="lazy"></figure>
 </br>
<p>4)从00020000h执行到000200A5h处，000200A5h到000200F0h处是一个循环,右键选中000200F2h处，按F4跳出循环到000200F2h处。</p>
<figure data-type="image" tabindex="6"><img src="https://ygytl.github.io//post-images/1592064559504.JPG" alt="img" loading="lazy"></figure>
 </br>
<p>5)从000200F2h处执行到00020147h处，jmp short 00020147指令表示00020147h处到00020178h处是一个循环；jmp short 0002010C指令表示0002010Ch处到0002017Dh处是一个循环；跳出这两个循环，到0002017Fh处。</p>
<figure data-type="image" tabindex="7"><img src="https://ygytl.github.io//post-images/1592064568427.JPG" alt="img" loading="lazy"></figure>
 </br>
<p>6)0002017Fh处会跳转到000201F6h处。</p>
<figure data-type="image" tabindex="8"><img src="https://ygytl.github.io//post-images/1592064578621.JPG" alt="img" loading="lazy"></figure>
<figure data-type="image" tabindex="9"><img src="https://ygytl.github.io//post-images/1592064611770.JPG" alt="img" loading="lazy"></figure>
 </br>
<ol start="7">
<li>从0000201F6h处执行到00020282h处、00020283h处、00020283h处，分别可以看到popad、push 401000、retn。至此，OEP就找到了，是401000。</li>
</ol>
<figure data-type="image" tabindex="10"><img src="https://ygytl.github.io//post-images/1592064623616.JPG" alt="img" loading="lazy"></figure>
 </br>
<figure data-type="image" tabindex="11"><img src="https://ygytl.github.io//post-images/1592064634601.JPG" alt="img" loading="lazy"></figure>
 </br>
<h5 id="2抓取内存映像文件"><em><strong>*(2)抓取内存映像文件*</strong></em></h5>
<p>1)运行CRACKME.EXE程序，运行LordPE，在LordPE的选项中勾选“Full dump header from disk”，在窗口选择CRACKME，点击右键，执行“修正镜像大小”，接着执行“dump full(完整转存)”命令，即可转去内存数据并保存在文件里。命名为dumped.exe。</p>
<figure data-type="image" tabindex="12"><img src="https://ygytl.github.io//post-images/1592064647371.JPG" alt="img" loading="lazy"></figure>
<figure data-type="image" tabindex="13"><img src="https://ygytl.github.io//post-images/1592064654957.JPG" alt="img" loading="lazy"></figure>
 </br>
2) dumped.exe文件是不可运行的
<figure data-type="image" tabindex="14"><img src="https://ygytl.github.io//post-images/1592064667914.JPG" alt="img" loading="lazy"></figure>
 </br>
<h5 id="3重建输入表"><em><strong>*(3)重建输入表*</strong></em></h5>
<p>1)使用ImportREC工具进行修复。先运行CRACKME.EXE，接着运行ImportREC。<br>
<img src="https://ygytl.github.io//post-images/1592064676429.JPG" alt="img" loading="lazy"></p>
</br>
<p>2)在下列表框中选择CRACKME.EXE进程，在OEP处填入OEP的RVA值1000，单击“IAT AutoSearch”按钮，让其自动检查IAT的偏移和大小。弹出如下对话框：</p>
<figure data-type="image" tabindex="15"><img src="https://ygytl.github.io//post-images/1592064686437.JPG" alt="img" loading="lazy"></figure>
<p>表示输入的OEP发挥作用了。</p>
<p>3)单击“Get Imports”按钮，让其分析IAT结构得到基本信息</p>
<figure data-type="image" tabindex="16"><img src="https://ygytl.github.io//post-images/1592064696874.JPG" alt="img" loading="lazy"></figure>
 </br>
<p>4)单击“Fix Dump”，选择刚才抓取的dumped.exe映像文件，将自动创建一个dumped_.exe文件。这个就是脱壳后的文件了，该文件可以正常运行。接着使用PEiD.exe查看脱壳前后的区段表。</p>
<p>脱壳前：</p>
<figure data-type="image" tabindex="17"><img src="https://ygytl.github.io//post-images/1592064705124.JPG" alt="img" loading="lazy"></figure>
<p>脱壳后：</p>
<figure data-type="image" tabindex="18"><img src="https://ygytl.github.io//post-images/1592064713911.JPG" alt="img" loading="lazy"></figure>
 </br>
<h4 id="3脱壳后再对软件代码进行分析分析出自己姓名所对应的正确的序列号"><em><strong>*3.脱壳后再对软件代码进行分析，分析出自己姓名所对应的正确的序列号*</strong></em></h4>
<p>1)打开OllyDbg，选择dumped_.exe进行分析。</p>
<figure data-type="image" tabindex="19"><img src="https://ygytl.github.io//post-images/1592064722160.JPG" alt="img" loading="lazy"></figure>
 </br>
<p>2)先在00401226h处设置断点,在注册表填入自定义姓名和序列号。</p>
<figure data-type="image" tabindex="20"><img src="https://ygytl.github.io//post-images/1592064730216.JPG" alt="img" loading="lazy"></figure>
 </br>
<p>3)按F9后，得到下图所示；在00401228h处显示了Name框的内容，在00401233h处显示了序列号Serial框的内容。</p>
<p><img src="https://ygytl.github.io//post-images/1592064737550.JPG" alt="img" loading="lazy"><br>
</br><br>
4)接下来分析下图语句，首先是一个用户名的计算函数，然后是一个序列号的计算函数，接着比较两个函数计算的结果是否相等，相等则提示正确。</p>
<figure data-type="image" tabindex="21"><img src="https://ygytl.github.io//post-images/1592064744857.JPG" alt="img" loading="lazy"></figure>
<pre><code>00401228h call dumped_.0040137E  //用户名的计算函数

00401238h call dumped_.004013D8  //序列号的计算函数

00401241h cmp eax,ebx  //比较用户名字和序列号计算的结果

00401243h je short dumped_.0040124C  //相等则提示正确

00401245h call dumped_.00401362  //错误提示

0040124Ch call dumped_.0040134D  //正确提示
</code></pre>
 </br>
 5)用户名算法分析
<figure data-type="image" tabindex="22"><img src="https://ygytl.github.io//post-images/1592064753430.JPG" alt="img" loading="lazy"></figure>
<p>0040137Eh先取出用户名，依次去出名字字符串的单字符，将用户名中的英文单词全部转换为大写。</p>
<p>0040137Eh mov esi, dword ptr ss:[esp+0x4]  //esi=username</p>
<p>00401389h cmp a1, 0x41  //比较是否小于A</p>
<p>0040138Dh cmp a1, 0x5A  //比较是否大于Z</p>
<p>00401391h Inc esi  //username&gt;&gt;1</p>
<p>00401394h call dumped_.004013D2  //将小写字母转成大写</p>
<figure data-type="image" tabindex="23"><img src="https://ygytl.github.io//post-images/1592064763096.JPG" alt="img" loading="lazy"></figure>
<p>接着进入4013C2这个函数，将用户名每一位的ASCII值相加。</p>
<figure data-type="image" tabindex="24"><img src="https://ygytl.github.io//post-images/1592064770608.JPG" alt="img" loading="lazy"></figure>
 </br>
<p>6)序列号算法分析</p>
<figure data-type="image" tabindex="25"><img src="https://ygytl.github.io//post-images/1592064778269.JPG" alt="img" loading="lazy"></figure>
<p>取出每一位的ASCII值，然后减去0x30，即将字母转化为数字然后用edi乘0xA(0x10)，接着用edi再加上序列号。（edi与0x1234进行异或）</p>
 </br>
<p>序列号edi校验：</p>
<figure data-type="image" tabindex="26"><img src="https://ygytl.github.io//post-images/1592064802509.JPG" alt="img" loading="lazy"></figure>
 </br>
<p>比较edi与ebx是否相等：</p>
<figure data-type="image" tabindex="27"><img src="https://ygytl.github.io//post-images/1592064811680.JPG" alt="img" loading="lazy"></figure>
<h4 id="4写出注册机代码如下"><em><strong>*4.********写出注册机********代码如下：*</strong></em></h4>
<pre><code class="language-c++">#include&lt;bits/stdc++.h&gt;

using namespace std;

int main()

{

	string username;

	printf(&quot;请输入用户名: &quot;);

	cin &gt;&gt; username;

	int result = 0, l = username.length();

	for(int i=0; i&lt;l; i++){

		if(username[i]&gt;='a'&amp;&amp;username[i]&lt;='z'){

			username[i] = username[i]-'a' + 'A';

		}

		result += username[i];

	}

	result ^= 0x5678;

	result ^= 0x1234;

	printf(&quot;%d\n&quot;, result);

	return 0;

}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[1088 Rational Arithmetic (20分)题解]]></title>
        <id>https://ygytl.github.io/post/1088-rational-arithmetic-20-fen-ti-jie/</id>
        <link href="https://ygytl.github.io/post/1088-rational-arithmetic-20-fen-ti-jie/">
        </link>
        <updated>2020-06-11T15:33:26.000Z</updated>
        <content type="html"><![CDATA[<p>1088 Rational Arithmetic (20分)</p>
<p>For two rational numbers, your task is to implement the basic arithmetics, that is, to calculate their sum, difference, product and quotient.</p>
<h3 id="input-specification">Input Specification:</h3>
<p>Each input file contains one test case, which gives in one line the two rational numbers in the format <code>a1/b1 a2/b2</code>. The numerators and the denominators are all in the range of long int. If there is a negative sign, it must appear only in front of the numerator. The denominators are guaranteed to be non-zero numbers.</p>
<h3 id="output-specification">Output Specification:</h3>
<p>For each test case, print in 4 lines the sum, difference, product and quotient of the two rational numbers, respectively. The format of each line is <code>number1 operator number2 = result</code>. Notice that all the rational numbers must be in their simplest form <code>k a/b</code>, where <code>k</code> is the integer part, and <code>a/b</code> is the simplest fraction part. If the number is negative, it must be included in a pair of parentheses. If the denominator in the division is zero, output <code>Inf</code> as the result. It is guaranteed that all the output integers are in the range of <strong>long int</strong>.</p>
<h3 id="sample-input-1">Sample Input 1:</h3>
<pre><code class="language-in">2/3 -4/2
</code></pre>
<h3 id="sample-output-1">Sample Output 1:</h3>
<pre><code class="language-out">2/3 + (-2) = (-1 1/3)
2/3 - (-2) = 2 2/3
2/3 * (-2) = (-1 1/3)
2/3 / (-2) = (-1/3)
</code></pre>
<h3 id="sample-input-2">Sample Input 2:</h3>
<pre><code class="language-in">5/3 0/6
</code></pre>
<h3 id="sample-output-2">Sample Output 2:</h3>
<pre><code class="language-out">1 2/3 + 0 = 1 2/3
1 2/3 - 0 = 1 2/3
1 2/3 * 0 = 0
1 2/3 / 0 = Inf
</code></pre>
<hr>
<p>题目意思：求分数的加减乘除</p>
<p>输出规则：负数需要带括号输出。假分数要以标准格式输出。</p>
</br>
<p>解题思路：每个分数的输出格式都是同意的规则，将这个输出搞定就行了。</p>
<p>注意：数据类型要是long long类型，否则测试点2会报错。</p>
<hr>
<pre><code class="language-c++">#include&lt;bits/stdc++.h&gt;
using namespace std;
long long gcd(long long a, long long b){
	if(a==0) return b;
	gcd(b%a,a);
}
void com(long long x, long long y){
	long long g, c;
	bool f = false;
	g = gcd(abs(x),abs(y));
	x/=g; y/=g;
	c = x/y;
	if(c&lt;0) x *= -1;
	x %= y;
	if(c!=0){
		if(c&lt;0){
			printf(&quot;(%lld&quot;, c);
			f = true;
		}
		else printf(&quot;%lld&quot;, c);
	}
	if(x&lt;0){
		printf(&quot;(%lld&quot;, x);
		f = true;
	}
	else{
		if(c==0) printf(&quot;%lld&quot;, x);
		else if(c!=0&amp;&amp;x!=0) printf(&quot; %lld&quot;, x);
	}
	if(x!=0&amp;&amp;y!=1){
		printf(&quot;/%lld&quot;, y);
	}
	if(f) printf(&quot;)&quot;);
}
void solve1(long long a1, long long b1, long long a2, long long b2){
	com(a1,b1); printf(&quot; + &quot;);
	com(a2,b2); printf(&quot; = &quot;);
	long long a, b;
	b = b1*b2;
	a = a1*b2 + a2*b1;
	com(a,b);
}
void solve2(long long a1, long long b1, long long a2, long long b2){
	com(a1,b1); printf(&quot; - &quot;);
	com(a2,b2); printf(&quot; = &quot;);
	long long a, b;
	b = b1*b2;
	a = a1*b2 - a2*b1;
	com(a,b);
}
void solve3(long long a1, long long b1, long long a2, long long b2){
	com(a1,b1); printf(&quot; * &quot;);
	com(a2,b2); printf(&quot; = &quot;);
	if(a1==0||a2==0){
		printf(&quot;0&quot;);
		return ;
	}
	long long a, b;
	a = a1*a2; b = b1*b2;
	if(b&lt;0){
		b*=-1;
		a*=-1;
	}
	com(a,b);
}
void solve4(long long a1, long long b1, long long a2, long long b2){
	com(a1,b1); printf(&quot; / &quot;);
	com(a2,b2); printf(&quot; = &quot;);
	if(a2==0){
		printf(&quot;Inf&quot;);
		return ;
	}
	long long a, b;
	a = a1*b2; b = b1*a2;
	if(b&lt;0){
		b*=-1;
		a*=-1;
	}
	com(a,b);
}

int main()
{
	long long a1, b1, a2, b2;
	scanf(&quot;%lld/%lld %lld/%lld&quot;, &amp;a1, &amp;b1, &amp;a2, &amp;b2);
	solve1(a1,b1,a2,b2); printf(&quot;\n&quot;);
	solve2(a1,b1,a2,b2); printf(&quot;\n&quot;);
	solve3(a1,b1,a2,b2); printf(&quot;\n&quot;);
	solve4(a1,b1,a2,b2); printf(&quot;\n&quot;);
	return 0;
}
</code></pre>
]]></content>
    </entry>
</feed>